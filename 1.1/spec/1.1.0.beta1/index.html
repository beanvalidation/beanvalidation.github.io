<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <style type="text/css">
div.added    { background-color: #ffff99; }
div.deleted  { text-decoration: line-through;
               background-color: #FF7F7F; }
div.changed  { background-color: #99ff99; }
div.off      {  }

span.added   { background-color: #ffff99; }
span.deleted { text-decoration: line-through;
               background-color: #FFDDDD; }
span.changed { background-color: #99ff99; }
span.off     {  }
</style><title>Bean Validation specification</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>Bean Validation specification</h1></div><div><div class="authorgroup"><h3 class="corpauthor">Bean Validation Expert Group</h3><div class="author"><h3 class="author"><span class="firstname">Emmanuel</span> <span class="surname">Bernard</span></h3><div class="affiliation"><span class="orgname">Red Hat, Inc.<br></span></div></div></div></div><div><p class="releaseinfo">1.1.0.Beta1 (public review draft 1)</p></div><div><p class="copyright">Copyright &copy; 2007-2012 Red Hat, Inc</p></div><div><p class="pubdate">2012-10-19</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#license">Evaluation license</a></span></dt><dt><span class="chapter"><a href="#introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e100">1.1. Expert group</a></span></dt><dt><span class="section"><a href="#d0e223">1.2. Specification goals</a></span></dt><dt><span class="section"><a href="#d0e237">1.3. Required Java version</a></span></dt><dt><span class="section"><a href="#d0e242">1.4. How this document is organized</a></span></dt><dt><span class="section"><a href="#d0e273">1.5. Changes applied since between 1.0 and this draft</a></span></dt><dt><span class="section"><a href="#d0e290">1.6. How to comment</a></span></dt></dl></dd><dt><span class="chapter"><a href="#whatsnew">2. What's new in 1.1</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e303">2.1. Openness</a></span></dt><dt><span class="section"><a href="#d0e313">2.2. Dependency injection</a></span></dt><dt><span class="section"><a href="#d0e330">2.3. Method validation</a></span></dt><dt><span class="section"><a href="#d0e351">2.4. Integration with Context and Dependency Injection</a></span></dt><dt><span class="section"><a href="#d0e356">2.5. Group conversion</a></span></dt><dt><span class="section"><a href="#d0e361">2.6. Others</a></span></dt></dl></dd><dt><span class="chapter"><a href="#constraintsdefinitionimplementation">3. Constraint Definition</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintdefinition">3.1. Constraint annotation</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintdefinition-properties">3.1.1. Constraint definition properties</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintdefinition-parameters-message">3.1.1.1. message</a></span></dt><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintdefinition-groups">3.1.1.2. groups</a></span></dt><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintdefinition-payload">3.1.1.3. payload</a></span></dt><dt><span class="section"><a href="#d0e632">3.1.1.4. Constraint specific parameter</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e640">3.1.2. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#constraintsdefinitionimplementation-multipleconstraints">3.2. Applying multiple constraints of the same type</a></span></dt><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintcomposition">3.3. Constraint composition</a></span></dt><dt><span class="section"><a href="#constraintsdefinitionimplementation-validationimplementation">3.4. Constraint validation implementation</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintsdefinitionimplementation-validationimplementation-example">3.4.1. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintfactory">3.5. The ConstraintValidatorFactory</a></span></dt></dl></dd><dt><span class="chapter"><a href="#constraintdeclarationvalidationprocess">4. Constraint declaration and validation process</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-requirements">4.1. Requirements on classes to be validated</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-requirements-object">4.1.1. Object validation</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-requirements-property">4.1.2. Field and property validation</a></span></dt><dt><span class="section"><a href="#d0e1372">4.1.3. Graph validation</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1458">4.2. Constraint declaration</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-inheritance">4.3. Inheritance (interface and superclass)</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence">4.4. Group and group sequence</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence-groupinheritance">4.4.1. Group inheritance</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence-groupsequence">4.4.2. Group sequence</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup">4.4.3. Redefining the Default group for a class</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence-implicitgrouping">4.4.4. Implicit grouping</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence-groupconversion">4.4.5. Group conversion</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2010">4.4.5.1. Group conversion example</a></span></dt></dl></dd><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence-formaldefinition">4.4.6. Formal group definitions</a></span></dt></dl></dd><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-methodlevelconstraints">4.5. Method and constructor constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2495">4.5.1. Requirements on methods to be validated</a></span></dt><dt><span class="section"><a href="#d0e2503">4.5.2. Declare parameter constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-crossparameterconstraints">4.5.2.1. Cross-parameter constraints</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-methodlevelconstraints-definingparameterconstraints-namingparameters">4.5.2.2. Naming parameters</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2642">4.5.3. Declaring return value constraints</a></span></dt><dt><span class="section"><a href="#d0e2696">4.5.4. Marking parameters and return values for cascaded
      validation</a></span></dt><dt><span class="section"><a href="#d0e2780">4.5.5. Method constraints in inheritance hierarchies</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2820">4.5.5.1. Examples</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-validationroutine">4.6. Validation routine</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation">4.6.1. Object graph validation</a></span></dt><dt><span class="section"><a href="#d0e3133">4.6.2. Method validation</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-validationroutine-traversable">4.6.3. Traversable property</a></span></dt><dt><span class="section"><a href="#typevalidatorresolution">4.6.4. ConstraintValidator resolution algorithm</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3792">4.7. Examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#validationapi">5. Validation APIs</a></span></dt><dd><dl><dt><span class="section"><a href="#validationapi-validatorapi">5.1. Validator API</a></span></dt><dd><dl><dt><span class="section"><a href="#validationapi-validatorapi-validationmethods">5.1.1. Validation methods</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4218">5.1.1.1. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#validationapi-validatorapi-methodlevelvalidationmethods">5.1.2. Methods for validating method and constructor constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4344">5.1.2.1. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#validationapi-validatorapi-groups">5.1.3. groups</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4445">5.1.3.1. Examples</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#validationapi-constraintviolation">5.2. ConstraintViolation</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5392">5.2.1. Examples</a></span></dt><dt><span class="section"><a href="#d0e5451">5.2.2. Examples for method/constructor constraint violations</a></span></dt></dl></dd><dt><span class="section"><a href="#validationapi-message">5.3. Message interpolation</a></span></dt><dd><dl><dt><span class="section"><a href="#default-messageresolver">5.3.1. Default message interpolation</a></span></dt><dd><dl><dt><span class="section"><a href="#default-resolution-algorithm">5.3.1.1. Default message interpolation algorithm</a></span></dt></dl></dd><dt><span class="section"><a href="#custom-message-resolution">5.3.2. Custom message interpolation</a></span></dt><dt><span class="section"><a href="#validationapi-message-examples">5.3.3. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#validationapi-triggeringmethodvalidation">5.4. Triggering method validation</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5934">5.4.1. PROPOSAL: customizing method interception</a></span></dt></dl></dd><dt><span class="section"><a href="#bootstrapping">5.5. Bootstrapping</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6099">5.5.1. Examples</a></span></dt><dt><span class="section"><a href="#d0e6173">5.5.2. ValidatorFactory</a></span></dt><dt><span class="section"><a href="#d0e6387">5.5.3. Configuration</a></span></dt><dt><span class="section"><a href="#d0e6783">5.5.4. ValidationProvider and ValidationProviderResolver</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6793">5.5.4.1. ValidationProviderResolver</a></span></dt><dt><span class="section"><a href="#id-bootstrap-validationprovider">5.5.4.2. ValidationProvider</a></span></dt></dl></dd><dt><span class="section"><a href="#boostrapping-validation">5.5.5. Validation</a></span></dt><dt><span class="section"><a href="#xml-config">5.5.6. XML Configuration: META-INF/validation.xml</a></span></dt><dt><span class="section"><a href="#bootstrapping-usageandcontainerexpectation">5.5.7. Bootstrapping considerations</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#constraintmetadata">6. Constraint metadata request APIs</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7292">6.1. Validator</a></span></dt><dt><span class="section"><a href="#constraintmetadata-elementdescriptor">6.2. ElementDescriptor</a></span></dt><dt><span class="section"><a href="#d0e7480">6.3. BeanDescriptor</a></span></dt><dt><span class="section"><a href="#d0e7565">6.4. PropertyDescriptor</a></span></dt><dt><span class="section"><a href="#d0e7607">6.5. MethodDescriptor</a></span></dt><dt><span class="section"><a href="#d0e7672">6.6. ConstructorDescriptor</a></span></dt><dt><span class="section"><a href="#d0e7722">6.7. ParameterDescriptor</a></span></dt><dt><span class="section"><a href="#d0e7759">6.8. ReturnValueDescriptor</a></span></dt><dt><span class="section"><a href="#constraintmetadata-constraintdescriptor">6.9. ConstraintDescriptor</a></span></dt><dt><span class="section"><a href="#d0e7844">6.10. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#builtinconstraints">7. Built-in Constraint definitions</a></span></dt><dt><span class="chapter"><a href="#xml">8. XML deployment descriptor</a></span></dt><dd><dl><dt><span class="section"><a href="#xml-mapping">8.1. Constraint definition and declaration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7998">8.1.1. Constraint declaration in XML</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8036">8.1.1.1. Class-level overriding</a></span></dt><dt><span class="section"><a href="#d0e8078">8.1.1.2. Field-level overriding</a></span></dt><dt><span class="section"><a href="#d0e8134">8.1.1.3. Property-level overriding</a></span></dt><dt><span class="section"><a href="#xml-mapping-constraintdeclarationinxml-methodleveloverriding">8.1.1.4. Method-level overriding</a></span></dt><dt><span class="section"><a href="#d0e8204">8.1.1.5. Constraint declaration</a></span></dt></dl></dd><dt><span class="section"><a href="#xml-mapping-constraintdefinition">8.1.2. Overriding constraint definitions in XML</a></span></dt><dt><span class="section"><a href="#xml-mapping-typeconversion">8.1.3. Converting the string representation of a value</a></span></dt><dt><span class="section"><a href="#xml-mapping-xsd">8.1.4. XML Schema</a></span></dt></dl></dd><dt><span class="section"><a href="#xml-config-xsd">8.2. Configuration schema</a></span></dt></dl></dd><dt><span class="chapter"><a href="#exception">9. Exception model</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8596">9.1. Error report:
    ConstraintViolationException</a></span></dt><dt><span class="section"><a href="#d0e8635">9.2. Constraint definition:
    ConstraintDefinitionException</a></span></dt><dt><span class="section"><a href="#d0e8656">9.3. Constraint declaration:
    ConstraintDeclarationException and
    UnexpectedTypeException</a></span></dt><dt><span class="section"><a href="#d0e8701">9.4. Group definition:
    GroupDefinitionException</a></span></dt></dl></dd><dt><span class="chapter"><a href="#integration">10. Integration</a></span></dt><dd><dl><dt><span class="section"><a href="#integration-javaee">10.1. Java EE</a></span></dt><dt><span class="section"><a href="#d0e8841">10.2. Context and Dependency Injection (CDI)
    integration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8846">10.2.1. ValidatorFactory and
      Validator</a></span></dt><dt><span class="section"><a href="#d0e8950">10.2.2. ConstraintValidatorFactory,
      MessageInterpolator,
      ParameterNameProvider and
      TraversableResolver</a></span></dt><dt><span class="section"><a href="#d0e9041">10.2.3. Method validation</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9064">10.3. Java Persistence 2.0 integration</a></span></dt><dt><span class="section"><a href="#d0e9072">10.4. Java Server Faces 2.0 integration</a></span></dt><dt><span class="section"><a href="#d0e9080">10.5. JAX-RS 2 integration</a></span></dt></dl></dd><dt><span class="appendix"><a href="#terminology">A. Terminology</a></span></dt><dt><span class="appendix"><a href="#standard-resolver-messages">B. Standard ResourceBundle messages</a></span></dt><dt><span class="appendix"><a href="#appendix-jpa">C. Java Persistence 2.0 and schema generation</a></span></dt><dt><span class="appendix"><a href="#changelog">D. Changelog</a></span></dt></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="license"></a>Evaluation license</h2></div></div><div></div></div><p>Copyright 2007-2012 Red Hat Inc.</p><p>All rights reserved.</p><p>NOTICE</p><p>The Specification is protected by copyright and the information
  described therein may be protected by one or more U.S. patents, foreign
  patents, or pending applications. Except as provided under the following
  license, no part of the Specification may be reproduced in any form by any
  means without the prior written authorization of Red Hat Inc. and its
  licensors, if any. Any use of the Specification and the information
  described therein will be governed by the terms and conditions of this
  Agreement.</p><p>Subject to the terms and conditions of this license, including your
  compliance with Paragraphs 1 and 2 below, Red Hat Inc. hereby grants you a
  fully-paid, non-exclusive, non-transferable, limited license (without the
  right to sublicense) under Red Hat Inc.'s intellectual property rights
  to:</p><p>1. Review the Specification for the purposes of evaluation. This
  includes: (i) developing implementations of the Specification for your
  internal, non-commercial use; (ii) discussing the Specification with any
  third party; and (iii) excerpting brief portions of the Specification in
  oral or written communications which discuss the Specification provided that
  such excerpts do not in the aggregate constitute a significant portion of
  the Specification.</p><p>2. Distribute implementations of the Specification to third parties
  for their testing and evaluation use, provided that any such
  implementation:</p><p>(i) does not modify, subset, superset or otherwise extend the Licensor
  Name Space, or include any public or protected packages, classes, Java
  interfaces, fields or methods within the Licensor Name Space other than
  those required/authorized by the Specification or Specifications being
  implemented;</p><p>(ii) is clearly and prominently marked with the word "UNTESTED" or
  "EARLY ACCESS" or "INCOMPATIBLE" or "UNSTABLE" or "BETA" in any list of
  available builds and in proximity to every link initiating its download,
  where the list or link is under Licensee's control; and</p><p>(iii) includes the following notice:</p><p>"This is an implementation of an early-draft specification developed
  under the Java Community Process (JCP). The code is not compatible with any
  specification of the JCP."</p><p>The grant set forth above concerning your distribution of
  implementations of the Specification is contingent upon your agreement to
  terminate development and distribution of your implementation of early draft
  upon final completion of the Specification. If you fail to do so, the
  foregoing grant shall be considered null and void.</p><p>No provision of this Agreement shall be understood to restrict your
  ability to make and distribute to third parties applications written to the
  Specification.</p><p>Other than this limited license, you acquire no right, para or
  interest in or to the Specification or any other Red Hat Inc. intellectual
  property, and the Specification may only be used in accordance with the
  license terms set forth herein. This license will expire on the earlier of:
  (a) two (2) years from the date of Release listed above; (b) the date on
  which the final version of the Specification is publicly released; or (c)
  the date on which the Java Specification Request (JSR) to which the
  Specification corresponds is withdrawn. In addition, this license will
  terminate immediately without notice from Red Hat Inc. if you fail to comply
  with any provision of this license. Upon termination, you must cease use of
  or destroy the Specification.</p><p>"Licensor Name Space" means the public class or interface declarations
  whose names begin with "java", "javax", "com.redhat", "com.jboss",
  "org.jboss", "org.hibernate" or their equivalents in any subsequent naming
  convention adopted through the Java Community Process, or any recognized
  successors or replacements thereof.</p><p>TRADEMARKS</p><p>No right, para, or interest in or to any trademarks, service marks, or
  trade names of Red Hat Inc. or Red Hat's licensors is granted hereunder.
  Java and Java-related logos, marks and names are trademarks or registered
  trademarks of Sun Microsystems, Inc. in the U.S. and other countries.</p><p>DISCLAIMER OF WARRANTIES</p><p>THE SPECIFICATION IS PROVIDED "AS IS" AND IS EXPERIMENTAL AND MAY
  CONTAIN DEFECTS OR DEFICIENCIES WHICH CANNOT OR WILL NOT BE CORRECTED BY RED
  HAT Inc. RED HAT Inc. MAKES NO REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS
  OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT THAT THE CONTENTS OF
  THE SPECIFICATION ARE SUITABLE FOR ANY PURPOSE OR THAT ANY PRACTICE OR
  IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY THIRD PARTY PATENTS,
  COPYRIGHTS, TRADE SECRETS OR OTHER RIGHTS. This document does not represent
  any commitment to release or implement any portion of the Specification in
  any product.</p><p>THE SPECIFICATION COULD INCLUDE TECHNICAL INACCURACIES OR
  TYPOGRAPHICAL ERRORS. CHANGES ARE PERIODICALLY ADDED TO THE INFORMATION
  THEREIN; THESE CHANGES WILL BE INCORPORATED INTO NEW VERSIONS OF THE
  SPECIFICATION, IF ANY. RED HAT Inc. MAY MAKE IMPROVEMENTS AND/OR CHANGES TO
  THE PRODUCT(S) AND/OR THE PROGRAM(S) DESCRIBED IN THE SPECIFICATION AT ANY
  TIME. Any use of such changes in the Specification will be governed by the
  then-current license for the applicable version of the Specification.</p><p>LIMITATION OF LIABILITY</p><p>TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL RED HAT Inc. OR
  ITS LICENSORS BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION, LOST
  REVENUE, PROFITS OR DATA, OR FOR SPECIAL, INDIRECT, CONSEQUENTIAL,
  INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY
  OF LIABILITY, ARISING OUT OF OR RELATED TO ANY FURNISHING, PRACTICING,
  MODIFYING OR ANY USE OF THE SPECIFICATION, EVEN IF RED HAT Inc. AND/OR ITS
  LICENSORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p><p>You will hold Red Hat Inc. (and its licensors) harmless from any
  claims based on your use of the Specification for any purposes other than
  the limited right of evaluation as described above, and from any claims that
  later versions or releases of any Specification furnished to you are
  incompatible with the Specification provided to you under this
  license.</p><p>RESTRICTED RIGHTS LEGEND</p><p>If this Software is being acquired by or on behalf of the U.S.
  Government or by a U.S. Government prime contractor or subcontractor (at any
  tier), then the Government's rights in the Software and accompanying
  documentation shall be only as set forth in this license; this is in
  accordance with 48 C.F.R. 227.7201 through 227.7202-4 (for Department of
  Defense (DoD) acquisitions) and with 48 C.F.R. 2.101 and 12.212 (for non-DoD
  acquisitions).</p><p>REPORT</p><p>You may wish to report any ambiguities, inconsistencies or
  inaccuracies you may find in connection with your evaluation of the
  Specification ("Feedback"). To the extent that you provide Red Hat Inc. with
  any Feedback, you hereby: (i) agree that such Feedback is provided on a
  non-proprietary and non-confidential basis, and (ii) grant Red Hat Inc. a
  perpetual, non-exclusive, worldwide, fully paid-up, irrevocable license,
  with the right to sublicense through multiple levels of sublicensees, to
  incorporate, disclose, and use without limitation the Feedback for any
  purpose related to the Specification and future versions, implementations,
  and test suites thereof.</p><p>GENERAL TERMS</p><p>Any action related to this Agreement will be governed by California
  law and controlling U.S. federal law. The U.N. Convention for the
  International Sale of Goods and the choice of law rules of any jurisdiction
  will not apply.</p><p>The Specification is subject to U.S. export control laws and may be
  subject to export or import regulations in other countries. Licensee agrees
  to comply strictly with all such laws and regulations and acknowledges that
  it has the responsibility to obtain such licenses to export, re-export or
  import as may be required after delivery to Licensee.</p><p>This Agreement is the parties' entire agreement relating to its
  subject matter. It supersedes all prior or contemporaneous oral or written
  communications, proposals, conditions, representations and warranties and
  prevails over any conflicting or additional terms of any quote, order,
  acknowledgment, or other communication between the parties relating to its
  subject matter during the term of this Agreement. No modification to this
  Agreement will be binding, unless in writing and signed by an authorized
  representative of each party.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="introduction"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div><div></div></div><p>This document is the specification of the Java API for JavaBean
  validation in Java EE and Java SE. The technical objective of this work is
  to provide an object level constraint declaration and validation facility
  for the Java application developer, as well as a constraint metadata
  repository and query API.</p><p>It also offers method and constructor validation facilities to ensure
  constraints on their parameters and return values.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e100"></a>1.1.&nbsp;Expert group</h2></div></div><div></div></div><div class="changed"><p>This work is being conducted as part of JSR
    349 and formerly JSR 303 under the Java Community Process Program. This
    specification is the result of the collaborative work of the members of
    the JSR 349 Expert Group and the community at large. The following persons
    have actively contributed to Bean Validation 1.1 in alphabetical
    order:</p></div><div class="added"><div class="itemizedlist"><ul type="disc"><li><p>Matt Benson</p></li><li><p>Paul Benedict</p></li><li><p>Emmanuel Bernard (Red Hat, Inc.) - Specification Lead</p></li><li><p>Edward Burns (Oracle)</p></li><li><p>Peter Davis</p></li><li><p>Hardy Ferentschik (Red Hat, Inc.)</p></li><li><p>Cemalettin Ko&ccedil;</p></li><li><p>Rich Midwinter</p></li><li><p>Gunnar Morling</p></li><li><p>Pete Muir (Red Hat, Inc.)</p></li><li><p>Michael Nascimento Santos</p></li><li><p>Gerhard Petracek</p></li><li><p>Kevin Pollet (SERLI)</p></li><li><p>Jagadish Prasath Ramu (Oracle)</p></li><li><p>Sebastian Thomschke</p></li></ul></div></div><div class="changed"><p>Former expert group members of JSR-303 in
    alphabetical order are:</p></div><div class="itemizedlist"><ul type="disc"><li><p>Geert Bevin</p></li><li><p>Emmanuel Bernard (Red Hat, Inc.) - Specification Lead</p></li><li><p>Uri Boness</p></li><li><p>Erik Brakkee (Ericsson AB)</p></li><li><p>Ed Burns (Sun Microsystems, Inc.)</p></li><li><p>Jason Carreira</p></li><li><p>Robert Clevenger (Oracle - retired)</p></li><li><p>Linda DeMichiel (Sun Microsystems, Inc.)</p></li><li><p>Tim Fennel</p></li><li><p>Bharath Ganesh (Pramati Technologies)</p></li><li><p>Romain Guy (Google Inc.)</p></li><li><p>Robert Harrop</p></li><li><p>Jacob J. Hookom</p></li><li><p>Bob Lee (Google Inc.)</p></li><li><p>Craig R. McClanahan (Sun Microsystems, Inc.)</p></li><li><p>Niall K. Pemberton</p></li><li><p>Steve Peterson</p></li><li><p>Dhanji R. Prasanna (Google Inc., formerly individual)</p></li><li><p>Gerhard Petracek</p></li><li><p>Matt Raible</p></li><li><p>Michael Nascimento Santos</p></li><li><p>Sebastian Thomschke</p></li><li><p>Jon Wetherbee (Oracle)</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e223"></a>1.2.&nbsp;Specification goals</h2></div></div><div></div></div><p>Validating data is a common task that occurs throughout an
    application, from the presentation layer to the persistence layer. Often
    the same validation logic is implemented in each layer, proving to be time
    consuming and error-prone. To avoid duplication of these validations in
    each layer, developers often bundle validation logic directly into the
    domain model, cluttering domain classes with validation code that is, in
    fact, metadata about the class itself.</p><p>This JSR defines a metadata model and API for JavaBean validation.
    The default metadata source is annotations, with the ability to override
    and extend the meta-data through the use of XML validation
    descriptors.</p><p>The validation API developed by this JSR is not intended for use in
    any one tier or programming model. It is specifically not tied to either
    the web tier or the persistence tier, and is available for both
    server-side application programming, as well as rich client Swing
    application developers. This API is seen as a general extension to the
    JavaBeans object model, and as such is expected to be used as a core
    component in other specifications. Ease of use and flexibility have
    influenced the design of this specification.</p><div class="added"><p>As of version 1.1, Bean Validation constraints
    can also be applied to the parameters and return values of methods of
    arbitrary Java types. Thus the Bean Validation API can be used to describe
    and validate the contract (comprising pre- and postconditions) applying to
    a given method ("Programming by Contract", PbC). Note that it is
    <span class="emphasis"><em>not</em></span> the goal of this specification to develop a
    fully-fledged PbC solution but rather an easy-to-use facility satisfying
    the most common needs related to applying constraints to method parameters
    and return values, based on the proven concepts of the Bean Validation
    API.</p></div></div><div class="added"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e237"></a>1.3.&nbsp;Required Java version</h2></div></div><div></div></div><p>The specification uses Java 6.0 language features. There is no
    requirement that implementations be compatible with Java language versions
    prior to 6.0.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e242"></a>1.4.&nbsp;How this document is organized</h2></div></div><div></div></div><p>This document describes each aspect of the bean validation
    specification in a separate chapter. One should remember that the
    specification is a consistent whole.</p><p><a href="#constraintsdefinitionimplementation" title="Chapter&nbsp;3.&nbsp;Constraint Definition">Chapter&nbsp;3, <i>Constraint Definition</i></a> describes how
    constraints are defined.</p><p><a href="#constraintdeclarationvalidationprocess" title="Chapter&nbsp;4.&nbsp;Constraint declaration and validation process">Chapter&nbsp;4, <i>Constraint declaration and validation process</i></a> describes
    how a JavaBean class is decorated with annotations to describe
    constraints.</p><p><a href="#validationapi" title="Chapter&nbsp;5.&nbsp;Validation APIs">Chapter&nbsp;5, <i>Validation APIs</i></a> describes how to programmatically
    validate a JavaBean.</p><p><a href="#constraintmetadata" title="Chapter&nbsp;6.&nbsp;Constraint metadata request APIs">Chapter&nbsp;6, <i>Constraint metadata request APIs</i></a> describes how the metadata
    query API works.</p><div class="added"><p><a href="#integration" title="Chapter&nbsp;10.&nbsp;Integration">Chapter&nbsp;10, <i>Integration</i></a> describes the
    different integration points of Bean Validation with other technologies.
    In some cases one has to refer to the to the respective specifications for
    the up-to-date integration rules.</p></div><p><a href="#builtinconstraints" title="Chapter&nbsp;7.&nbsp;Built-in Constraint definitions">Chapter&nbsp;7, <i>Built-in Constraint definitions</i></a> list all the built-in
    constraints.</p><p>In <a href="#terminology" title="Appendix&nbsp;A.&nbsp;Terminology">Appendix&nbsp;A, <i>Terminology</i></a>, key concepts are summarized. Some
    reviewers have found that reading the terminology section first helps to
    better understand the specification.</p><p>The changelog can be found at <a href="#changelog" title="Appendix&nbsp;D.&nbsp;Changelog">Appendix&nbsp;D, <i>Changelog</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e273"></a>1.5.&nbsp;Changes applied since between 1.0 and this draft</h2></div></div><div></div></div><p>To facilitate change reviews, HTML rendering of this specification
    highlight changes:</p><div class="itemizedlist"><ul type="disc"><li><div class="added"><p>Added paragraphs are being highlighted in green</p></div></li><li><div class="changed"><p>Changed paragraphs are being highlighted in yellow</p></div></li><li><div class="deleted"><p>Deleted paragraphs are being highlighted in red and stroke -
        note that some elements might be deleted without this notice.</p></div></li></ul></div><p>At this time change highlighting is not supported in the PDF
    version.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e290"></a>1.6.&nbsp;How to comment</h2></div></div><div></div></div><div class="changed"><p>The expert group is eager to receive feedback
    from readers. Feel free to contact us. You can get all the details at
    <a href="http://beanvalidation.org/contribute/" target="_top">http://beanvalidation.org/contribute/</a>.</p></div></div></div><div class="added"><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="whatsnew"></a>Chapter&nbsp;2.&nbsp;What's new in 1.1</h2></div></div><div></div></div><p>Bean Validation 1.1 improves and build upon Bean Validation 1.0. The
  expert group and the community have been working of a few specific
  areas.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e303"></a>2.1.&nbsp;Openness</h2></div></div><div></div></div><p>All of Bean Validation 1.1 work has been done in the open and in an
    open source way. Source code for the API, reference implementation, test
    compatibility kit as well as the specification and the website source are
    available in the open. All discussions are done in the open in the
    publicly available development mailing list. Road map and proposals are
    also published on the website.</p><p>You can find all the details (mailing lists, source repositories
    etc) at <a href="http://beanvalidation.org" target="_top">http://beanvalidation.org</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e313"></a>2.2.&nbsp;Dependency injection</h2></div></div><div></div></div><p>Bean Validation uses a few components
    <tt class="classname">MessageInterpolator</tt>,
    <tt class="classname">TraversableResolver</tt>,
    <tt class="classname">ConstraintValidatorFactory</tt> and
    <tt class="classname">ConstraintValidator</tt>. We aim at standardising how
    these objects are managed by a container and how these objects can benefit
    from container services. In particular, CDI support within Java EE is
    being defined.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e330"></a>2.3.&nbsp;Method validation</h2></div></div><div></div></div><p>Bean Validation 1.1 allows to put constraints to the parameters and
    return values of arbitrary methods and constructors. That way the Bean
    Validation API can be used to describe and validate the contract applying
    to a given method or constructor, that is</p><div class="itemizedlist"><ul type="disc"><li><p>the preconditions that must be met by the caller before the
        method or constructor may be invoked and</p></li><li><p>the postconditions that are guaranteed to the caller after a
        method or constructor invocation returns.</p></li></ul></div><p>This enables a programming style known as "Programming by Contract"
    (PbC). Compared to traditional means of checking the sanity of argument
    and return values this approach has several advantages:</p><div class="itemizedlist"><ul type="disc"><li><p>These checks are expressed declaratively and don't have to be
        performed manually, which results in less code to write, read and
        maintain.</p></li><li><p>The pre- and postconditions applying for a method or constructor
        don't have to be expressed again in the documentation, since any of
        it's annotations will automatically be included in the generated
        JavaDoc. This reduces redundancies, thus avoiding efforts and
        inconsistencies between implementation and documentation.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e351"></a>2.4.&nbsp;Integration with Context and Dependency Injection</h2></div></div><div></div></div><p>The integration points with Context and Dependency Injection (CDI)
    have been increased and reworked. This should open up for a more natural
    and standard integration both in Java EE and Java SE and encompass
    dependency injection, component lifecycle management and interception for
    method validation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e356"></a>2.5.&nbsp;Group conversion</h2></div></div><div></div></div><p>The specification offers a way to alter the targeted group when
    validation cascading in happening. This feature is particularly useful to
    reuse a given object (graph) and to avoid leaking group segmentation from
    various object subgraphs. It also makes for more readable
    constraints.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e361"></a>2.6.&nbsp;Others</h2></div></div><div></div></div><p>Many more minor changes are being done. Check out the change log for
    more details at <a href="#changelog" title="Appendix&nbsp;D.&nbsp;Changelog">Appendix&nbsp;D, <i>Changelog</i></a>.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="constraintsdefinitionimplementation"></a>Chapter&nbsp;3.&nbsp;Constraint Definition</h2></div></div><div></div></div><p>Constraints are defined by the combination of a constraint annotation
  and a list of constraint validation implementations. The constraint
  annotation is applied on types, methods, fields or other constraint
  annotations in case of composition.</p><p>Unless stated otherwise the default package name for the Bean
  Validation APIs is <tt class="classname">javax.validation</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintsdefinitionimplementation-constraintdefinition"></a>3.1.&nbsp;Constraint annotation</h2></div></div><div></div></div><p>A constraint on a JavaBean is expressed through one or more
    annotations. An annotation is considered a <span class="added"><span>generic</span></span> constraint definition if its
    retention policy contains <tt class="literal">RUNTIME</tt> and if the annotation
    itself is annotated with
    <tt class="literal">javax.validation.Constraint</tt>.</p><pre class="programlisting">/**
 * Link between a constraint annotation and its constraint validation implementations.
 * &lt;p/&gt;
 * A given constraint annotation should be annotated by a {@code @Constraint}
 * annotation which refers to its list of constraint validation implementations.
 *
 * @author Emmanuel Bernard
 * @author Gavin King
 * @author Hardy Ferentschik
 */
@Documented
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface Constraint {
    /**
     * {@code ConstraintValidator} classes must reference distinct target types.
     * If two {@code ConstraintValidator}s refer to the same type,
     * an exception will occur.
     *
     * @return array of (@code ConstraintValidator} classes implementing the constraint
     */
    Class&lt;? extends ConstraintValidator&lt;?, ?&gt;&gt;[] validatedBy();
}</pre><div class="added"><p>An annotation is considered a cross-parameter
    constraint definition (see section <a href="#constraintdeclarationvalidationprocess-crossparameterconstraints" title="4.5.2.1.&nbsp;Cross-parameter constraints">Section&nbsp;4.5.2.1, &#8220;Cross-parameter constraints&#8221;</a>)
    if its retention policy contains <tt class="literal">RUNTIME</tt> and if the
    annotation itself is annotated with
    <tt class="literal">javax.validation.CrossParameterConstraint</tt>.</p></div><div class="added"><pre class="programlisting">/**
 * Link between a cross-parameter constraint annotation and its constraint
 * validation implementation.
 *
 * @author Gunnar Morling
 */
@Documented
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface CrossParameterConstraint {
   /**
     * Returns the {@link ConstraintValidator} class for the annotated
     * cross-parameter constraint. The validator's type parameter {@code T} must
     * resolve to {@code Object[]}.
     *
     * @return Constraint validator class implementing the constraint
     */
    Class&lt;? extends ConstraintValidator&lt;?, ?&gt;&gt; validatedBy();
}</pre></div><div class="added"><p>A Bean Validation constraint is either a
    generic constraint (marked with <tt class="classname">@Constraint</tt>) or a a
    cross-parameter constraint (marked with
    <tt class="classname">@CrossParameterConstraint</tt>). If both annotations are
    given on an annotation type, a
    <tt class="classname">ConstraintDefinitionException</tt> is raised by the Bean
    Validation provider.</p></div><div class="added"><i><span class="remark">TODO: Alternatively to distinguishing generic
    and cross-parameter constraint annotation types by different meta
    annotations, we could also add a method such as
    <tt class="methodname">type()</tt> to <tt class="classname">@Constraint</tt>
    which allows to determine a constraint's type.</span></i></div><div class="added"><p>A generic constraint is used when validating a
    bean, a field, a getter, a method/constructor return value or a
    method/constructor parameter. A cross-parameter constraint is used when
    validating the consistency of several method/constructor
    parameters.</p></div><p>Generic constraint annotations can target any of the following
    <tt class="classname">ElementType</tt>s:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">FIELD</tt> for constrained attributes</p></li><li><p><tt class="literal">METHOD</tt> for constrained getters<span class="added"><span> and constrained method return
        values</span></span></p></li><li><div class="added"><p><tt class="classname">CONSTRUCTOR</tt> for constrained constructor
        return values</p></div></li><li><div class="added"><p><tt class="classname">PARAMETER</tt> for constrained method and
        constructor parameters</p></div></li><li><p><tt class="literal">TYPE</tt> for constrained beans</p></li><li><p><tt class="literal">ANNOTATION_TYPE</tt> for constraints composing
        other constraints</p></li></ul></div><div class="added"><p>Cross-parameter constraint annotations can
    target any of the following <tt class="classname">ElementType</tt>s:</p></div><div class="added"><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">METHOD</tt></p></li><li><p><tt class="literal">ANNOTATION_TYPE</tt> for cross-parameter
        constraints composing other cross-parameter constraints</p></li></ul></div></div><p>While other <tt class="classname">ElementType</tt>s are not forbidden,
    the provider does not have to recognize and process constraints placed on
    such types. <span class="deleted"><span>Built-in types do support
    <tt class="literal">PARAMETER</tt> and <tt class="literal">CONSTRUCTOR</tt> to allow
    Bean Validation provider specific extensions. It is considered good
    practice to follow the same approach for custom
    annotations.</span></span></p><p>Since a given constraint definition applies to one or more specific
    Java types, the JavaDoc for the constraint annotation should clearly state
    which types are supported. Applying a constraint annotation to an
    incompatible type will raise an
    <tt class="classname">UnexpectedTypeException</tt>. Care should be taken on
    defining the list of <tt class="classname">ConstraintValidator</tt>s. The type
    resolution algorithm (see <a href="#typevalidatorresolution" title="4.6.4.&nbsp;ConstraintValidator resolution algorithm">Section&nbsp;4.6.4, &#8220;ConstraintValidator resolution algorithm&#8221;</a>) could
    lead to exceptions if the <tt class="classname">ConstraintValidator</tt> list
    leads to ambiguities.</p><p>If a constraint definition is not valid, a
    <tt class="classname">ConstraintDefinitionException</tt> is raised either at
    validation time or when the metadata is requested. Invalid constraint
    definitions causes are multiple but include missing or illegal
    <tt class="methodname">message</tt> or <tt class="methodname">groups</tt>
    elements (see <a href="#constraintsdefinitionimplementation-constraintdefinition-properties" title="3.1.1.&nbsp;Constraint definition properties">Section&nbsp;3.1.1, &#8220;Constraint definition properties&#8221;</a>).</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintsdefinitionimplementation-constraintdefinition-properties"></a>3.1.1.&nbsp;Constraint definition properties</h3></div></div><div></div></div><p>A constraint definition may have attributes that are specified at
      the time the constraint is applied to a JavaBean. The properties are
      mapped as annotation elements. The annotation element names
      <tt class="literal">message</tt>, <tt class="literal">groups</tt> and
      <tt class="literal">payload</tt> are considered reserved names; annotation
      elements starting with <tt class="literal">valid</tt> are not allowed; a
      constraint may use any other element name for its attributes.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="constraintsdefinitionimplementation-constraintdefinition-parameters-message"></a>3.1.1.1.&nbsp;message</h4></div></div><div></div></div><p>Every constraint annotation must define a
        <tt class="literal">message</tt> element of type
        <tt class="literal">String</tt>.</p><pre class="programlisting">String message() default "{com.acme.constraint.MyConstraint.message}";</pre><p>The <tt class="methodname">message</tt> element value is used to
        create the error message. See <a href="#validationapi-message" title="5.3.&nbsp;Message interpolation">Section&nbsp;5.3, &#8220;Message interpolation&#8221;</a>
        for a detailed explanation. It is recommended to default
        <tt class="literal">message</tt> values to resource bundle keys to enable
        internationalization. It is also recommended to use the following
        convention: the resource bundle key should be the fully qualified
        class name of the constraint annotation concatenated to
        <tt class="literal">.message</tt> as shown in the previous program
        listing.</p><p>Built-in Bean Validation constraints follow this
        convention.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="constraintsdefinitionimplementation-constraintdefinition-groups"></a>3.1.1.2.&nbsp;groups</h4></div></div><div></div></div><p>Every constraint annotation must define a
        <tt class="literal">groups</tt> element that specifies the processing groups
        with which the constraint declaration is associated.</p><pre class="programlisting">    Class&lt;?&gt;[] groups() default {};</pre><p>The default value must be an empty array.</p><p>If no group is specified when declaring the constraint on an
        element, the <tt class="literal">Default</tt> group is considered
        declared.</p><p>See <a href="#validationapi-validatorapi-groups" title="5.1.3.&nbsp;groups">Section&nbsp;5.1.3, &#8220;groups&#8221;</a> for more
        information.</p><p>Groups are typically used to control the order in which
        constraints are evaluated, or to perform validation of the partial
        state of a JavaBean.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="constraintsdefinitionimplementation-constraintdefinition-payload"></a>3.1.1.3.&nbsp;payload</h4></div></div><div></div></div><p>Constraint annotations must define a <tt class="literal">payload</tt>
        element that specifies the payload with which the the constraint
        declaration is associated.</p><pre class="programlisting">    Class&lt;? extends Payload&gt;[] payload() default {};</pre><p>The default value must be an empty array.</p><p>Each attachable payload extends
        <tt class="classname">Payload</tt>.</p><pre class="programlisting">/**
 * Payload type that can be attached to a given
 * constraint declaration.
 * Payloads are typically used to carry on metadata information
 * consumed by a validation client.
 *
 * Use of payloads is not considered portable.
 *
 * @author Emmanuel Bernard
 * @author Gerhard Petracek
 */
public interface Payload {
}</pre><p>Payloads are typically used by validation clients to associate
        some metadata information with a given constraint declaration.
        Payloads are typically non-portable. Describing payloads as interface
        extensions as opposed to a string-based approach allows an easier and
        more type-safe approach.</p><p>One use case for payload shown in <a href="#example-payload" title="Example&nbsp;3.1.&nbsp;Use of payload to associate severity to a constraint">Example&nbsp;3.1, &#8220;Use of payload to associate severity to a constraint&#8221;</a> is to associate a severity to a
        constraint. This severity can be exploited by a presentation framework
        to adjust how a constraint failure is displayed.</p><div class="example"><a name="example-payload"></a><p class="title"><b>Example&nbsp;3.1.&nbsp;Use of payload to associate severity to a constraint</b></p><pre class="programlisting">package com.acme.severity;

public class Severity {
    public static class Info implements Payload {};
    public static class Error implements Payload {};
}

public class Address {
    @NotNull(message="would be nice if we had one", payload=Severity.Info.class)
    public String getZipCode() {...}

    @NotNull(message="the city is mandatory", payload=Severity.Error.class) 
    String getCity() {...}
}</pre></div><p>The <tt class="literal">payload</tt> information can be retrieved from
        error reports via the <tt class="classname">ConstraintDescriptor</tt>
        either accessed through the <tt class="classname">ConstraintViolation</tt>
        objects (see <a href="#validationapi-constraintviolation" title="5.2.&nbsp;ConstraintViolation">Section&nbsp;5.2, &#8220;ConstraintViolation&#8221;</a>) or
        through the metadata API (see <a href="#constraintmetadata-constraintdescriptor" title="6.9.&nbsp;ConstraintDescriptor">Section&nbsp;6.9, &#8220;ConstraintDescriptor&#8221;</a>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e632"></a>3.1.1.4.&nbsp;Constraint specific parameter</h4></div></div><div></div></div><p>The constraint annotation definitions may define additional
        elements to parameterize the constraint. For example, a constraint
        that validates the length of a string can use an annotation element
        named <tt class="literal">length</tt> to specify the maximum length at the
        time the constraint is declared.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e640"></a>3.1.2.&nbsp;Examples</h3></div></div><div></div></div><div class="example"><a name="example-definition-notnull"></a><p class="title"><b>Example&nbsp;3.2.&nbsp;Simple constraint definition</b></p><pre class="programlisting">package com.acme.constraint;

/**
 * Mark a String as representing a well formed order number
 */
@Documented
@Constraint(validatedBy = OrderNumberValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface OrderNumber {
    String message() default "{com.acme.constraint.OrderNumber.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</pre></div><p><a href="#example-definition-notnull" title="Example&nbsp;3.2.&nbsp;Simple constraint definition">Example&nbsp;3.2, &#8220;Simple constraint definition&#8221;</a> marks a String as a
      well-formed order number. The constraint validator is implemented by
      <tt class="classname">OrderNumberValidator</tt>.</p><div class="added"><div class="example"><a name="example-definition-crossparameter"></a><p class="title"><b>Example&nbsp;3.3.&nbsp;Simple cross-parameter constraint definition</b></p><pre class="programlisting">package com.acme.constraint;

/**
 * Cross-parameter constraint ensuring that two date parameters
 * of a method are in the correct order.
 */
@Documented
@CrossParameterConstraint(validatedBy = DateParametersConsistentValidator.class)
@Target({ METHOD, ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface DateParametersConsistent {
    String message() default "{com.acme.constraint.DateParametersConsistent.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</pre></div></div><div class="added"><p><a href="#example-definition-crossparameter" title="Example&nbsp;3.3.&nbsp;Simple cross-parameter constraint definition">Example&nbsp;3.3, &#8220;Simple cross-parameter constraint definition&#8221;</a> shows a cross-parameter
      constraint which ensures that two date parameters of a method are in the
      correct order. The constraint validator is implemented by
      <tt class="classname">DateParametersConsistentValidator</tt>.</p></div><div class="example"><a name="example-definition-length"></a><p class="title"><b>Example&nbsp;3.4.&nbsp;Constraint definition with default parameter</b></p><pre class="programlisting">package com.acme.constraint;

/**
 * A frequency in Hz as audible to human ear.
 * Adjustable to the age of the person.
 * Accept Numbers.
 */
@Documented
@Constraint(validatedBy = AudibleValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface Audible {
    Age age() default Age.YOUNG;
    String message() default "{com.acme.constraint.Audible.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    public enum Age {
        YOUNG,
        WONDERING
        OLD
    }
}</pre></div><p><a href="#example-definition-length" title="Example&nbsp;3.4.&nbsp;Constraint definition with default parameter">Example&nbsp;3.4, &#8220;Constraint definition with default parameter&#8221;</a> ensures that a given
      frequency is within the scope of human ears. The constraint definition
      includes an optional parameter that may be specified when the constraint
      is applied.</p><div class="example"><a name="example-definition-mandatory"></a><p class="title"><b>Example&nbsp;3.5.&nbsp;Constraint definition with mandatory parameter</b></p><pre class="programlisting">package com.acme.constraint;

/**
 * Defines the list of values accepted
 * Accepts int or Integer objects
 */
@Documented
@Constraint(validatedBy = DiscreteListOfIntegerValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface Acceptable {
    int[] value();
    String message() default "{com.acme.constraint.Acceptable.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</pre></div><p><a href="#example-definition-mandatory" title="Example&nbsp;3.5.&nbsp;Constraint definition with mandatory parameter">Example&nbsp;3.5, &#8220;Constraint definition with mandatory parameter&#8221;</a> defines a list of
      acceptable values expressed as an array: the
      <tt class="methodname">value</tt> property must be specified when the
      constraint is applied.</p><div class="added"><div class="example"><a name="example-definition-illegal"></a><p class="title"><b>Example&nbsp;3.6.&nbsp;Illegal constraint definition</b></p><pre class="programlisting">package com.acme.constraint;

/**
 * Cross-parameter constraint ensuring that two date parameters
 * of a method are in the correct order.
 */
@Documented
@Constraint(validatedBy = DateParametersConsistentValidator.class)
@CrossParameterConstraint(validatedBy = AnotherDateParametersConsistentValidator.class)
@Target({ METHOD, ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface DateParametersConsistent {
    String message() default "{com.acme.constraint.DateParametersConsistent.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</pre></div></div><div class="added"><p><a href="#example-definition-illegal" title="Example&nbsp;3.6.&nbsp;Illegal constraint definition">Example&nbsp;3.6, &#8220;Illegal constraint definition&#8221;</a>
      shows an illegal constraint definition ; an annotation may either be a
      constraint annotation or a cross-parameter annotation but not
      both.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintsdefinitionimplementation-multipleconstraints"></a>3.2.&nbsp;Applying multiple constraints of the same type</h2></div></div><div></div></div><p>It is often useful to declare the same constraint more than once to
    the same target, with different properties. A common example is the
    <tt class="literal">@Pattern</tt> constraint, which validates that its target
    matches a specified regular expression. Other constraints have this
    requirement as well. The same constraint type can belong to different
    groups and have specific error messages depending on the targeted
    group.</p><p>To support this requirement, the bean validation provider treats
    regular annotations (annotations not annotated by
    <tt class="classname">@Constraint</tt>) whose <tt class="literal">value</tt> element
    has a return type of an array of constraint annotations in a special way.
    Each element in the <tt class="literal">value</tt> array are processed by the
    Bean Validation implementation as regular constraint annotations. This
    means that each constraint specified in the <tt class="literal">value</tt>
    element is applied to the target. The annotation must have retention
    <tt class="literal">RUNTIME</tt> and can be applied on a type, field, property
    or another annotation. It is recommended to use the same set of targets as
    the initial constraint.</p><p>Note to constraint designers: each constraint annotation should be
    coupled with its corresponding multi-valued annotation. The specification
    recommends, though does not mandate, the definition of an inner annotation
    named <tt class="classname">List</tt>.</p><div class="example"><a name="d0e722"></a><p class="title"><b>Example&nbsp;3.7.&nbsp;Multi-valued constraint definition</b></p><pre class="programlisting">/**
 * Validate a zipcode for a given country 
 * The only supported type is String
 */
@Documented
@Constraint(validatedBy = ZipCodeValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface ZipCode {

    String countryCode();

    String message() default "{com.acme.constraint.ZipCode.message}";

    Class&lt;?&gt;[] groups() default {};

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * Defines several @ZipCode annotations on the same element
     * @see (@link ZipCode}
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        ZipCode[] value();
    }    
}</pre></div><div class="example"><a name="d0e727"></a><p class="title"><b>Example&nbsp;3.8.&nbsp;Multi-valued constraint declaration</b></p><pre class="programlisting">public class Address {
    @ZipCode.List( {
            @ZipCode(countryCode="fr", groups=Default.class
                     message = "zip code is not valid"),
            @ZipCode(countryCode="fr", groups=SuperUser.class
                     message = "zip code invalid. Requires overriding before saving.")
            } )
    private String zipcode;
}</pre></div><p>In this example, both constraints apply to the
    <tt class="methodname">zipcode</tt> field but with different groups and with
    different error messages.</p><p>Using two different multi-constraint annotations for the same
    underlying constraint type on the same target (i.e. class or property) is
    not considered portable and is discouraged.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintsdefinitionimplementation-constraintcomposition"></a>3.3.&nbsp;Constraint composition</h2></div></div><div></div></div><p>This specification allows you to compose constraints to create
    higher level constraints.</p><p>Constraint composition is useful in several ways:</p><div class="itemizedlist"><ul type="disc"><li><p>Avoid duplication and facilitate reuse of more primitive
        constraints.</p></li><li><p>Expose primitive constraints as part of a composed constraint in
        the metadata API and enhance tool awareness.</p></li></ul></div><p>Composition is done by annotating a constraint annotation with the
    composing constraint annotations.</p><div class="example"><a name="d0e755"></a><p class="title"><b>Example&nbsp;3.9.&nbsp;Composition is done by annotating the composed constraint</b></p><pre class="programlisting">@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ANNOTATION_TYPE, METHOD, FIELD, CONSTRUCTOR, PARAMETER})
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</pre></div><p>Annotating an element with <tt class="classname">@FrenchZipcode</tt>
    (the composed annotation) is equivalent to annotating it with
    <tt class="classname">@Pattern(regexp="[0-9]*")</tt>, <tt class="classname">@Size(min=5,
    max=5)</tt> (the composing annotations) and
    <tt class="classname">@FrenchZipcode</tt>. More formally, each constraint
    annotation hosted on a constraint annotation is applied to the target
    element and this is done recursively. Note that the main annotation and
    its constraint validation implementation is also applied. By default, each
    failing constraint generates an error report. Groups from the main
    constraint annotation are inherited by the composing annotations. Any
    <tt class="methodname">groups</tt> definition on a composing annotation is
    ignored. Likewise, payload from the main constraint annotation is
    inherited by the composing annotations. Any
    <tt class="methodname">payload</tt> definition on a composing annotation is
    ignored.</p><p>The <span class="deleted"><span>property</span></span> type upon which
    composed constraint is placed must be compatible with all constraints
    (composing and composed). A constraint designer should ensure that such a
    type exists and list in the JavaDoc all the compatible types.</p><div class="added"><p>Both composed and composing constraints should
    share the same constraint type. Either all of generic constraints
    (<tt class="classname">@Constraint</tt>) or all of cross parameter constraints
    (<tt class="classname">@CrossParameterConstraint</tt>).</p></div><p>It is possible to ensure that composing annotations do not raise
    individual error reports. In this scenario, if one or more composing
    annotations are invalid, the main constraint is automatically considered
    invalid and the corresponding error report is generated. To mark a
    constraint as raising a single constraint error report if either the
    composed or one of the composing constraints fail, use the
    <tt class="classname">@ReportAsSingleViolation</tt> annotation.</p><div class="example"><a name="d0e798"></a><p class="title"><b>Example&nbsp;3.10.&nbsp;If any of the composing constraints fail, the error report
      corresponding to @FrenchZipcode is raised and none other.</b></p><pre class="programlisting">@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@ReportAsSingleViolation
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</pre></div><p>The definition of <tt class="classname">@ReportAsSingleViolation</tt> is
    as follows.</p><div class="changed"><pre class="programlisting">/**
 * A constraint annotation hosting this annotation will return the
 * composed annotation error report if any of the composing annotations fail.
 * The error reports of each individual composing constraint are ignored.
 *
 * &lt;p&gt;
 * Note: Evaluation of composed constraints stops on the first validation
 * error in case the composing constraint is annotated with
 * {@code @ReportAsSingleViolation}.
 * &lt;/p&gt;
 *
 * @author Emmanuel Bernard
 */
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface ReportAsSingleViolation {
}</pre></div><div class="changed"><p>More specifically, if a composed constraint
    is marked as <tt class="classname">@ReportAsSingleViolation</tt>, the
    evaluation of the composing constraints stops at the first failing
    constraint and the error report corresponding to the composed constraint
    is generated and returned.</p></div><p>Composing annotations can define the value of
    <tt class="literal">message</tt> and custom attributes (excluding
    <tt class="methodname">groups</tt> and <tt class="methodname">payload</tt>) but
    these are fixed in the composed constraint definition.</p><div class="example"><a name="d0e826"></a><p class="title"><b>Example&nbsp;3.11.&nbsp;Composing annotations can use attributes. They are fixed for a
      given main annotation. All @FrenchZipcode constraints have a @Size
      restricted to 5.</b></p><pre class="programlisting">@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</pre></div><p>It is possible to override attributes and messages defined on a
    composing annotation. An attribute from the main annotation is used to
    override one or more attributes of the composing annotations. Such an
    attribute is annotated with the <tt class="classname">@OverridesAttribute</tt>
    annotation or its multivalued equivalent
    <tt class="classname">@OverridesAttribute.List</tt>.</p><div class="example"><a name="example-composing-overridden"></a><p class="title"><b>Example&nbsp;3.12.&nbsp;Attributes from composing annotations can be overridden by
      attributes from the composed annotation.</b></p><pre class="programlisting">@Pattern(regexp="[0-9]*")
@Size
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @OverridesAttribute.List( {
        @OverridesAttribute(constraint=Size.class, name="min"),
        @OverridesAttribute(constraint=Size.class, name="max") } )
    int size() default 5;

    @OverridesAttribute(constraint=Size.class, name="message")
    String sizeMessage() default "{com.acme.constraint.FrenchZipcode.zipcode.size}";

    @OverridesAttribute(constraint=Pattern.class, name="message")
    String numberMessage() default "{com.acme.constraint.FrenchZipcode.number.size}";

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</pre></div><p>The value of the composed constraint attribute annotated with
    <tt class="classname">@OverridesAttribute</tt>
    (<tt class="methodname">@FrenchZipcode.sizeMessage</tt>) is applied to the
    composing constraint attribute named after
    <tt class="methodname">OverridesAttribute.name</tt> and hosted on the
    composing constraint of type
    <tt class="methodname">OverridesAttribute.constraint</tt>
    (<tt class="methodname">@Size.message</tt>). Similarly,
    <tt class="classname">@FrenchZipcode.numberMessage</tt> value is mapped to
    <tt class="classname">@Pattern.message</tt>.</p><p>If left undefined, the default value for
    <tt class="methodname">@OverridesAttribute.name</tt> is the name of the
    composed constraint attribute hosting the
    <tt class="classname">@OverridesAttribute</tt> annotation.</p><p>The types of the overridden and overriding attributes must be
    identical.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A composing constraint can itself be a composed constraint. In
      this case, attribute values are overridden recursively according to the
      described rules. Note however, that a forwarding rule (as defined by
      <tt class="classname">@OverridesAttribute</tt>) is only applied to the
      direct composing constraints.</p></div><p>Using <a href="#example-composing-overridden" title="Example&nbsp;3.12.&nbsp;Attributes from composing annotations can be overridden by&#xA;      attributes from the composed annotation.">Example&nbsp;3.12, &#8220;Attributes from composing annotations can be overridden by
      attributes from the composed annotation.&#8221;</a>,</p><pre class="programlisting">@FrenchZipcode(size=9, sizeMessage="Zipcode should be of size {max}")</pre><p>is equivalent to</p><pre class="programlisting">@FrenchZipcode</pre><p>if <tt class="classname">@FrenchZipcode</tt> is defined as</p><pre class="programlisting">@Pattern(regexp="[0-9]*")
@Size(min=9, max=9, message="Zipcode should be of size {max}")
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</pre><p>If a constraint is used more than once as a composing constraint,
    the multi value constraints model as described in <a href="#constraintsdefinitionimplementation-multipleconstraints" title="3.2.&nbsp;Applying multiple constraints of the same type">Section&nbsp;3.2, &#8220;Applying multiple constraints of the same type&#8221;</a> is
    used. To select a specific composing constraint,
    <tt class="methodname">OverridesAttribute.constraintIndex</tt> is used. It
    represents the constraint index in the <tt class="methodname">value</tt>
    array. If <tt class="literal">index</tt> is undefined, the single constraint
    declaration is targeted.</p><div class="example"><a name="d0e913"></a><p class="title"><b>Example&nbsp;3.13.&nbsp;Use of constraintIndex in @OverridesAttribute</b></p><pre class="programlisting">@Pattern.List( {
    @Pattern(regexp="[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}"), //email
    @Pattern(regexp=".*?emmanuel.*?") //emmanuel
} )
@Constraint(validatedBy={})
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface EmmanuelsEmail {
    String message() default "Not emmanuel's email";

    @OverridesAttribute(constraint=Pattern.class, name="message", constraintIndex=0)
    String emailMessage() default "Not an email";

    @OverridesAttribute(constraint=Pattern.class, name="message", constraintIndex=1)
    String emmanuelMessage() default "Not Emmanuel";

    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        EmmanuelsEmail[] value();
    }
}</pre></div><p><tt class="classname">@OverridesAttribute</tt> definition is as
    follows:</p><pre class="programlisting">/**
 * Mark an attribute as overriding the attribute of a composing constraint.
 * Both attributes must share the same type.
 *
 * @author Emmanuel Bernard
 */
@Retention(RUNTIME)
@Target({ METHOD })
public @interface OverridesAttribute {
    /**
     * @return Constraint type the attribute is overriding
     */
    Class&lt;? extends Annotation&gt; constraint();

    /**
     * Name of the Constraint attribute overridden.
     * Defaults to the name of the attribute hosting &lt;code&gt;@OverridesAttribute&lt;/code&gt;.
     *
     * @return name of constraint attribute overridden.
     */
    String name();

    /**
     * The index of the targeted constraint declaration when using
     * multiple constraints of the same type.
     * The index represents the index of the constraint in the value() array.
     *
     * By default, no index is defined and the single constraint declaration
     * is targeted
     *
     * @return constraint declaration index if multivalued annotation is used
     */
    int constraintIndex() default -1;

    /**
     * Defines several @OverridesAttribute annotations on the same element
     * @see javax.validation.OverridesAttribute
     */
    @Documented
    @Target({ METHOD })
    @Retention(RUNTIME)
    public @interface List {
        OverridesAttribute[] value();
    }
}</pre><p>The following elements uniquely identify an overridden constraint
    attribute:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">OverridesAttribute.constraint</tt></p></li><li><p><tt class="methodname">OverridesAttribute.name</tt></p></li><li><p><tt class="methodname">OverridesAttribute.constraintIndex</tt></p></li></ul></div><p>If the composition is invalid</p><div class="itemizedlist"><ul type="disc"><li><p>infinitely recursive composition</p></li><li><p>wrong attribute overriding</p></li><li><p>a single attribute mapped to more than one source
        attribute</p></li><li><div class="added"><p>A composing and composed constraint marked
        as different constraint types (i.e., generic with
        <tt class="classname">@Constraint</tt> and cross-parameter with
        <tt class="classname">@CrossParameterConstraint</tt>)</p></div></li><li><p>etc</p></li></ul></div><p>a single attribute mapped to more than one source attribute etc), a
    <tt class="classname">ConstraintDefinitionException</tt> is raised either at
    validation time or when the metadata is requested.</p><p>Constraint designers are encouraged to make use of composition
    (recursively or not) based on the built-in constraints defined by the
    specification. The composing constraints are exposed through the Bean
    Validation metadata API (<a href="#constraintmetadata-constraintdescriptor" title="6.9.&nbsp;ConstraintDescriptor">Section&nbsp;6.9, &#8220;ConstraintDescriptor&#8221;</a>). This metadata is
    particularly useful for third-party metadata consumers like persistence
    frameworks generating database schemas (such as Java Persistence) or
    presentation frameworks.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintsdefinitionimplementation-validationimplementation"></a>3.4.&nbsp;Constraint validation implementation</h2></div></div><div></div></div><p>A constraint validation implementation performs the validation of a
    given constraint annotation for a given type. The implementation classes
    are specified by the <tt class="literal">validatedBy</tt> element of the
    <tt class="classname">@Constraint</tt> <span class="added"><span>respectively
    <tt class="classname">@CrossParameterConstraint</tt></span></span> annotation that
    decorates the constraint definition. The constraint validation
    implementation implements the <tt class="classname">ConstraintValidator</tt>
    interface.</p><pre class="programlisting">/**
 * Defines the logic to validate a given constraint A
 * for a given object type T.
 * Implementations must comply to the following restriction:
 * &lt;ul&gt;
 * &lt;li&gt;T must resolve to a non parameterized type&lt;/li&gt;
 * &lt;li&gt;or generic parameters of T must be unbounded
 * wildcard types&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidator&lt;A extends Annotation, T&gt; {
    /**
     * Initialize the validator in preparation for isValid calls.
     * The constraint annotation for a given constraint declaration
     * is passed.
     * &lt;p/&gt;
     * This method is guaranteed to be called before any use of this instance for
     * validation.
     *
     * @param constraintAnnotation annotation instance for a given constraint declaration
     */
    void initialize(A constraintAnnotation);

    /**
     * Implement the validation logic.
     * The state of &lt;code&gt;value&lt;/code&gt; must not be altered.
     *
     * This method can be accessed concurrently, thread-safety must be ensured
     * by the implementation.
     *
     * @param value object to validate
     * @param context context in which the constraint is evaluated
     *
     * @return false if &lt;code&gt;value&lt;/code&gt; does not pass the constraint
     */
    boolean isValid(T value, ConstraintValidatorContext context);
}</pre><p>Some restrictions apply on the generic type <tt class="classname">T</tt>
    (used in the <tt class="methodname">isValid</tt> method).
    <tt class="classname">T</tt> must</p><div class="itemizedlist"><ul type="disc"><li><p>resolve to a non parameterized type (i.e. because the type is
        not using generics or because the raw type is used instead of the
        generic version)</p></li><li><p>or generic parameters of <tt class="classname">T</tt> must be
        unbounded wildcard types (i.e. <tt class="literal">&lt;?&gt;</tt>)<span class="added"><span>.</span></span></p></li><li><div class="added"><p>If <tt class="classname">A</tt> is a cross-parameter constraint
        annotation type, <tt class="classname">T</tt> must resolve to
        <tt class="classname">Object[]</tt> in order to have the array of
        parameter values passed to the <tt class="methodname">isValid()</tt>
        method.</p></div></li></ul></div><p><a href="#example-constraintsdefinitionimplementation-validationimplementation-validdef" title="Example&nbsp;3.14.&nbsp;Valid ConstraintValidator definitions">Example&nbsp;3.14, &#8220;Valid ConstraintValidator definitions&#8221;</a>
    shows some examples of valid definitions.</p><div class="changed"><div class="example"><a name="example-constraintsdefinitionimplementation-validationimplementation-validdef"></a><p class="title"><b>Example&nbsp;3.14.&nbsp;Valid ConstraintValidator definitions</b></p><pre class="programlisting">//String is not making use of generics
public class SizeValidatorForString implements&lt;Size, String&gt; {...}

//Collection uses generics but the raw type is used
public class SizeValidatorForCollection implements&lt;Size, Collection&gt; {...}

//Collection uses generics and unbounded windcard type
public class SizeValidatorForCollection implements&lt;Size, Collection&lt;?&gt;&gt; {...}

//Validator for cross-parameter constraint
public class DateParametersConsistentValidator implements&lt;DateParametersConsistent, Object[]&gt; {...}</pre></div></div><p>And some invalid definitions in <a href="#example-constraintsdefinitionimplementation-validationimplementation-invaliddef" title="Example&nbsp;3.15.&nbsp;Invalid ConstraintValidator definitions">Example&nbsp;3.15, &#8220;Invalid ConstraintValidator definitions&#8221;</a>.</p><div class="example"><a name="example-constraintsdefinitionimplementation-validationimplementation-invaliddef"></a><p class="title"><b>Example&nbsp;3.15.&nbsp;Invalid ConstraintValidator definitions</b></p><pre class="programlisting">//parameterized type
public class SizeValidatorForString implements&lt;Size, Collection&lt;String&gt;&gt; {...}

//parameterized type using bounded wildcard
public class SizeValidatorForCollection implements&lt;Size, Collection&lt;? extends Address&gt;&gt; {...}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This restriction is not a theoretical limitation and a future
      version of the specification will likely allow it.</p></div><div class="changed"><p>The life cycle of a constraint validation
    implementation instance is undefined. Bean Validation providers are
    allowed to cache <tt class="classname">ConstraintValidator</tt> instances
    retrieved from the
    <tt class="classname">ConstraintValidatorFactory</tt>.</p></div><p>The <tt class="methodname">initialize</tt> method is called by the Bean
    validation provider prior to any use of the constraint
    implementation.</p><p>The <tt class="methodname">isValid</tt> method is evaluated by the Bean
    Validation provider each time a given value is validated. It returns
    <tt class="literal">false</tt> if the value is not valid,
    <tt class="literal">true</tt> otherwise. <tt class="literal">isValid</tt>
    implementations must be thread-safe.</p><p>If the property is of an unanticipated type, an
    <tt class="literal">UnexpectedTypeException</tt> is raised.
    <tt class="classname">ConstraintValidator</tt> implementations raise this
    exception themselves if they receive an unsupported type. However,
    constraint designers are encouraged to make use of specialized
    <tt class="classname">ConstraintValidator</tt> implementations and delegate
    the type resolution to the Bean Validation provider (see the type matching
    algorithm described in <a href="#typevalidatorresolution" title="4.6.4.&nbsp;ConstraintValidator resolution algorithm">Section&nbsp;4.6.4, &#8220;ConstraintValidator resolution algorithm&#8221;</a>).</p><p>If an exception occurs either in the
    <tt class="classname">initialize</tt> or <tt class="classname">isValid</tt>
    method, the runtime exception is wrapped into a
    <tt class="classname">ValidationException</tt> by the Bean Validation
    engine.</p><p>The constraint validation implementation is not allowed to change
    the state of the value passed to <tt class="methodname">isValid</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>While not mandatory, it is considered a good practice to split the
      core constraint validation from the not null constraint validation (for
      example, an <tt class="classname">@Email</tt> constraint will return true on
      a null object, i.e. will not take care of the
      <tt class="classname">@NotNull</tt> validation)</p><p><tt class="code">null</tt> can have multiple meanings but is commonly used
      to express that a value does not make sense, is not available or is
      simply unknown. Those constraints on the value are orthogonal in most
      cases to other constraints. For example a String, if present, must be an
      email but can be null. Separating both concerns is a good
      practice.</p></div><p>The <tt class="classname">ConstraintValidatorContext</tt> object passed
    to the <tt class="methodname">isValid</tt> method carries information and
    operations available in the context the constraint is validated to.</p><pre class="programlisting">/**
 * Provide contextual data and operation when applying a given constraint validator.
 *
 * At least one &lt;code&gt;ConstraintViolation&lt;/code&gt; must be defined (either the default one,
 * of if the default &lt;code&gt;ConstraintViolation&lt;/code&gt; is disabled, a custom one).
 *
 * @author Emmanuel Bernard
 */
public interface ConstraintValidatorContext {
    /**
     * Disable the default &lt;code&gt;ConstraintViolation&lt;/code&gt; object generation (which
     * is using the message template declared on the constraint).
     * Useful to set a different violation message or generate a &lt;code&gt;ConstraintViolation&lt;/Code&gt;
     * based on a different property.
     */
    void disableDefaultConstraintViolation();

    /**
     * @return the current uninterpolated default message.
     */
    String getDefaultConstraintMessageTemplate();

    /**
     * Return an constraint violation builder building an violation report
     * allowing to optionally associate it to a sub path.
     * The violation message will be interpolated.
     * &lt;p/&gt;
     * To create the &lt;code&gt;ConstraintViolation&lt;/code&gt;, one must call either one of
     * the #addConstraintViolation() methods available in one of the
     * interfaces of the fluent API.
     * If another method is called after #addConstraintViolation() on
     * &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; or any of its associated nested interfaces
     * an &lt;code&gt;IllegalStateException&lt;/code&gt; is raised.
     * &lt;p/&gt;
     * If &lt;code&gt;isValid&lt;code&gt; returns &lt;code&gt;false&lt;/code&gt;, a &lt;code&gt;ConstraintViolation&lt;/code&gt;
     * object will be built per ConstraintViolation report including the default one (unless
     * {@link #disableDefaultConstraintViolation()} has been called).
     * &lt;p/&gt;
     * &lt;code&gt;ConstraintViolation&lt;/code&gt; objects generated from such a call
     * contain the same contextual information (root bean, path and so on) unless
     * the path has been overriden.
     * &lt;p/&gt;
     * To create a different &lt;code&gt;ConstraintViolation&lt;/code&gt;, a new constraint violation builder
     * has to be retrieved from &lt;code&gt;ConstraintValidatorContext&lt;/code&gt;
     *
     * Here are a few usage examples:
     * &lt;pre&gt;
     * {@code
     * // create new violation report with the default path the constraint is located on
     * context.buildConstraintViolationWithTemplate( "way too long" )
     *             .addConstraintViolation();
     *
     * // create new violation report in the "street" subnode of the default path
     * //the constraint is located on
     * context.buildConstraintViolationWithTemplate( "way too long" )
     *              .addNode( "street" )
     *              .addConstraintViolation();
     *
     * //create new violation report in the "addresses["home"].country.name" subnode
     * //of the default path the constraint is located on
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *              .addNode( "addresses" )
     *              .addNode( "country" )
     *                  .inIterable().atKey( "home" )
     *              .addNode( "name" )
     *              .addConstraintViolation();
     * }
     * &lt;/pre&gt;
     *
     * @param messageTemplate new uninterpolated constraint message.
     * @return Returns an constraint violation builder
     */
    ConstraintViolationBuilder buildConstraintViolationWithTemplate(String messageTemplate);

    /**
     * &lt;code&gt;ConstraintViolation&lt;/code&gt; builder allowing to optionally associate
     * the violation report to a sub path.
     *
     * To create the &lt;code&gt;ConstraintViolation&lt;/code&gt;, one must call either one of
     * the #addConstraintViolation() methods available in one of the
     * interfaces of the fluent API.
     * If another method is called after #addConstraintViolation() on
     * &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; or any of its associated objects
     * an &lt;code&gt;IllegalStateException&lt;/code&gt; is raised.
     * 
     */
    interface ConstraintViolationBuilder {
        /**
         * Add a node to the path the &lt;code&gt;ConstraintViolation&lt;/code&gt; will be associated to.
         *
         * &lt;code&gt;name&lt;/code&gt; describes a single property. In particular,
         * dot (.) is not allowed.
         *
         * @param name property name
         * @return a builder representing node &lt;code&gt;name&lt;/code&gt;
         */
        NodeBuilderDefinedContext addNode(String name);

        /**
         * Add the new &lt;code&gt;ConstraintViolation&lt;/code&gt; to be generated if the
         * constraint validator marks the value as invalid.
         * Methods of this &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; instance and its nested
         * objects return &lt;code&gt;IllegalStateException&lt;/code&gt; from now on.
         *
         * @return the &lt;code&gt;ConstraintValidatorContext&lt;/code&gt; instance the
         *           &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; comes from
         */
        ConstraintValidatorContext addConstraintViolation();

        /**
         * Represent a node whose context is known
         * (ie index, key and isInIterable)
         */
        interface NodeBuilderDefinedContext {

            /**
             * Add a node to the path the &lt;code&gt;ConstraintViolation&lt;/code&gt; will be associated to.
             *
             * &lt;code&gt;name&lt;/code&gt; describes a single property. In particular,
             * dot (.) are not allowed.
             *
             * @param name property &lt;code&gt;name&lt;/code&gt;
             * @return a builder representing this node
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Add the new &lt;code&gt;ConstraintViolation&lt;/code&gt; to be generated if the
             * constraint validator marks the value as invalid.
             * Methods of the &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; instance this object
             * comes from and the constraint violation builder nested
             * objects return &lt;code&gt;IllegalStateException&lt;/code&gt; after this call.
             *
             * @return &lt;code&gt;ConstraintValidatorContext&lt;/code&gt; instance the
             *           &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represent a node whose context is
         * configurable (ie index, key and isInIterable)
         */
        interface NodeBuilderCustomizableContext {

            /**
             * Mark the node as being in an &lt;code&gt;Iterable&lt;/code&gt; or a &lt;code&gt;Map&lt;/code&gt;
             * 
             * @return a builder representing iterable details
             */
            NodeContextBuilder inIterable();

            /**
             * Add a node to the path the &lt;code&gt;ConstraintViolation&lt;/code&gt; will be associated to.
             *
             * &lt;code&gt;name&lt;/code&gt; describes a single property. In particular,
             * dot (.) are not allowed.
             *
             * @param name property &lt;code&gt;name&lt;/code&gt;
             * @return a builder representing this node
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Add the new &lt;code&gt;ConstraintViolation&lt;/code&gt; to be generated if the
             * constraint validator mark the value as invalid.
             * Methods of the &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; instance this object
             * comes from and the constraint violation builder nested
             * objects return &lt;code&gt;IllegalStateException&lt;/code&gt; after this call.
             *
             * @return &lt;code&gt;ConstraintValidatorContext&lt;/code&gt; instance the
             *           &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represent refinement choices for a node which is
         * in an &lt;code&gt;Iterator&lt;/code&gt; or &lt;code&gt;Map&lt;/code&gt;.
         * If the iterator is an indexed collection or a map,
         * the index or the key should be set.
         */
        interface NodeContextBuilder {
            
            /**
             * Define the key the object is into the &lt;code&gt;Map&lt;/code&gt;
             *
             * @param key map key
             * @return a builder representing the current node
             */
            NodeBuilderDefinedContext atKey(Object key);

            /**
             * Define the index the object is into the &lt;code&gt;List&lt;/code&gt; or array
             *
             * @param index index
             * @return a builder representing the current node
             */
            NodeBuilderDefinedContext atIndex(Integer index);

            /**
             * Add a node to the path the &lt;code&gt;ConstraintViolation&lt;/code&gt; will be associated to.
             *
             * &lt;code&gt;name&lt;/code&gt; describes a single property. In particular,
             * dot (.) are not allowed.
             *
             * @param name property &lt;code&gt;name&lt;/code&gt;
             * @return a builder representing this node
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Add the new &lt;code&gt;ConstraintViolation&lt;/code&gt; to be generated if the
             * constraint validator mark the value as invalid.
             * Methods of the &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; instance this object
             * comes from and the constraint violation builder nested
             * objects return &lt;code&gt;IllegalStateException&lt;/code&gt; after this call.
             *
             * @return &lt;code&gt;ConstraintValidatorContext&lt;/code&gt; instance the
             *           &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }
    }
}</pre><p>The <tt class="classname">ConstraintValidatorContext</tt> interface
    allows redefinition of the default constraint message generated when a
    constraint is not valid. By default, each invalid constraint leads to the
    generation of one error object represented by a
    <tt class="classname">ConstraintViolation</tt> object. This object is built
    from the default constraint message template as defined by the constraint
    declaration and the context in which the constraint declaration is placed
    (bean, property, attribute, <span class="added"><span>method or
    constructor parameter, method or constructor return
    value</span></span>).</p><p>The <tt class="classname">ConstraintValidatorContext</tt> methods let
    the constraint implementation disable the default
    <tt class="classname">ConstraintViolation</tt> generation and create one or
    more custom ones. The non-interpolated message passed as a parameter is
    used to build the <tt class="classname">ConstraintViolation</tt> message (the
    message interpolation operation is applied to it).</p><p>By default, the <tt class="classname">Path</tt> exposed on the
    <tt class="classname">ConstraintViolation</tt> represents the path to the
    bean, property, <span class="added"><span>parameter or return
    value</span></span> hosting the constraint (see <a href="#validationapi-constraintviolation" title="5.2.&nbsp;ConstraintViolation">Section&nbsp;5.2, &#8220;ConstraintViolation&#8221;</a> for more information). You
    can point it to a subpath of this default path by using the constraint
    violation builder fluent API.</p><p><a href="#example-constraintsdefinitionimplementation-validationimplementation-errorbuilder" title="Example&nbsp;3.16.&nbsp;Using the fluent API to build custom constraint&#xA;      violations">Example&nbsp;3.16, &#8220;Using the fluent API to build custom constraint
      violations&#8221;</a>
    shows a few examples.</p><div class="example"><a name="example-constraintsdefinitionimplementation-validationimplementation-errorbuilder"></a><p class="title"><b>Example&nbsp;3.16.&nbsp;Using the fluent API to build custom constraint
      violations</b></p><pre class="programlisting">//default path
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addConstraintViolation();

//default path + "street"
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addNode( "street" )
            .addConstraintViolation();

//default path + "addresses["home"].country.name"
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addNode( "addresses" )
            .addNode( "country" )
                .inIterable().atKey( "home" )
            .addNode( "name" )
            .addConstraintViolation();</pre></div><p>If <tt class="methodname">disableDefaultConstraintViolation</tt> is
    called, no custom error is added (using the error builder) and if the
    constraint is not valid, a <tt class="classname">ValidationException</tt> is
    raised.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintsdefinitionimplementation-validationimplementation-example"></a>3.4.1.&nbsp;Examples</h3></div></div><div></div></div><div class="example"><a name="d0e1188"></a><p class="title"><b>Example&nbsp;3.17.&nbsp;ConstraintValidator implementation</b></p><pre class="programlisting">/**
 * Check that a text is within the authorized syntax
 */
public class SyntaxValidator implements ConstraintValidator&lt;Syntax, String&gt; {
    private Set&lt;Format&gt; allowedFormats;

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Syntax constraint) {
        allowedFormats = new HashSet( Arrays.asList( constraint.value() ) );
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null ) return true;

        return allowedFormats.size() == 0 
            || (! Collections.disjoint( guessFormat(value), allowedFormats ) );
    }

    Set&lt;Format&gt; guessFormats(String text) { ... }
}</pre></div><p>This <tt class="classname">ConstraintValidator</tt> checks that a text
      is within the accepted syntax. It also demonstrates an interesting best
      practice: return <tt class="literal">true</tt> on a null parameter.</p><div class="added"><p>The following listing shows a validator
      implementing the validation logic for a cross-parameter
      constraint.</p></div><div class="added"><div class="example"><a name="d0e1203"></a><p class="title"><b>Example&nbsp;3.18.&nbsp;cross-parameter validator implementation</b></p><pre class="programlisting">/**
 * Check that two date parameters of a method are in the expected order. Expects the
 * 2nd and 3rd parameter of the validated method to be of type java.util.Date.
 */
public class DateParametersConsistentValidator implements&lt;DateParametersConsistent, Object[]&gt; {

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(DateParametersConsistent constraint) {
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(Object[] value, ConstraintValidatorContext context) {
        if ( value.length != 3 ) {
            throw new IllegalStateException( "Unexpected method signature" );
        }
        // one or both limits are unbounded =&gt; always consistent
        if ( value[1] == null || value[2] == null ) return true;
        return ( (Date) value[1] ).before( (Date) value[2] );
    }
}</pre></div></div><p>The next example shows how to use
      <tt class="classname">ConstraintValidatorContext</tt>.</p><div class="example"><a name="d0e1213"></a><p class="title"><b>Example&nbsp;3.19.&nbsp;Use of ConstraintValidatorContext</b></p><pre class="programlisting">/**
 * Check that a text is within the authorized syntax
 * Error messages are using either key:
 *  - com.acme.constraint.Syntax.unknown if no particular syntax is detected
 *  - com.acme.constraint.Syntax.unauthorized if the syntax is not allowed
 */
public class FineGrainedSyntaxValidator implements ConstraintValidator&lt;Syntax, String&gt; {
    private Set&lt;Format&gt; allowedFormats;

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Syntax constraint) {
        allowedFormats = new HashSet( Arrays.asList( constraint.value() ) );
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null ) return true;
        Set&lt;Format&gt; guessedFormats = guessFormats(value);

        context.disableDefaultConstraintViolation();
        if ( guessedFormats.size() == 0 ) {
            String unknown = "{com.acme.constraint.Syntax.unknown}";
            context.buildConstraintViolationWithTemplate(unknown)
                       .addConstraintViolation();
            return false;
        }
        if ( allowedFormats.size() != 0 
            &amp;&amp; Collections.disjoint( guessedFormats, allowedFormats ) ) {

            String unauthorized = "{com.acme.constraint.Syntax.unauthorized}";
            context.buildConstraintViolationWithTemplate(unauthorized)
                       .addConstraintViolation();
            return false;
        }
        return true;
    }

    Set&lt;Format&gt; guessFormats(String text) { ... }
}</pre></div><p>The default error message is disabled and replaced by a specific
      error message depending on the type of constraint violation detected. In
      this case, only one error report is returned at a given time but a
      constraint validation implementation can return several error
      reports.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintsdefinitionimplementation-constraintfactory"></a>3.5.&nbsp;The ConstraintValidatorFactory</h2></div></div><div></div></div><p>Constraint validation implementation instances are created by a
    <tt class="classname">ConstraintValidatorFactory</tt>.</p><div class="added"><p>The life cycle of
    <tt class="classname">ConstraintValidator</tt> instances is fully dependent of
    the Bean Validation provider and piloted by the
    <tt class="classname">ConstraintValidatorFactory</tt> methods. Therefore,
    <tt class="classname">ConstraintValidatorFactory</tt> implementations (such as
    dependency injection frameworks) must consider these instances as
    belonging to a dependent scope. Bean Validation Provider must release each
    instance retrieved. This is typically done when the
    <tt class="classname">ValidatorFactory</tt> is being closed.</p></div><div class="changed"><div class="example"><a name="d0e1242"></a><p class="title"><b>Example&nbsp;3.20.&nbsp;ConstraintValidatorFactory interface</b></p><pre class="programlisting">/**
 * Instantiate a &lt;code&gt;ConstraintValidator&lt;/code&gt; instance based off its class.
 * The &lt;code&gt;ConstraintValidatorFactory&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; responsible
 * for calling {@link ConstraintValidator#initialize(java.lang.annotation.Annotation)}.
 *
 * @author Dhanji R. Prasanna
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidatorFactory {

    /**
     * @param key The class of the constraint validator to instantiate.
     *
     * @return A new constraint validator instance of the specified class.
     */
    &lt;T extends ConstraintValidator&lt;?,?&gt;&gt; T getInstance(Class&lt;T&gt; key);
    
    /**
     * Signal ConstraintValidatorFactory that the instance is no longer
     * being used by the Bean Validation provider
     *
     * @param instance validator being released
     */
    void releaseInstance(ConstraintValidator&lt;?,?&gt; instance);
}</pre></div></div><div class="changed"><p>The default
    <tt class="classname">ConstraintValidatorFactory</tt> provided by the Bean
    Validation provider implementation uses the public no-arg constructor of
    the <tt class="classname">ConstraintValidator</tt> class. A custom
    <tt class="classname">ConstraintValidatorFactory</tt> can be provided; for
    example it may benefit from dependency injection control in constraint
    implementations (see <a href="#bootstrapping-usageandcontainerexpectation" title="5.5.7.&nbsp;Bootstrapping considerations">Section&nbsp;5.5.7, &#8220;Bootstrapping considerations&#8221;</a>). Any constraint
    implementation relying on
    <tt class="classname">ConstraintValidatorFactory</tt> behaviors specific to an
    implementation (dependency injection, no no-arg constructor and so on) are
    not portable, hence great care should be given before walking that path.
    Make sure to configure the Bean Validation provider to honor any specific
    needs your <tt class="classname">ConstraintValidator</tt> has. As constraint
    designer and writer, make sure to document any specific non compliant
    requirements.</p></div><p><tt class="classname">ConstraintValidatorFactory</tt> should not cache
    instances as the state of each instance can be altered in the
    <tt class="methodname">initialize</tt> method.</p><p>If an exception occurs in the factory while retrieving the
    <tt class="classname">ConstraintValidator</tt> instance, the runtime exception
    is wrapped in a <tt class="classname">ValidationException</tt>. If the
    instance returned by the factory is null, a
    <tt class="classname">ValidationException</tt> is raised.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="constraintdeclarationvalidationprocess"></a>Chapter&nbsp;4.&nbsp;Constraint declaration and validation process</h2></div></div><div></div></div><div class="changed"><p>The Bean Validation specification defines a
  framework for declaring constraints on JavaBean classes, fields and
  properties. Constraints are declared on types and evaluated against
  instances or graphs of instances.</p></div><div class="added"><p>Bean Validation also offers a way to declare
  constructor and method constraints. Parameters and return values are the
  constrained elements. We will discuss method constraints declaration in
  detail at <a href="#constraintdeclarationvalidationprocess-methodlevelconstraints" title="4.5.&nbsp;Method and constructor constraints">Section&nbsp;4.5, &#8220;Method and constructor constraints&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintdeclarationvalidationprocess-requirements"></a>4.1.&nbsp;Requirements on classes to be validated</h2></div></div><div></div></div><p>Objects that are to be validated must fulfill the following
    requirements:</p><div class="itemizedlist"><ul type="disc"><li><p>Properties to be validated must follow the method signature
        conventions for JavaBeans read properties, as defined by the JavaBeans
        specification.</p></li><li><p>Static fields and static methods are excluded from
        validation.</p></li><li><p>Constraints can be applied to interfaces and
        superclasses.</p></li></ul></div><p>The target of an annotation definition can be a field, property, or
    type, provided that:</p><div class="itemizedlist"><ul type="disc"><li><p>the constraint definition supports the specified target
        (<tt class="classname">java.lang.annotation.Target</tt>)</p></li><li><p>the one of the <tt class="classname">ConstraintValidator</tt>s
        declared on the constraint supports the declared type of the target
        (see <a href="#typevalidatorresolution" title="4.6.4.&nbsp;ConstraintValidator resolution algorithm">Section&nbsp;4.6.4, &#8220;ConstraintValidator resolution algorithm&#8221;</a>).</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-requirements-object"></a>4.1.1.&nbsp;Object validation</h3></div></div><div></div></div><p>Constraint declarations can be applied to a class or an interface.
      Applying a constraint to a class or interface expresses a validation
      over the state of the class or the class implementing the
      interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-requirements-property"></a>4.1.2.&nbsp;Field and property validation</h3></div></div><div></div></div><p>Constraint declarations can be applied on both fields and
      properties for the same object type. The same constraint should however
      not be duplicated between a field and its associated property (the
      constraint validation would be applied twice). It is recommended for
      objects holding constraint declarations to adhere to a single state
      access strategy (either annotated fields or properties).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Java Persistence and Bean Validation</h3><p>For maximum portability, persistent properties hosting Bean
        Validation constraints should use the same access strategy used in
        Java Persistence. In other words, place your Bean Validation
        constraint annotations on the same element (field or getter) as your
        Java Persistence annotations.</p></div><p>When a field is annotated with a constraint declaration, field
      access strategy is used to access the state validated by such
      constraint.</p><p>When a property is annotated with a constraint declaration,
      property access strategy is used to access the state validated by such
      constraint.</p><p>When using field access strategy, the bean validation provider
      accesses the instance variable directly. When using the property access
      strategy, the bean validation provider accesses the state via the
      property accessor method. It is required that the class follows the
      method signature conventions for JavaBeans read properties (as defined
      by the JavaBeans <tt class="classname">Introspector</tt> class) for
      constrained properties when constrained properties are used. In this
      case, for every constraint property of type <tt class="classname">T</tt>,
      there is a getter method,
      <tt class="methodname">get&lt;Property-name&gt;</tt>. For
      <tt class="code">boolean</tt> properties,
      <tt class="methodname">is&lt;Property-name&gt;</tt> is an alternative name
      for the getter method. Specifically, if <tt class="methodname">getX</tt> is
      the name of the getter method, where <tt class="classname">X</tt> is a
      string, the name of the persistent property is defined by the result of
      <tt class="code">java.beans.Introspector.decapitalize(X)</tt>.</p><p>The fields or methods visibility are not constrained. Constraints
      on non getter methods are not supported.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1372"></a>4.1.3.&nbsp;Graph validation</h3></div></div><div></div></div><p>In addition to supporting instance validation, validation of
      graphs of object is also supported. The result of a graph validation is
      returned as a unified set of constraint violations.</p><p>Consider the situation where bean <tt class="classname">X</tt>
      contains a field of type <tt class="classname">Y</tt>. By annotating field
      <tt class="classname">Y</tt> with the <tt class="classname">@Valid</tt>
      annotation, the Validator will validate <tt class="classname">Y</tt> (and
      its properties) when <tt class="classname">X</tt> is validated. The exact
      type <tt class="classname">Z</tt> of the value contained in the field
      declared of type <tt class="classname">Y</tt> (subclass, implementation) is
      determined at runtime. The constraint definitions of
      <tt class="classname">Z</tt> are used. This ensures proper polymorphic
      behavior for associations marked <tt class="classname">@Valid</tt>.</p><p>Collection-valued, array-valued and generally
      <tt class="classname">Iterable</tt> fields and properties may also be
      decorated with the <tt class="classname">@Valid</tt> annotation. This causes
      the contents of the iterator to be validated. Any object implementing
      <tt class="classname">java.lang.Iterable</tt> is supported. This includes
      specifically:</p><div class="itemizedlist"><ul type="disc"><li><p>arrays of objects</p></li><li><p><tt class="classname">java.util.Collection</tt></p></li><li><p><tt class="classname">java.util.Set</tt></p></li><li><p><tt class="classname">java.util.List</tt></p></li><li><p><tt class="classname">java.util.Map</tt> (special treatment see
          below)</p></li></ul></div><p>Each object provided by the iterator is validated. For
      <tt class="classname">Map</tt>, the value of each
      <tt class="classname">Map.Entry</tt> is validated (the key is not
      validated).</p><p>Like regular references, its type is determined at runtime and the
      constraint definitions for this particular type are used.</p><p>The <tt class="classname">@Valid</tt> annotation is applied
      recursively. A conforming implementation avoids infinite loops according
      to the rules described in <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1458"></a>4.2.&nbsp;Constraint declaration</h2></div></div><div></div></div><p>Constraint declarations are placed on classes or interfaces
    primarily through annotations. A constraint annotation (see <a href="#constraintsdefinitionimplementation-constraintdefinition" title="3.1.&nbsp;Constraint annotation">Section&nbsp;3.1, &#8220;Constraint annotation&#8221;</a>), can
    be applied to a type, on any of the type's fields or on any of the
    JavaBeans-compliant properties.</p><p>When a constraint is defined on a class, the class instance being
    validated is passed to the <tt class="classname">ConstraintValidator</tt>.
    When a constraint is defined on a field, the value of the field is passed
    to the <tt class="classname">ConstraintValidator</tt>. When a constraint is
    defined on a getter, the result of the getter invocation is passed to the
    <tt class="classname">ConstraintValidator</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintdeclarationvalidationprocess-inheritance"></a>4.3.&nbsp;Inheritance (interface and superclass)</h2></div></div><div></div></div><p>A constraint declaration can be placed on an interface. For a given
    class, constraint declarations held on superclasses as well as interfaces
    are evaluated by the Bean Validation provider. Rules are formally
    described in <a href="#constraintdeclarationvalidationprocess-groupsequence-formaldefinition" title="4.4.6.&nbsp;Formal group definitions">Section&nbsp;4.4.6, &#8220;Formal group definitions&#8221;</a>.</p><p>The effect of constraint declarations is cumulative. Constraints
    declared on a superclass getter will be validated along with any
    constraints defined on an overridden version of the getter according to
    the Java Language Specification visibility rules.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintdeclarationvalidationprocess-groupsequence"></a>4.4.&nbsp;Group and group sequence</h2></div></div><div></div></div><p>A group defines a subset of constraints. Instead of validating all
    constraints for a given object graph, only a subset is validated. This
    subset is defined by the the group or groups targeted. Each constraint
    declaration defines the list of groups it belongs to. If no group is
    explicitly declared, a constraint belongs to the
    <tt class="classname">Default</tt> group.</p><p>Groups are represented by interfaces.</p><div class="example"><a name="d0e1495"></a><p class="title"><b>Example&nbsp;4.1.&nbsp;Definition of groups</b></p><pre class="programlisting">/**
 * Validation group verifing that a user is billable
 */
public interface Billable {}

/**
 * customer can buy without any harrassing checking process
 */
public interface BuyInOneClick {
}</pre></div><p>A constraint can belong to one or more groups.</p><div class="example"><a name="example-assigngrouptoconstraints"></a><p class="title"><b>Example&nbsp;4.2.&nbsp;Assign groups to constraints</b></p><pre class="programlisting">/**
 * User representation
 */
public class User {
    @NotNull
    private String firstname;

    @NotNull(groups = Default.class)
    private String lastname;

    @NotNull(groups = {Billable.class, BuyInOneClick.class})
    private CreditCard defaultCreditCard;
}</pre></div><p>During the validation call, one or more groups are validated. All
    the constraints belonging to this set of group is evaluated on the object
    graph. In <a href="#example-assigngrouptoconstraints" title="Example&nbsp;4.2.&nbsp;Assign groups to constraints">Example&nbsp;4.2, &#8220;Assign groups to constraints&#8221;</a>,
    <tt class="classname">@NotNull</tt> is checked on
    <tt class="literal">defaultCreditCard</tt> when either the
    <tt class="classname">Billable</tt> or <tt class="classname">BuyInOneClick</tt>
    group is validated. <tt class="classname">@NotNull</tt> on
    <tt class="literal">firstname</tt> and <tt class="literal">lastname</tt> are validated
    when the <tt class="classname">Default</tt> group is validated. Reminder:
    constraints held on superclasses and interfaces are considered.</p><p><tt class="classname">Default</tt> is a group predefined by the
    specification</p><pre class="programlisting">package javax.validation.groups;

/**
 * Default Bean Validation group.
 * Unless a list of group is explicitly defined:
 * &lt;ul&gt;
 *  &lt;li&gt;constraints belong to the Default group&lt;/li&gt;
 *  &lt;li&gt;validation apply on the Default group&lt;/li&gt;
 * &lt;/ul&gt;
 * Most structural constraints should belong to the default group.
 *
 * @author Emmanuel Bernard
 */
public interface Default {
}</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-groupsequence-groupinheritance"></a>4.4.1.&nbsp;Group inheritance</h3></div></div><div></div></div><p>In some situations, a group is a superset of one or more groups.
      This can be described by Bean Validation. A group may inherit one or
      more groups by using interface inheritance.</p><div class="example"><a name="d0e1546"></a><p class="title"><b>Example&nbsp;4.3.&nbsp;Groups can inherit other groups</b></p><pre class="programlisting">/**
 * Customer can buy without harrassing checking process
 */
public interface BuyInOneClick extends Default, Billable {}</pre></div><p>For a given interface <tt class="classname">Z</tt>, constraints marked
      as belonging to the group <tt class="classname">Z</tt> (i.e. where the
      annotation element <tt class="methodname">groups</tt> contains the
      interface <tt class="classname">Z</tt>) or any of the super interfaces of
      <tt class="classname">Z</tt> (inherited groups) are considered part of the
      group <tt class="classname">Z</tt>.</p><p>In the following example:</p><div class="example"><a name="d0e1573"></a><p class="title"><b>Example&nbsp;4.4.&nbsp;Use of a inherited group</b></p><pre class="programlisting">/**
 * User representation
 */
public class User {
    @NotNull
    private String firstname;

    @NotNull(groups = Default.class)
    private String lastname;

    @NotNull(groups = Billable.class)
    private CreditCard defaultCreditCard;
}</pre></div><p>validating the group <tt class="classname">BuyInOneClick</tt> will
      lead to the following constraints checking:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">@NotNull</tt> on
          <tt class="literal">firstname</tt> and <tt class="literal">lastname</tt></p></li><li><p><tt class="classname">@NotNull</tt> on
          <tt class="literal">defaultCreditCard</tt></p></li></ul></div><p>because <tt class="classname">Default</tt> and
      <tt class="classname">Billable</tt> are superinterfaces of
      <tt class="classname">BuyInOneClick</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-groupsequence-groupsequence"></a>4.4.2.&nbsp;Group sequence</h3></div></div><div></div></div><p>By default, constraints are evaluated in no particular order
      regardless of which groups they belong to. It is however useful in some
      situations to control the order of constraints evaluation. There are
      often scenarios where a preliminary set of constraints should be
      evaluated prior to other constraints. Here are two examples:</p><div class="itemizedlist"><ul type="disc"><li><p>The second group depends on a stable state to run properly.
          This stable state is verified by the first group.</p></li><li><p>The second group is a heavy consumer of time, CPU or memory
          and its evaluation should be avoided if possible.</p></li></ul></div><p>To implement such ordering, a group can be defined as a sequence
      of other groups. Each group in a group sequence must be processed
      sequentially in the order defined by
      <tt class="methodname">@GroupSequence.value</tt> when the group defined as
      a sequence is requested. Note that a group member of a sequence can
      itself be composed of several groups via inheritance or sequence
      definition. In this case, each composed group must respect the sequence
      order as well.</p><p>Processing a group is defined in <a href="#constraintdeclarationvalidationprocess-validationroutine" title="4.6.&nbsp;Validation routine">Section&nbsp;4.6, &#8220;Validation routine&#8221;</a> ;
      if one of the groups processed in the sequence generates one or more
      constraint violations, the groups following in the sequence must not be
      processed. This ensures that a set of constraint is evaluated only if
      another set of constraint is valid.</p><p>Groups defining a sequence and groups composing a sequence must
      not be involved in a cyclic dependency:</p><div class="itemizedlist"><ul type="disc"><li><p>either directly or indirectly</p></li><li><p>either through cascaded sequence definitions or group
          inheritance</p></li></ul></div><p>If a group containing such a circularity is evaluated, a
      <tt class="classname">GroupDefinitionException</tt> is raised.</p><p>Groups defining a sequence should not directly inherit other
      groups. In other words, the interface hosting the group sequence should
      not have any super interface.</p><p>Groups defining a sequence should not be used directly in
      constraint declarations. In other words, the interface hosting the group
      sequence should not be used in a constraint declaration.</p><p>To define a group as a sequence, the interface must be annotated
      with the <tt class="classname">@GroupSequence</tt> annotation.</p><pre class="programlisting">/**
 * Define a group sequence
 * The interface hosting &lt;code&gt;@GroupSequence&lt;/code&gt; is representing 
 * the group sequence.
 * When hosted on a class, represents the &lt;code&gt;Default&lt;/code&gt; group
 * for that class.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
@Target({ TYPE })
@Retention(RUNTIME)
public @interface GroupSequence {
    Class&lt;?&gt;[] value();
}</pre><p>Here is a usage example</p><div class="example"><a name="example-groupsequence"></a><p class="title"><b>Example&nbsp;4.5.&nbsp;Make use of group sequence</b></p><pre class="programlisting">@ZipCodeCoherenceChecker(groups = Address.HighLevelCoherence.class)
public class Address {
    @NotNull @Size(max = 50)
    private String street1;

    @NotNull @ZipCode
    private String zipcode;

    @NotNull @Size(max = 30)
    private String city;

    /**
     * check coherence on the overall object
     * Needs basic checking to be green first
     */
    public interface HighLevelCoherence {}

    /**
     * check both basic constraints and high level ones.
     * high level constraints are not checked if basic constraints fail
     */
    @GroupSequence({Default.class, HighLevelCoherence.class})
    public interface Complete {}
}</pre></div><p>In <a href="#example-groupsequence" title="Example&nbsp;4.5.&nbsp;Make use of group sequence">Example&nbsp;4.5, &#8220;Make use of group sequence&#8221;</a>, when the
      <tt class="classname">Address.Complete</tt> group is validated, all
      constraints belonging to the <tt class="classname">Default</tt> group are
      validated. If any of them fail, the validation skips the
      <tt class="classname">HighLevelCoherence</tt> group. If all
      <tt class="classname">Default</tt> constraints pass,
      <tt class="classname">HighLevelCoherence</tt> constraints are
      evaluated.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A given constraint can belong to two or more groups ordered by a
        sequence. In this case, the constraint is evaluated as part of the
        first group and ignored in the subsequent group(s). See <a href="#constraintdeclarationvalidationprocess-validationroutine" title="4.6.&nbsp;Validation routine">Section&nbsp;4.6, &#8220;Validation routine&#8221;</a>
        for more information.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup"></a>4.4.3.&nbsp;Redefining the Default group for a class</h3></div></div><div></div></div><p>In <a href="#example-groupsequence" title="Example&nbsp;4.5.&nbsp;Make use of group sequence">Example&nbsp;4.5, &#8220;Make use of group sequence&#8221;</a>, validating the
      <tt class="classname">Default</tt> group does not validate
      <tt class="classname">HighLevelCoherence</tt> constraints. To ensure a
      complete validation, a user must use the <tt class="classname">Complete</tt>
      group. This breaks some of the encapsulation you could expect. You can
      work around this by redefining what the <tt class="classname">Default</tt>
      group means for a given class. To redefine
      <tt class="classname">Default</tt> for a class, place a
      <tt class="classname">@GroupSequence</tt> annotation on the class ; this
      sequence expresses the sequence of groups that does substitute
      <tt class="classname">Default</tt> for this class.</p><div class="example"><a name="example-overridedefaultgroup"></a><p class="title"><b>Example&nbsp;4.6.&nbsp;Redefining Default group for Address</b></p><pre class="programlisting">@GroupSequence({Address.class, HighLevelCoherence.class})
@ZipCodeCoherenceChecker(groups = Address.HighLevelCoherence.class)
public class Address {
    @NotNull @Size(max = 50)
    private String street1;

    @NotNull @ZipCode
    private String zipcode;

    @NotNull @Size(max = 30)
    private String city;

    /**
     * check coherence on the overall object
     * Needs basic checking to be green first
     */
    public interface HighLevelCoherence {}
}</pre></div><p>In <a href="#example-overridedefaultgroup" title="Example&nbsp;4.6.&nbsp;Redefining Default group for Address">Example&nbsp;4.6, &#8220;Redefining Default group for Address&#8221;</a>, when an address
      object is validated for the group <tt class="classname">Default</tt>, all
      constraints belonging to the group <tt class="classname">Default</tt> and
      hosted on <tt class="classname">Address</tt> are evaluated. If none fails,
      all <tt class="classname">HighLevelCoherence</tt> constraints present on
      <tt class="classname">Address</tt> are evaluated. In other words, when
      validating the <tt class="classname">Default</tt> group for
      <tt class="classname">Address</tt>, the group sequence defined on the
      <tt class="classname">Address</tt> class is used.</p><p>Since sequences cannot have circular dependencies, using
      <tt class="classname">Default</tt> in the declaration of a sequence is not
      an option. Constraints hosted on a class <tt class="classname">A</tt> and
      belonging to the <tt class="classname">Default</tt> group (by default or
      explicitly) implicitly belong to the group
      <tt class="classname">A</tt>.</p><p>A sequence defined on a class <tt class="classname">A</tt> (i.e.
      redefining the <tt class="classname">Default</tt> groups for the class) must
      contain the group <tt class="classname">A</tt>. In other words, the default
      constraints hosted on a class must be part of the sequence definition.
      If a <tt class="classname">@GroupSequence</tt> redefining the
      <tt class="classname">Default</tt> group for a class
      <tt class="classname">A</tt> does not contain the group
      <tt class="classname">A</tt>, a
      <tt class="classname">GroupDefinitionException</tt> is raised when the class
      is validated or when its metadata is requested.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-groupsequence-implicitgrouping"></a>4.4.4.&nbsp;Implicit grouping</h3></div></div><div></div></div><p>It is possible to implicitly group several constraints in the same
      group without explicitly listing such a group in the constraint
      declaration. Every constraint hosted on an interface
      <tt class="classname">Z</tt> and part of the <tt class="classname">Default</tt>
      group (implicitly or explicitly) belongs to the group
      <tt class="classname">Z</tt>. This is useful to validate the partial state
      of an object based on a role represented by an interface.</p><div class="example"><a name="d0e1806"></a><p class="title"><b>Example&nbsp;4.7.&nbsp;Example of interface / group hosting constraints</b></p><pre class="programlisting">/**
 * Auditable object contract
 */
public interface Auditable {
    @NotNull String getCreationDate();
    @NotNull String getLastUpdate();
    @NotNull String getLastModifier();
    @NotNull String getLastReader();
}

/**
 * Represents an order in the system
 */
public class Order implements Auditable {
    private String creationDate;
    private String lastUpdate;
    private String lastModifier;
    private String lastReader;

    private String orderNumber;

    public String getCreationDate() {
        return this.creationDate;
    }

    public String getLastUpdate() {
        return this.lastUpdate;
    }

    public String getLastModifier() {
        return this.lastModifier;
    }

    public String getLastReader() {
        return this.lastReader;
    }

    @NotNull @Size(min=10, max=10)
    public String getOrderNumber() {
        return this.orderNumber;
    }
}</pre></div><p>When an <tt class="classname">Order</tt> object is validated on the
      <tt class="classname">Default</tt> group, the following constraints are
      validated: <tt class="classname">@NotNull</tt> on
      <tt class="methodname">getCreationDate</tt>,
      <tt class="methodname">getLastUpdate</tt>,
      <tt class="methodname">getLastModifier</tt>,
      <tt class="methodname">getLastReader</tt>,
      <tt class="methodname">getOrderNumber</tt> and <tt class="classname">@Size</tt>
      on <tt class="methodname">getOrderNumber</tt> as all belong to the
      <tt class="classname">Default</tt> group.</p><p>When an <tt class="classname">Order</tt> object is validated on the
      <tt class="classname">Auditable</tt> group, the following constraints are
      validated: <tt class="classname">@NotNull</tt> on
      <tt class="methodname">getCreationDate</tt>,
      <tt class="methodname">getLastUpdate</tt>,
      <tt class="methodname">getLastModifier</tt>,
      <tt class="methodname">getLastReader</tt>. Only the constraints present on
      <tt class="classname">Auditable</tt> (and any of its super interfaces) and
      belonging to the <tt class="classname">Default</tt> group are validated when
      the group <tt class="classname">Auditable</tt> is requested. It allows the
      caller to validate that a given object can be safely audited even if the
      object state itself is not valid.</p></div><div class="added"><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-groupsequence-groupconversion"></a>4.4.5.&nbsp;Group conversion</h3></div></div><div></div></div><p>When performing cascading validation, it is possible to use a
      different group than the one originally requested using the group
      conversion feature. Group conversions are declared by using the
      <tt class="classname">@ConverGroup</tt> annotation.</p><div class="example"><a name="d0e1886"></a><p class="title"><b>Example&nbsp;4.8.&nbsp;@ConvertGroup annotation</b></p><pre class="programlisting">package javax.validation;

/**
 * Convert group {@code from} to group {@code to} during cascading.
 *
 * @author Emmanuel Bernard
 * @since 1.1
 */
@Target({ TYPE, METHOD, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface ConvertGroup {
    Class&lt;?&gt; from();
    Class&lt;?&gt; to();

    /**
     * Defines several {@code ConvertGroup} annotations
     * on the same element
     */
    public @interface List {
        ConvertGroup[] value();
    }
}</pre></div><p><tt class="classname">@ConvertGroup</tt> and
      <tt class="classname">@ConvertGroup.List</tt> can be used everywhere
      <tt class="classname">@Valid</tt> can be used (associations,
      method/constructor parameters and return value). If these annotations
      are used without <tt class="classname">@Valid</tt>, a
      <tt class="classname">ConstraintDeclarationException</tt> is raised.</p><p>When an element is annotated with <tt class="classname">@Valid</tt>,
      validation is propagated. Groups are passed as is to the nested elements
      unless the <tt class="classname">@ConvertGroup</tt> annotation is
      used.</p><p>If the group expected to be passed to the nested element
      validation is defined as the <tt class="literal">from</tt> attribute of a
      <tt class="classname">@ConvertGroup</tt> annotation, the group used to
      effectively validate the nested element is the corresponding group
      defined in the <tt class="literal">to</tt> attribute.</p><p>Rules are not executed recursively. If a rule is found matching,
      subsequent rules are no longer evaluated. In particular, if a set of
      <tt class="classname">@ConvertGroup</tt> declaration chains group
      <tt class="literal">A</tt> to <tt class="literal">B</tt> and <tt class="literal">B</tt> to
      <tt class="literal">C</tt>, the group <tt class="literal">A</tt> will be converted
      to <tt class="literal">B</tt> and not to <tt class="literal">C</tt>. This both makes
      rules clearer and let you switch two groups.</p><p>It is not legal to have more than one conversion rule containing
      the same <tt class="literal">from</tt> value. In this case, a
      <tt class="classname">ConstraintDeclarationException</tt> is raised.</p><p>Like regular constraint declarations, the <tt class="literal">from</tt>
      attribute cannot refer to a group sequence. A
      <tt class="classname">ConstraintDeclarationException</tt> is raised in this
      situation. The <tt class="literal">to</tt> attribute can. The group sequence
      will then be expanded before validating the associated object.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>When validation is done, group sequences are expanded before
        validating the object and its cascaded objects with the expected
        groups. Group conversion on an associated object happens on the
        already expanded groups.</p><p>The group referred to in
        <tt class="methodname">@ConvertGroup.from</tt> works on expanded groups
        (i.e., after the group sequence has been expanded), not necessarily
        groups passed to the various <tt class="methodname">validate</tt>
        methods</p><p>The group referred to in
        <tt class="methodname">@ConvertGroup.to</tt> will be expanded before
        validating the cascaded object just like a call to the various
        <tt class="methodname">validate</tt> method would have done.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Like most Bean Validation error cases, an illegal set of rules
        can be discovered statically (at compile time). For example, an
        annotation processor could detect such errors.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Group circularity in a group conversion are not problematic
        because:</p><div class="itemizedlist"><ul type="disc"><li><p>only one rule is applied for a given cascade (rules are not
            applied recursively)</p></li><li><p>validation cascading is stopped when the same instance /
            property is validated with the same group in a given path
            (existing rule)</p></li></ul></div></div><p><i><span class="remark">TODO: is ConstraintDeclarationException the right
      exception? Should we create a new one?</span></i></p><i><span class="remark">TODO: think about inheritance, should rules be additive, or
      should an overridden method clear the supermethod rules?</span></i><p>Group conversion is quite useful to facilitate object graph reuse
      without spreading the validation group definitions across several
      layers. Let's look at an example.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2010"></a>4.4.5.1.&nbsp;Group conversion example</h4></div></div><div></div></div><p>In this example we will reuse the <tt class="classname">Address</tt>
        group split and match it to the <tt class="classname">User</tt> group
        split.</p><div class="example"><a name="d0e2021"></a><p class="title"><b>Example&nbsp;4.9.&nbsp;Example of group conversion</b></p><pre class="programlisting">public interface Complete extends Default {}
public interface BasicPostal {}
public interface FullPostal extends BasicPostal {}

public class Address {
    @NotNull(group=BasicPostal.class)
    String street1;

    String street2;

    @ZipCode(group=BasicPostal.class)
    String zipCode;

    @CodeChecker(group=FullPostal.class)
    String doorCode;
}

public class User {
    @Valid
    @ConvertGroup.List( {
        @ConvertGroup(from=Default.class, to=BasicPostal.class),
        @ConvertGroup(from=Complete.class, to=FullPostal.class)
    } )
    Set&lt;Address&gt; getAddresses() { ... }
}</pre></div><p>When validating an instance of <tt class="literal">user</tt> with the
        <tt class="classname">Default</tt> group, the associated addresses are
        validated with the <tt class="classname">BasicPostal</tt> group. When
        validating an instance of <tt class="literal">user</tt> with the
        <tt class="classname">Complete</tt> group, the associated addresses are
        validated with the <tt class="classname">FullPostal</tt> group.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-groupsequence-formaldefinition"></a>4.4.6.&nbsp;Formal group definitions</h3></div></div><div></div></div><p>The formal rules defining groups are as followed. <span class="emphasis"><em>Text
      in italic are comments about the rules.</em></span></p><p>For every class <tt class="classname">X</tt>:</p><div class="orderedlist"><ol type="A"><li><p>For each superclass <tt class="classname">Y</tt> of
          <tt class="classname">X</tt>, the group <tt class="classname">Y</tt>
          contains all constraints of the group <tt class="classname">Y</tt> of
          <tt class="classname">Y</tt></p><p><span class="emphasis"><em>this rule prepares formal concepts for recursive
          discovery</em></span></p></li><li><p>The group <tt class="classname">X</tt> contains the following
          constraints:</p><p><span class="emphasis"><em>group <tt class="classname">X</tt> is a group used on
          sequences redefining the default group on a class (see <a href="#constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup" title="4.4.3.&nbsp;Redefining the Default group for a class">Section&nbsp;4.4.3, &#8220;Redefining the Default group for a class&#8221;</a>)</em></span></p><div class="orderedlist"><ol type="I"><li><p>every constraint declared by the class
              <tt class="classname">X</tt> which does not declare a group or does
              declare the group <tt class="classname">Default</tt>
              explicitly.</p><p><span class="emphasis"><em>all <tt class="classname">Default</tt> constraints
              hosted on <tt class="classname">X</tt></em></span></p></li><li><p>every constraint declared by any interface implemented by
              <tt class="classname">X</tt> and not annotated
              <tt class="classname">@GroupSequence</tt> which does not explicitly
              declare a group or does declare the group
              <tt class="classname">Default</tt> explicitly.</p><p><span class="emphasis"><em>all <tt class="classname">Default</tt> constraints
              hosted on interfaces of <tt class="classname">X</tt>: constraints
              are inherited by the class hierarchy. Interfaces marked as
              <tt class="classname">@GroupSequence</tt> are
              ignored.</em></span></p></li><li><p>if <tt class="classname">X</tt> has a direct superclass
              <tt class="classname">Y</tt>, every constraint in the group
              <tt class="classname">Y</tt></p><p><span class="emphasis"><em>all <tt class="classname">Default</tt> constraints
              hosted on the superclasses of <tt class="classname">X</tt>:
              constraints are inherited by the class
              hierarchy</em></span></p></li></ol></div></li><li><p>If <tt class="classname">X</tt> has no
          <tt class="classname">@GroupSequence</tt> annotation, the group
          <tt class="classname">Default</tt> contains the following
          constraints:</p><p><span class="emphasis"><em>this rule defines which constraints are evaluated
          when validating <tt class="classname">Default</tt> on
          <tt class="classname">X</tt>.</em></span></p><div class="orderedlist"><ol type="I"><li><p>every constraint in the group
              <tt class="classname">X</tt></p></li><li><p>if <tt class="classname">X</tt> has a direct superclass
              <tt class="classname">Y</tt>, every constraint in the group
              <tt class="classname">Default</tt> of
              <tt class="classname">Y</tt></p><p><span class="emphasis"><em>this rule is necessary in case
              <tt class="classname">Y</tt> redefines the group
              <tt class="classname">Default</tt></em></span></p></li></ol></div></li><li><p>If <tt class="classname">X</tt> does have a
          <tt class="classname">@GroupSequence</tt> annotation, the group
          <tt class="classname">Default</tt> contains every constraint belonging
          to every group declared by the <tt class="classname">@GroupSequence</tt>
          annotation.</p><p><span class="emphasis"><em>this rule describes how a class can redefine the
          group <tt class="classname">Default</tt> for itself (see <a href="#constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup" title="4.4.3.&nbsp;Redefining the Default group for a class">Section&nbsp;4.4.3, &#8220;Redefining the Default group for a class&#8221;</a>)</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>the <tt class="classname">@GroupSequence</tt> annotation must
              declare the group <tt class="classname">X</tt></p></li></ul></div></li><li><p>For every interface <tt class="classname">Z</tt>, the group
          <tt class="classname">Z</tt> contains the following constraints:</p><p><span class="emphasis"><em>this rule defines how non
          <tt class="classname">Default</tt> groups are defined</em></span></p><div class="orderedlist"><ol type="I"><li><p>every constraint declared by the interface
              <tt class="classname">Z</tt> which does not explicitly declare a
              group or does declare the group <tt class="classname">Default</tt>
              explicitly.</p><p><span class="emphasis"><em>all <tt class="classname">Default</tt> constraints
              hosted on <tt class="classname">Z</tt>: this rule formally defines
              implicit grouping per interface (see <a href="#constraintdeclarationvalidationprocess-groupsequence-implicitgrouping" title="4.4.4.&nbsp;Implicit grouping">Section&nbsp;4.4.4, &#8220;Implicit grouping&#8221;</a>)</em></span></p></li><li><p>every constraint (which does not explicitly declare a
              group) declared by any superinterface not annotated
              <tt class="classname">@GroupSequence</tt> of the interface
              <tt class="classname">Z</tt></p><p><span class="emphasis"><em>all <tt class="classname">Default</tt> constraints
              hosted on interfaces of <tt class="classname">Z</tt>: groups can be
              inherited (see <a href="#constraintdeclarationvalidationprocess-groupsequence-groupinheritance" title="4.4.1.&nbsp;Group inheritance">Section&nbsp;4.4.1, &#8220;Group inheritance&#8221;</a>)</em></span></p></li><li><p>every constraint declared by the class
              <tt class="classname">X</tt> which explicitly declares the group
              <tt class="classname">Z</tt></p><p><span class="emphasis"><em>every constraint hosted by
              <tt class="classname">X</tt> and marked as belonging to the group
              <tt class="classname">Z</tt></em></span></p></li><li><p>every constraint declared by any interface implemented by
              <tt class="classname">X</tt> and not annotated
              <tt class="classname">@GroupSequence</tt> which explicitly declares
              the group <tt class="classname">Z</tt></p><p><span class="emphasis"><em>every constraint hosted by any interface of
              <tt class="classname">X</tt> and marked as belonging to the group
              <tt class="classname">Z</tt></em></span></p></li><li><p>if <tt class="classname">X</tt> has a direct superclass
              <tt class="classname">Y</tt>, every constraint in the group
              <tt class="classname">Z</tt> of <tt class="classname">Y</tt></p><p><span class="emphasis"><em>every constraint hosted by any superclass of
              <tt class="classname">X</tt> and marked as belonging to the group
              <tt class="classname">Z</tt></em></span></p></li></ol></div></li><li><p>For every interface <tt class="classname">Z</tt> annotated
          <tt class="classname">@GroupSequence</tt>, the group
          <tt class="classname">Z</tt> contains every constraint belonging to
          every group declared by the <tt class="classname">@GroupSequence</tt>
          annotation.</p><p><span class="emphasis"><em>defines the composition side of group sequence but
          does not define the ordering behavior of sequence (see <a href="#constraintdeclarationvalidationprocess-groupsequence-groupsequence" title="4.4.2.&nbsp;Group sequence">Section&nbsp;4.4.2, &#8220;Group sequence&#8221;</a>)</em></span></p></li></ol></div><p>When a given group <tt class="classname">G</tt> (represented by an
      interface <tt class="classname">G</tt>) is requested for the validation of a
      class <tt class="classname">X</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>constraints belonging to the group <tt class="classname">G</tt>
          are evaluated</p></li><li><p>if the interface <tt class="classname">G</tt> is not annotated
          <tt class="classname">@GroupSequence</tt>, every group represented by
          the super interface of <tt class="classname">G</tt> are requested for
          validation</p></li><li><p>if the interface <tt class="classname">G</tt> is annotated with
          <tt class="classname">@GroupSequence</tt>, every group represented by
          the interfaces declared by the <tt class="classname">@GroupSequence</tt>
          annotation are requested for validation</p><div class="itemizedlist"><ul type="circle"><li><p>the validation of groups declared to the
              <tt class="classname">@GroupSequence</tt> must happen in the
              sequencing order declared by
              <tt class="classname">@GroupSequence</tt>: the sequencing order is
              propagated to the groups composing the sequenced group (via
              inheritance or group sequence)</p></li><li><p>if a group validation triggers the failure of one or more
              constraints, groups following in the sequence must not be
              evaluated.</p></li></ul></div></li><li><p>if the group <tt class="classname">G</tt> represents the
          <tt class="classname">Default</tt> group of <tt class="classname">X</tt>
          overridden by <tt class="classname">@GroupSequence</tt>, operations are
          equivalent</p></li></ul></div><p>When the <tt class="classname">Default</tt> group of a given class
      <tt class="classname">X</tt> is overridden via
      <tt class="classname">@GroupSequence</tt>, its validation is as
      followed:</p><div class="itemizedlist"><ul type="disc"><li><p>every group represented by the interfaces declared by the
          <tt class="classname">@GroupSequence</tt> annotation are requested for
          validation</p><div class="itemizedlist"><ul type="circle"><li><p>the validation of groups declared to the
              <tt class="classname">@GroupSequence</tt> must happen in the
              sequencing order declared by
              <tt class="classname">@GroupSequence</tt>: the sequencing order is
              propagated to the groups composing the sequenced group (via
              inheritance or group sequence)</p></li><li><p>if a group validation triggers the failure of one or more
              constraints, groups following in the sequence must not be
              evaluated.</p></li></ul></div></li></ul></div><p>Unless defined by a <tt class="classname">@GroupSequence</tt>,
      evaluation ordering is not constrained. In particular, several groups
      can be validated in the same pass. If a group definition leads to a
      circular sequencing order between groups, a
      <tt class="classname">GroupDefinitionException</tt> is raised.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A group <tt class="classname">G</tt> sequenced (directly or
        indirectly) to be executed before itself is not considered a circular
        reference.</p></div></div></div><div class="added"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintdeclarationvalidationprocess-methodlevelconstraints"></a>4.5.&nbsp;Method and constructor constraints</h2></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In the following, the term "method constraint" refers to
      constraints declared on methods as well as constructors.</p></div><p>Method constraints are declared by adding constraint annotations to
    method - respectively constructor - parameters (parameter constraints) or
    directly to methods - respectively constructors - (return value
    constraints). As with bean constraints, this can be done using either
    actual Java annotations or using an XML constraint mapping file (see <a href="#xml-mapping-constraintdeclarationinxml-methodleveloverriding" title="8.1.1.4.&nbsp;Method-level overriding">Section&nbsp;8.1.1.4, &#8220;Method-level overriding&#8221;</a>).
    Bean Validation providers are free to provide additional means of defining
    method constraints such as an API-based approach.</p><p>Getters are not considered constrained methods.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2495"></a>4.5.1.&nbsp;Requirements on methods to be validated</h3></div></div><div></div></div><p>Constrained methods must be non-static. No other restrictions
      exist from the perspective of this specification, however it is possible
      that technologies integrating with method validation impose further
      restrictions to methods to which a validation shall be applied. For
      instance certain integration technologies might require that methods to
      be validated must have <tt class="methodname">public</tt> visibility and/or
      must not be final.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2503"></a>4.5.2.&nbsp;Declare parameter constraints</h3></div></div><div></div></div><p>Parameter constraints are declared by putting constraint
      annotations on method or constructor parameters.</p><div class="example"><a name="d0e2508"></a><p class="title"><b>Example&nbsp;4.10.&nbsp;Declaring parameter constraints</b></p><pre class="programlisting">public class OrderService {

    public OrderService(@NotNull CreditCardProcessor creditCardProcessor) {
        //...
    }

    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity) {

        //...
    }
}</pre></div><i><span class="remark">TODO: Consistently use "..." or "//..." for omissions</span></i><p>Using constraint annotations, several preconditions are defined
      here. These preconditions which must be satisfied in order to legally
      invoke the methods of <tt class="classname">OrderService</tt> are:</p><div class="itemizedlist"><ul type="disc"><li><p>The <tt class="classname">CreditCardProcessor</tt> passed to the
          constructor must not be null.</p></li><li><p>The customer code passed to the
          <tt class="methodname">placeOrder()</tt> method must not be null and
          must be between 3 and 20 characters long.</p></li><li><p>The <tt class="classname">Item</tt> passed to the
          <tt class="methodname">placeOrder()</tt> method must not be
          null.</p></li><li><p>The quantity value passed to the
          <tt class="methodname">placeOrder()</tt> method must be 1 at
          least.</p></li></ul></div><p>Note that declaring these constraints does not automatically cause
      their validation when the concerned methods are invoked. It's the
      responsibility of an integration layer to trigger the validation of the
      constraints using a method interceptor, dynamic proxy or similar. See
      section <a href="#validationapi-triggeringmethodvalidation" title="5.4.&nbsp;Triggering method validation">Section&nbsp;5.4, &#8220;Triggering method validation&#8221;</a> for
      more details.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>In order to use constraint annotations for method or constructor
        parameters, their element type must be
        <tt class="varname">ElementType.PARAMETER</tt>. In order to use constraint
        annotations for cross-parameter validation or on the return values of
        methods or constructors (see the following sections), their element
        type must be <tt class="varname">ElementType.METHOD</tt> respectively
        <tt class="varname">ElementType.CONSTRUCTOR</tt>. All built-in constraints
        support these element types and it is considered a best practice to do
        the same for custom constraints.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="constraintdeclarationvalidationprocess-crossparameterconstraints"></a>4.5.2.1.&nbsp;Cross-parameter constraints</h4></div></div><div></div></div><p>Cross-parameter constraints allow to express constraints based
        on the value of several method parameters, similar to class-level
        constraints which are based on several properties of a given class.
        Cross-parameter constraints are declared by putting cross-parameter
        constraint annotations on methods or constructors as shown in the
        following example.</p><div class="example"><a name="d0e2569"></a><p class="title"><b>Example&nbsp;4.11.&nbsp;Declaring cross-parameter constraints</b></p><pre class="programlisting">public class CalendarService {

    @ConsistentDateParameters
    public void createEvent(
        String title,
        @NotNull Date startDate,
        @NotNull Date endDate) {
        //...
    }
}</pre></div><p>The cross-parameter constraint annotation expresses here that
        the given start date must be before the passed end date in order to
        legally invoke the <tt class="methodname">createEvent()</tt> method. The
        example also shows that it is often useful to combine constraints
        directly placed on individual parameters (<tt class="classname">e.g.
        @NotNull</tt>) and cross-parameter constraints.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>Cross-parameter constraints as well as return value
            constraints are declared directly on a method or a constructor. To
            make it obivious for a reader that an annotation refers to the
            parameters of a method or constructor and not its return value, it
            is recommended to chose a name which clearly expresses this
            intention.</p></div><p>Cross parameters constraints are validated at the same time as
        parameter constraints.</p><p><i><span class="remark">TODO: Decide on whether to include the type-safe
        approach from <a href="http://beanvalidation.org/proposals/BVAL-232/" target="_top">http://beanvalidation.org/proposals/BVAL-232/</a>.</span></i></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="constraintdeclarationvalidationprocess-methodlevelconstraints-definingparameterconstraints-namingparameters"></a>4.5.2.2.&nbsp;Naming parameters</h4></div></div><div></div></div><p>In case the validation of a parameter constraint fails, the
        concerned parameter needs to be identified in the resulting
        <tt class="classname">ConstraintViolation</tt> (see section <a href="#validationapi-constraintviolation" title="5.2.&nbsp;ConstraintViolation">Section&nbsp;5.2, &#8220;ConstraintViolation&#8221;</a>). As of version 7, Java
        doesn't provide a portable way to retrieve parameter names. Bean
        Validation therefore defines the
        <tt class="classname">javax.validation.ParameterNameProvider</tt> API to
        which the retrieval of parameter names is delegated:</p><pre class="programlisting">/**
 * &lt;p&gt;
 * Provides names for method and constructor parameters.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Used by the Bean Validation runtime when creating constraint violation
 * objects for violated method constraints.&lt;/p&gt;
 * &lt;p&gt;
 * Implementations must be thread-safe.
 * &lt;/p&gt;
 *
 * @author Gunnar Morling
 */
public interface ParameterNameProvider {

    /**
     * Returns the names of the parameters of the given constructor.
     *
     * @param constructor
     *            The constructor for which the parameter names shall be
     *            retrieved. Never null.
     *
     * @return An array with the names of the parameters of the given
     *         constructor. May be empty but never null.
     */
    String[] getParameterNames(Constructor&lt;?&gt; constructor);

    /**
     * Returns the names of the parameters of the given method.
     *
     * @param method
     *            The method for which the parameter names shall be retrieved.
     *            Never null.
     *
     * @return An array with the names of the parameters of the given method.
     *         May be empty but never null.
     */
    String[] getParameterNames(Method method);
}</pre><p>A conforming Bean Validation implementation provides a default
        <tt class="classname">ParameterNameProvider</tt> implementation which
        returns parameter names in the form
        <tt class="varname">arg</tt><span class="emphasis"><em>PARAMETER_INDEX</em></span>, where
        <span class="emphasis"><em>PARAMETER_INDEX</em></span> starts at 0 for the first
        parameter, e.g. <tt class="varname">arg0</tt>, <tt class="varname">arg1</tt>
        etc.</p><p>Bean Validation providers and integrators are free to provide
        additional implementations (e.g. based on annotations specifying
        parameter names, debug symbols etc.). If a user wishes to use another
        parameter name provider than the default implementation, she may
        specify the provider to use with help of the bootstrap API (see <a href="#bootstrapping" title="5.5.&nbsp;Bootstrapping">Section&nbsp;5.5, &#8220;Bootstrapping&#8221;</a>) or the XML configuration (see <a href="#xml-config" title="5.5.6.&nbsp;XML Configuration: META-INF/validation.xml">Section&nbsp;5.5.6, &#8220;XML Configuration: META-INF/validation.xml&#8221;</a>).</p><p>If an exception occurs during invocation of the
        <tt class="methodname">getParameterNames()</tt> methods, this exception
        is wrapped into a <tt class="classname">ValidationException</tt> by the
        Bean Validation engine.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2642"></a>4.5.3.&nbsp;Declaring return value constraints</h3></div></div><div></div></div><p>Return value constraints are declared by putting constraint
      annotations directly on a method or constructor.</p><div class="example"><a name="d0e2647"></a><p class="title"><b>Example&nbsp;4.12.&nbsp;Declaring return value constraints</b></p><pre class="programlisting">public class OrderService {

    private CreditCardProcessor creditCardProcessor;

    @ValidOnlineOrderService
    public OrderService(OnlineCreditCardProcessor creditCardProcessor) {
        this.creditCardProcessor = creditCardProcessor;
    }

    @ValidBatchOrderService
    public OrderService(BatchCreditCardProcessor creditCardProcessor) {
        this.creditCardProcessor = creditCardProcessor;
    }

    @NotNull
    @Size(min=1)
    public Set&lt;CreditCardProcessor&gt; getCreditCardProcessors() { ... }

    @NotNull
    @Future
    public Date getNextAvailableDeliveryDate() { ... }
}</pre></div><p>Here the following postconditions are defined which are guaranteed
      to the caller of the methods and constructors of the
      <tt class="classname">OrderService</tt> class:</p><div class="itemizedlist"><ul type="disc"><li><p>The newly created <tt class="classname">OrderService</tt> object
          returned by the first constructor satisfies the conditions of the
          custom <tt class="classname">@ValidOnlineOrderService</tt>
          constraint.</p></li><li><p>The newly created <tt class="classname">OrderService</tt> object
          returned by the second constructor satisfies the conditions of the
          custom <tt class="classname">@ValidBatchOrderService</tt>
          constraint.</p></li><li><p>The set of <tt class="classname">CreditCardProcessor</tt> objects
          returned by <tt class="methodname">getCreditCardProcessors()</tt> will
          neither be null nor empty.</p></li><li><p>The <tt class="classname">Date</tt> object returned by
          <tt class="methodname">getNextAvailableDeliveryDate()</tt> will not be
          null and will be in the future.</p></li></ul></div><p>Like parameter constraints, these return value constraints are not
      per-se validated upon method invocation, but instead an integration
      layer invoking the validation is required.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2696"></a>4.5.4.&nbsp;Marking parameters and return values for cascaded
      validation</h3></div></div><div></div></div><p>Similar to normal bean validation, the
      <tt class="classname">@Valid</tt> annotation is used to declare that a
      cascaded validation of the given method parameters or return values
      shall be performed by the Bean Validation provider. When marked, the
      parameter or return value is considered a bean object to validate.
      Generally the same rules as for standard object graph validation (see
      <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
      apply, in particular</p><div class="itemizedlist"><ul type="disc"><li><p>null arguments and null return values are ignored</p></li><li><p>The validation is recursive; that is, if validated parameter
          or return value objects have references marked with
          <tt class="classname">@Valid</tt> themselves, these references will also
          be validated</p></li><li><p>Bean Validation providers must guarantee the prevention of
          infinite loops during cascaded validation</p></li></ul></div><div class="example"><a name="d0e2719"></a><p class="title"><b>Example&nbsp;4.13.&nbsp;Marking parameters and return values for cascaded
        validation</b></p><pre class="programlisting">public class OrderService {

    @NotNull @Valid
    private CreditCardProcessor creditCardProcessor;

    @Valid
    public OrderService(@NotNull @Valid CreditCardProcessor creditCardProcessor) {
        this.creditCardProcessor = creditCardProcessor;
    }

    @NotNull @Valid
    public Order getOrderByPk(@NotNull @Valid OrderPK orderPk) { ... }

    @NotNull @Valid
    public Set&lt;Order&gt; getOrdersByCustomer(@NotNull @Valid CustomerPK customerPk) { ... }
}</pre></div><p>Here the following recursive validations will happen when
      validating the methods of the <tt class="classname">OrderService</tt>
      class:</p><div class="itemizedlist"><ul type="disc"><li><p>Validation of the constraints on the object passed for the
          <tt class="varname">creditCardProcessor</tt> parameter of the
          constructor</p></li><li><p>Validation of the constraints on the newly created
          <tt class="classname">OrderService</tt> instance returned by the
          constructor, i.e. the <tt class="classname">@NotNull</tt> constraint on
          the field <tt class="varname">creditCardProcessor</tt> and the constraints
          on the referenced <tt class="classname">CreditCardProcessor</tt>
          instance (as the field is annotated with
          <tt class="classname">@Valid</tt>).</p></li><li><p>Validation of the constraints on the object passed for the
          <tt class="varname">orderPk</tt> parameter and the returned
          <tt class="classname">Order</tt> object of the
          <tt class="methodname">getOrderByPk()</tt> method</p></li><li><p>Validation of the constraints on the object passed for the
          <tt class="varname">customerPk</tt> parameter and the constraints on each
          object contained within the returned
          <tt class="varname">Set&lt;Order&gt;</tt> of the
          <tt class="methodname">getOrdersByCustomer()</tt> method</p></li></ul></div><p>Again, solely marking parameters and return values for cascaded
      validation does not trigger the actual validation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2780"></a>4.5.5.&nbsp;Method constraints in inheritance hierarchies</h3></div></div><div></div></div><p>When defining method constraints within inheritance hierarchies
      (that is, class inheritance by extending base classes and interface
      inheritance by implementing or extending interfaces) one has to obey the
      <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_top">Liskov
      substitution</a> principle which mandates that:</p><div class="itemizedlist"><ul type="disc"><li><p>a method's preconditions (as represented by parameter
          constraints) may not be strengthened in sub types</p></li><li><p>a method's postconditions (as represented by return value
          constraints) may not be weakened in sub types</p></li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>Very informally speaking, the Liskov substituation principle
        says that where a given type T is used, it should be possible to
        replace T with a sub-type S of T ("Behavioral subtyping"). If S
        overrides/implements a method from T and S would strengthen the
        method's preconditions (e.g. by adding parameter constraints) this
        principle would be violated as client code working correctly against T
        might fail when working against S. Also if S overrides/implements a
        method from T and S weakens the method's postconditions this principle
        would be violated. However S may strengthen the method's
        postconditions (by adding return value constraints), as client code
        working against T still will work against S.</p></div><p>Therefore the following rules with respect to the definition of
      method level constraints in inheritance hierarchies apply:</p><div class="itemizedlist"><ul type="disc"><li><p>In sub types (be it sub classes/interfaces or interface
          implementations) no parameter constraints must be declared on
          overridden or implemented methods, nor may parameters be marked for
          cascaded validation (since this would pose a strengthening of
          preconditions to be fulfilled by the caller).</p></li><li><p>If a sub type overrides/implements a method originally defined
          in several parallel types of the hierarchy (e.g. two interfaces not
          extending each other, or a class and an interface not implemented by
          said class) no parameter constraints may be declared for that method
          at all. This again is to avoid an unexpected strengthening of
          preconditions to be fulfilled by the caller.</p></li><li><p>In sub types (be it sub classes/interfaces or interface
          implementations) return value constraints may be declared on
          overridden or implemented methods and the return value may be marked
          for cascaded validation. Upon validation, all return value
          constraints of the method in question are validated, wherever they
          are declared in the hierarchy (since this only poses possibly a
          strengthening but no weakening of the method's postconditions
          guaranteed to the caller).</p></li></ul></div><p>Out of the box, a conforming Bean Validation provider must throw a
      <tt class="classname">ConstraintDeclarationException</tt> when discovering
      that any of these rules are violated. In addition providers may
      implement alternative, potentially more liberal, approaches for handling
      constrained methods in inheritance hierarchies. Possible means for
      activating such alternative behavior include provider-specific
      configuration properties or annotations. Note that client code relying
      on such alternative behavior may not be portable between Bean Validation
      providers.</p><p>The above rules do not apply when validating constructor
      constraints. Parameter and return value constraints can be applied to
      any constructor in the type hierarchy, however, only the constraints
      defined directly on the validated constructor are evaluated. Constraints
      defined on super type constructors are not evaluated, even if the
      constructor in question calls the super type constructor via
      <tt class="methodname">super()</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2820"></a>4.5.5.1.&nbsp;Examples</h4></div></div><div></div></div><p>This sections provides some examples of illegal constraint
        definitions which violate the rules stated above in one way or
        another.</p><div class="example"><a name="d0e2825"></a><p class="title"><b>Example&nbsp;4.14.&nbsp;Illegally declared parameter constraints on interface
          implementation</b></p><pre class="programlisting">public interface OrderService {

    void placeOrder(String customerCode, Item item, int quantity);

}

public class SimpleOrderService implements OrderService {

    @Override
    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity) { ... }

}</pre></div><p>The constraints in <tt class="classname">SimpleOrderService</tt> are
        illegal, as they strengthen the preconditions of the
        <tt class="methodname">placeOrder()</tt> method as constituted by the
        interface <tt class="classname">OrderService</tt>.</p><div class="example"><a name="d0e2842"></a><p class="title"><b>Example&nbsp;4.15.&nbsp;Illegally declared parameter constraints on sub
            class</b></p><pre class="programlisting">public class OrderService {

    void placeOrder(String customerCode, Item item, int quantity) { ... }

}

public class SimpleOrderService extends OrderService {

    @Override
    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity) { ... }

}</pre></div><p>The constraints in <tt class="classname">SimpleOrderService</tt> are
        illegal, as they strengthen the preconditions of the
        <tt class="methodname">placeOrder()</tt> method as constituted by the
        super class <tt class="classname">OrderService</tt>.</p><div class="example"><a name="illegal_constraints_in_parallel_types"></a><p class="title"><b>Example&nbsp;4.16.&nbsp;Illegally declared parameter constraints on parallel
            types</b></p><pre class="programlisting">public interface OrderService {

    void placeOrder(String customerCode, Item item, int quantity);

}

public interface OrderPlacementService {

    public void placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull Item item,
        @Min(1) int quantity);

}

public class SimpleOrderService implements OrderService, OrderPlacementService {

    @Override
    public void placeOrder(String customerCode, Item item, int quantity) { ... }

}</pre></div><p>Here the class <tt class="classname">SimpleOrderService</tt>
        implements the interfaces <tt class="classname">OrderService</tt> and
        <tt class="classname">OrderPlacementService</tt>, which themselves are
        unrelated to each other but both define a method
        <tt class="methodname">placeOrder()</tt> with an identical signature.
        This hierarchy is illegal with respect to the parameter constraints as
        a client of <tt class="classname">SimpleOrderService</tt> would have to
        fulfill the constraints defined on the interface
        <tt class="classname">OrderPlacementService</tt> also if she only has a
        reference of the static type
        <tt class="classname">OrderService</tt>.</p><div class="example"><a name="d0e2887"></a><p class="title"><b>Example&nbsp;4.17.&nbsp;Correctly declared return value constraints on sub
            class</b></p><pre class="programlisting">public class OrderService {

    Order placeOrder(String customerCode, Item item, int quantity) { ... }

}

public class SimpleOrderService extends OrderService {

    @Override
    @NotNull
    @Valid
    public Order placeOrder(String customerCode, Item item, int quantity) { ... }

}</pre></div><p>The return value constraints in
        <tt class="classname">DefaultOrderService</tt> are legal, as they
        strengthen the postconditions of the
        <tt class="methodname">placeOrder()</tt> method as constituted by the
        super class <tt class="classname">OrderService</tt> but don't weaken
        them.</p></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintdeclarationvalidationprocess-validationroutine"></a>4.6.&nbsp;Validation routine</h2></div></div><div></div></div><p>For a given group, the validation routine applied on a given bean
    instance is expected to execute the following constraint validations in no
    particular order:</p><div class="itemizedlist"><ul type="disc"><li><p>for all <span class="emphasis"><em>reachable</em></span> fields, execute all field
        level validations (including the ones expressed on superclasses)
        matching the targeted group unless the given validation constraint has
        already been processed during this validation routine for a given
        navigation path (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
        as part of a previous group match.</p></li><li><p>for all <span class="emphasis"><em>reachable</em></span> getters, execute all
        getter level validations (including the ones expressed on interfaces
        and superclasses) matching the targeted group unless the given
        validation constraint has already been processed during this
        validation routine for a given navigation path (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
        as part of a previous group match.</p></li><li><p>execute all class level validations (including the ones
        expressed on interfaces and superclasses) matching the targeted group
        unless the given validation constraint has already been processed
        during this validation routine for a given navigation path (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
        as part of a previous group match.</p></li><li><p>for all <span class="emphasis"><em>reachable</em></span> and
        <span class="emphasis"><em>cascadable</em></span> associations, execute all cascading
        validations (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
        including the ones expressed on interfaces and superclasses (see <a href="#constraintdeclarationvalidationprocess-groupsequence-formaldefinition" title="4.4.6.&nbsp;Formal group definitions">Section&nbsp;4.4.6, &#8220;Formal group definitions&#8221;</a>).
        <span class="added"><span>Note that group conversion can apply (see
        <a href="#constraintdeclarationvalidationprocess-groupsequence-groupconversion" title="4.4.5.&nbsp;Group conversion">Section&nbsp;4.4.5, &#8220;Group conversion&#8221;</a>).</span></span></p></li></ul></div><p>Reachable fields, getters and associations as well as cascadable
    associations are defined in <a href="#constraintdeclarationvalidationprocess-validationroutine-traversable" title="4.6.3.&nbsp;Traversable property">Section&nbsp;4.6.3, &#8220;Traversable property&#8221;</a>.</p><p>Note that this implies that a given validation constraint will not
    be processed more than once per validation.</p><p>Unless ordered by group sequences, groups can be validated in no
    particular order. This implies that the validation routine can be run for
    several groups in the same pass.</p><p>The object validation routine is described as such. For each
    constraint declaration:</p><div class="itemizedlist"><ul type="disc"><li><p>determine for the constraint declaration, the appropriate
        <tt class="classname">ConstraintValidator</tt> to use (see <a href="#typevalidatorresolution" title="4.6.4.&nbsp;ConstraintValidator resolution algorithm">Section&nbsp;4.6.4, &#8220;ConstraintValidator resolution algorithm&#8221;</a>).</p></li><li><p>execute the <tt class="methodname">isValid</tt> operation (from the
        constraint validation implementation) on the appropriate data (see
        <a href="#constraintsdefinitionimplementation-validationimplementation" title="3.4.&nbsp;Constraint validation implementation">Section&nbsp;3.4, &#8220;Constraint validation implementation&#8221;</a>)</p></li><li><p>if <tt class="methodname">isValid</tt> returns true, continue to
        the next constraint,</p></li><li><p>if <tt class="methodname">isValid</tt> returns false, the Bean
        Validation provider populates
        <tt class="classname">ConstraintViolation</tt> object(s) according to the
        rules defined in <a href="#constraintsdefinitionimplementation-validationimplementation" title="3.4.&nbsp;Constraint validation implementation">Section&nbsp;3.4, &#8220;Constraint validation implementation&#8221;</a>
        and appends these objects to the list of constraint violations.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-validationroutine-graphvalidation"></a>4.6.1.&nbsp;Object graph validation</h3></div></div><div></div></div><p>The <tt class="classname">@Valid</tt> annotation on a given
      association (i.e. object reference or collection, array,
      <tt class="classname">Iterable</tt> of objects), dictates the Bean Validator
      implementation to apply recursively the Bean Validation routine on (each
      of) the associated object(s). This mechanism is recursive: an associated
      object can itself contain cascaded references.</p><p>Null references are ignored.</p><p>To prevent infinite loops, the Bean Validation implementation must
      ignore the cascading operation if the associated object instance has
      already been validated in the current navigation path (starting from the
      root object). See <a href="#example-oglimit" title="Example&nbsp;4.18.&nbsp;Object graph limits">Example&nbsp;4.18, &#8220;Object graph limits&#8221;</a> for an example. A
      navigation path is defined as a set of <tt class="classname">@Valid</tt>
      associations starting from the root object instance and reaching the
      associated instance. A given navigation path cannot contain the same
      instance multiple times (the complete validated object graph can
      though). See <a href="#example-oglimit" title="Example&nbsp;4.18.&nbsp;Object graph limits">Example&nbsp;4.18, &#8220;Object graph limits&#8221;</a> for an example.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This object graph navigation can lead to multiple validations of
        the same constraint and the same object instance but the set of
        constraint validation is deterministic and the algorithm prevents
        infinite loops.</p></div><div class="example"><a name="example-oglimit"></a><p class="title"><b>Example&nbsp;4.18.&nbsp;Object graph limits</b></p><pre class="programlisting">#assuming the following object graph

Order -(lines)-&gt; Orderline1
Order -(lines)-&gt; Orderline2
Orderline1 -(order)-&gt; Order
Orderline2 -(order)-&gt; Order
Order -(customer)-&gt; User
Order -(shippingAddress)-&gt; Address1
Order -(billingAddress)-&gt; Address2
Address1 -(inhabitant)-&gt; User
Address2 -(inhabitant)-&gt; User
User -(addresses)-&gt; Address1
User -(addresses)-&gt; Address2

#validation branches are as followed
Order -(lines)-&gt; Orderline1
  - order is ignored: Order is already present in the branch 

Order -(lines)-&gt; Orderline2
  - order is ignored: Order is already present in the branch

Order -(customer)-&gt; User -(addresses)-&gt; Address1
  - inhabitant is ignored: User is already present in the branch

Order -(customer)-&gt; User -(addresses)-&gt; Address2
  - inhabitant is ignored: User is already present in the branch

Order -(shippingAddress)-&gt; Address1 -(inhabitant)-&gt; User 
  - addresses to Address1 is ignored: Address1 is already present in the branch

Order -(shippingAddress)-&gt; Address1 -(inhabitant)-&gt; User -(addresses)-&gt; Address2
  - inhabitant is ignored: User is already present in the branch

Order -(billingAddress)-&gt; Address2 -(inhabitant)-&gt; User 
  - addresses to Address2 is ignored: Address2 is already present in the branch

Order -(billingAddress)-&gt; Address2 -(inhabitant)-&gt; User -(addresses)-&gt; Address1
  - inhabitant is ignored: User is already present in the branch</pre></div><p>The <tt class="classname">ConstraintViolation</tt> objects are built
      when a failing constraint on an associated object is found. They reflect
      the path to reach the object from the root validated object (See <a href="#validationapi-constraintviolation" title="5.2.&nbsp;ConstraintViolation">Section&nbsp;5.2, &#8220;ConstraintViolation&#8221;</a>).</p><p><tt class="classname">@Valid</tt> is an orthogonal concept to the
      notion of group. If two groups are in sequence, the first group must
      pass for all associated objects before the second group is evaluated.
      Note however that the <tt class="classname">Default</tt> group sequence
      overriding is local to the class it is defined on and is not propagated
      to the associated objects. The following example illustrates
      this:</p><div class="example"><a name="d0e3035"></a><p class="title"><b>Example&nbsp;4.19.&nbsp;Class Driver with redefined default group</b></p><pre class="programlisting">@GroupSequence({ Minimal.class, Driver.class })
public class Driver {
  @Min(value = 18, groups = Minimal.class)
  int age;

  @AssertTrue
  Boolean passedDrivingTest;

  @Valid
  Car car;

  // setter/getters
}</pre></div><div class="example"><a name="d0e3040"></a><p class="title"><b>Example&nbsp;4.20.&nbsp;Class Car with redefined default group</b></p><pre class="programlisting">@GroupSequence({ Car.class, Later.class })
public class Car {
  @NotNull
  String type;

  @AssertTruegroups = Later.class)
  Boolean roadWorthy;

  // setter/getters
}</pre></div><div class="example"><a name="d0e3045"></a><p class="title"><b>Example&nbsp;4.21.&nbsp;Defining a group sequence</b></p><pre class="programlisting">@GroupSequence({ Minimal.class, Later.class })
public interface SequencedGroups {
}</pre></div><div class="example"><a name="d0e3050"></a><p class="title"><b>Example&nbsp;4.22.&nbsp;Group sequence overriding is not propagated to associated
          objects</b></p><pre class="programlisting">Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Driver driver = new Driver();
driver.setAge(16);
Car porsche = new Car();
driver.setCar(porsche);


Set&lt;ConstraintViolation&lt;Driver&gt;&gt; violations = validator.validate( driver );

assert violations.size() == 2;

violations = validator.validate( driver, SequencedGroups.class );

assert violations.size() == 1;</pre></div><p>The default group sequence is redefined for the
      <tt class="classname">Driver</tt> as well as <tt class="classname">Car</tt>.
      When the default group is requested via <tt class="methodname">validator.validate(
      driver )</tt> the group <tt class="classname">Minimal</tt> gets
      validated in class <tt class="classname">Driver</tt>. The constraint will
      fail since the driver's age in the example is only 16. The constraint on
      <span class="property">passedDrivingTest</span> will not be evaluated due to the
      redefined default sequence of <tt class="classname">Driver</tt>. However,
      there is one more constraint violation, namely the
      <tt class="classname">@NotNull</tt> on <span class="property">Car.type</span>. The
      reason for this is that the group <tt class="classname">Default</tt> gets
      propagated to <tt class="classname">Car</tt> (not
      <tt class="classname">Minimal</tt>). Class <tt class="classname">Driver</tt>
      defines its own group sequence which means that <tt class="classname">only
      @NotNull</tt> on <span class="property">type</span> gets evaluated.</p><p>In the second call to <tt class="methodname">validate</tt> the group
      <tt class="classname">SequencedGroups</tt> is requested which defines a
      sequence of <tt class="classname">Minimal</tt> followed by
      <tt class="classname">Later</tt>. In this case there is only one constraint
      violation. Again <tt class="classname">@Min</tt> on <span class="property">age</span>
      fails, but in this case the group <tt class="classname">Minimal</tt> gets
      propagated to <tt class="classname">Car</tt> which does not have any
      constraints defined against this group. Constraints belonging to the
      group <tt class="classname">Later</tt> won't get validated until all
      constraints belonging to <tt class="classname">Minimal</tt> pass.</p></div><div class="added"><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3133"></a>4.6.2.&nbsp;Method validation</h3></div></div><div></div></div><p>For a given group, the validation routine applied to validate
      parameters of a method or constructor is expected to execute the
      following constraint validations in no particular order:</p><div class="itemizedlist"><ul type="disc"><li><p>for all <span class="emphasis"><em>reachable</em></span> parameters, execute all
          parameter validations (including the ones expressed on interfaces
          and superclasses) matching the targeted group unless the given
          validation constraint has already been processed during this
          validation routine for a given navigation path (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
          as part of a previous group match.</p></li><li><p>execute all cross parameter validations (including the ones
          expressed on interfaces and superclasses) matching the targeted
          group unless the given validation constraint has already been
          processed during this validation routine for a given navigation path
          (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
          as part of a previous group match.</p></li><li><p>for all <span class="emphasis"><em>reachable</em></span> and
          <span class="emphasis"><em>cascadable</em></span> parameters, execute all cascading
          validations (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
          including the ones expressed on interfaces and superclasses (see
          <a href="#constraintdeclarationvalidationprocess-groupsequence-formaldefinition" title="4.4.6.&nbsp;Formal group definitions">Section&nbsp;4.4.6, &#8220;Formal group definitions&#8221;</a>).
          Note that group conversion can apply (see <a href="#constraintdeclarationvalidationprocess-groupsequence-groupconversion" title="4.4.5.&nbsp;Group conversion">Section&nbsp;4.4.5, &#8220;Group conversion&#8221;</a>).</p></li></ul></div><p>For a given group, the validation routine applied to validate the
      return value of a method or constructor is expected to execute the
      following constraint validations in no particular order:</p><div class="itemizedlist"><ul type="disc"><li><p>if the return value is <span class="emphasis"><em>reachable</em></span>, execute
          all return value validations (including the ones expressed on
          interfaces and superclasses) matching the targeted group unless the
          given validation constraint has already been processed during this
          validation routine for a given navigation path (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
          as part of a previous group match.</p></li><li><p>if the return value is <span class="emphasis"><em>reachable</em></span> and
          <span class="emphasis"><em>cascadable</em></span>, execute all cascading validations
          (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="4.6.1.&nbsp;Object graph validation">Section&nbsp;4.6.1, &#8220;Object graph validation&#8221;</a>)
          including the ones expressed on interfaces and superclasses (see
          <a href="#constraintdeclarationvalidationprocess-groupsequence-formaldefinition" title="4.4.6.&nbsp;Formal group definitions">Section&nbsp;4.4.6, &#8220;Formal group definitions&#8221;</a>).
          Note that group conversion can apply (see <a href="#constraintdeclarationvalidationprocess-groupsequence-groupconversion" title="4.4.5.&nbsp;Group conversion">Section&nbsp;4.4.5, &#8220;Group conversion&#8221;</a>).</p></li></ul></div><p>Reachable and cascadable parameters and return values are defined
      in <a href="#constraintdeclarationvalidationprocess-validationroutine-traversable" title="4.6.3.&nbsp;Traversable property">Section&nbsp;4.6.3, &#8220;Traversable property&#8221;</a>.</p><p>Note that this implies that a given validation constraint will not
      be processed more than once per validation.</p><p>Unless ordered by group sequences, groups can be validated in no
      particular order. This implies that the validation routine can be run
      for several groups in the same pass.</p><p>The object validation routine is as defined in described in <a href="#constraintdeclarationvalidationprocess-validationroutine" title="4.6.&nbsp;Validation routine">Section&nbsp;4.6, &#8220;Validation routine&#8221;</a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-validationroutine-traversable"></a>4.6.3.&nbsp;Traversable property</h3></div></div><div></div></div><p>In some cases, the state of some properties should not be
      accessed. For example, if a property loaded by a Java Persistence
      provider is a lazy property or a lazy association, accessing its state
      would trigger a load from the database. An undesired behavior.</p><p>Bean Validation offers a way to control which property can and
      cannot be accessed via the
      <tt class="classname">TraversableResolver.isReachable</tt>()
      contract.</p><p>Likewise, it is sometimes undesirable to cascade validation
      despite the use of <tt class="classname">@Valid</tt>. Java Persistence 2 for
      example does not cascade to associated entities during flush. You can
      control this behavior by implementing
      <tt class="methodname">Traversable.isCascadable()</tt>.</p><pre class="programlisting">/**
 * Contract determining if a property can be accessed by the Bean Validation provider.
 * This contract is called for each property that is being either validated or cascaded.
 *
 * A traversable resolver implementation must be thread-safe.
 *
 * @author Emmanuel Bernard
 */
public interface TraversableResolver {
    /**
     * Determine if the Bean Validation provider is allowed to reach the property state
     *
     * @param traversableObject object hosting &lt;code&gt;traversableProperty&lt;/code&gt; or null
     *                          if &lt;code&gt;validateValue&lt;/code&gt; is called
     * @param traversableProperty the traversable property.
     * @param rootBeanType type of the root object passed to the Validator.
     * @param pathToTraversableObject path from the root object to
     *        &lt;code&gt;traversableObject&lt;/code&gt;
     *        (using the path specification defined by Bean Validator).
     * @param elementType either &lt;code&gt;FIELD&lt;/code&gt; or &lt;code&gt;METHOD&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the Bean Validation provider is allowed to
     *         reach the property state, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    boolean isReachable(Object traversableObject,
                        Path.Node traversableProperty,
                        Class&lt;?&gt; rootBeanType,
                        Path pathToTraversableObject,
                        ElementType elementType);

    /**
     * Determine if the Bean Validation provider is allowed to cascade validation on
     * the bean instance returned by the property value
     * marked as &lt;code&gt;@Valid&lt;/code&gt;.
     * Note that this method is called only if &lt;code&gt;isReachable&lt;/code&gt; returns true
     * for the same set of arguments and if the property is marked as &lt;code&gt;@Valid&lt;/code&gt;
     *
     * @param traversableObject object hosting &lt;code&gt;traversableProperty&lt;/code&gt; or null
     *                          if &lt;code&gt;validateValue&lt;/code&gt; is called
     * @param traversableProperty the traversable property.
     * @param rootBeanType type of the root object passed to the Validator.
     * @param pathToTraversableObject path from the root object to
     *        &lt;code&gt;traversableObject&lt;/code&gt;
     *        (using the path specification defined by Bean Validator).
     * @param elementType either &lt;code&gt;FIELD&lt;/code&gt; or &lt;code&gt;METHOD&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the Bean Validation provider is allowed to
     *         cascade validation, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    boolean isCascadable(Object traversableObject,
                         Path.Node traversableProperty,
                         Class&lt;?&gt; rootBeanType,
                         Path pathToTraversableObject,
                         ElementType elementType);
}</pre><p><tt class="methodname">isReachable</tt> is called for every property
      about to be accessed either for validation or for cascading. A property
      is <span class="emphasis"><em>reachable</em></span> if this method returns true.</p><p><tt class="methodname">isCascadable</tt> is called for every property
      about to be cascaded (i.e. marked as <tt class="classname">@Valid</tt>). A
      property is <span class="emphasis"><em>cascadable</em></span> if it is reachable and if
      the <tt class="methodname">isCascadable</tt> method returns true.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><tt class="methodname">isCascadable</tt> for a given property is
        only called if <tt class="methodname">isReachable</tt> returns true. In
        other words, <tt class="methodname">isReachable</tt> is always called
        before <tt class="methodname">isCascadable</tt> for a given
        property.</p></div><p><tt class="literal">traversableObject</tt> is the object instance being
      evaluated. <tt class="literal">null</tt> if the check is triggered as part of
      a <tt class="methodname">validateValue</tt> call.</p><p><tt class="literal">traversableProperty</tt> is the
      <tt class="classname">Node</tt> representing the property hosted by the
      <tt class="methodname">traversableObject</tt> being considered for
      traversal. The name of a property is defined in <a href="#constraintdeclarationvalidationprocess-requirements-property" title="4.1.2.&nbsp;Field and property validation">Section&nbsp;4.1.2, &#8220;Field and property validation&#8221;</a>.</p><p><tt class="literal">rootBeanType</tt> is the class of the root being
      validated (and passed to the <tt class="methodname">validate</tt>
      method).</p><p><tt class="literal">pathToTraversableObject</tt> is the
      <tt class="classname">Path</tt> from the
      <tt class="methodname">rootBeanType</tt> down to the
      <tt class="methodname">traversableObject</tt>. If the root object is
      <tt class="classname">traversableObject</tt>,
      <tt class="classname">pathToTraversableObject</tt> is composed of a single
      Node whose name is null. The path is described following the conventions
      described in <a href="#validationapi-constraintviolation" title="5.2.&nbsp;ConstraintViolation">Section&nbsp;5.2, &#8220;ConstraintViolation&#8221;</a>
      (<tt class="methodname">getPropertyPath</tt>).</p><p><tt class="literal">elementType</tt> is the
      <tt class="classname">java.lang.annotation.ElementType</tt> the annotation
      is placed on. It can be either <tt class="literal">FIELD</tt> or
      <tt class="literal">METHOD</tt>. Any other value is not expected.</p><p>The Bean Validation provider must not access the state of a
      property, nor validate its constraints if the property is not
      traversable. A property is traversable if
      <tt class="classname">TraversableResolver</tt> returns true for this
      property.</p><p>If an exception occurs when the
      <tt class="classname">TraversableResolver</tt> is called, the exception is
      wrapped into a <tt class="classname">ValidationException</tt>.</p><p>The following example assumes the object graph defined in <a href="#example-ognav-definitions" title="Example&nbsp;4.23.&nbsp;Definitions used in the example">Example&nbsp;4.23, &#8220;Definitions used in the example&#8221;</a> and assumes the validation
      operation is applied on an address object.</p><div class="example"><a name="example-ognav-definitions"></a><p class="title"><b>Example&nbsp;4.23.&nbsp;Definitions used in the example</b></p><pre class="programlisting">public class Country {
    @NotNull private String name;
    @Size(max=2) private String ISO2Code;
    @Size(max=3) private String ISO3Code;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getISO2Code() {
        return ISO2Code;
    }

    public void setISO2Code(String ISO2Code) {
        this.ISO2Code = ISO2Code;
    }

    public String getISO3Code() {
        return ISO3Code;
    }

    public void setISO3Code(String ISO3Code) {
        this.ISO3Code = ISO3Code;
    }
}

public class Address {
    @NotNull @Size(max=30)
    private String addressline1;
    @Size(max=30)
    private String addressline2;
    @Size(max=11)
    private String zipCode;
    @Valid
    private Country country;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }
}</pre></div><p>When the Bean Validation provider is about to check constraints of
      <tt class="literal">ISO3Code</tt>, it calls the
      <tt class="classname">TraversableResolver.isReachable()</tt> instance to
      ensure that the <tt class="literal">ISO3Code</tt> property is reachable with
      the following parameter values:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">traversableObject</tt>: country. The instance
          returned by <tt class="code">address.getCountry()</tt>.</p></li><li><p><tt class="literal">traversableProperty</tt>: a
          <tt class="classname">Node</tt> whose name is "ISO3Code". The name of
          the property of <tt class="literal">traversableObject</tt> being
          verified.</p></li><li><p><tt class="methodname">rootBeanType</tt>: Address.class. The type
          of the root object being validated.</p></li><li><p><tt class="literal">pathtoTraversableObject</tt>: a
          <tt class="classname">Path</tt> containing a single
          <tt class="classname">Node</tt> whose name is "country". The path from
          address to the country instance.</p></li><li><p><tt class="literal">elementType</tt>:
          <tt class="classname">ElementType.FIELD</tt>. The ISO3Code property is
          annotated on its field.</p></li></ul></div><p>When the Bean Validation provider is about to cascade validation
      on <tt class="literal">country</tt> (<tt class="classname">Address</tt> object),
      it calls the <tt class="classname">TraversableResolver.isReachable()</tt>
      instance to ensure that the <tt class="literal">country</tt> property is
      reachable and if this method returns true, it calls
      <tt class="classname">TraversableResolver.isCascadable()</tt> with the
      following parameter values:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">traversableObject</tt>: address. The address
          instance.</p></li><li><p><tt class="literal">traversableProperty</tt>: a
          <tt class="classname">Node</tt> whose name is "country". The name of the
          property of <tt class="literal">traversableObject</tt> being
          verified.</p></li><li><p><tt class="methodname">rootBeanType</tt>: Address.class. The type
          of the root object being validated.</p></li><li><p><tt class="literal">pathtoTraversableObject</tt>: a
          <tt class="classname">Path</tt> containing a single
          <tt class="classname">Node</tt> whose name is null.</p></li><li><p><tt class="literal">elementType</tt>:
          <tt class="classname">ElementType.FIELD</tt>. The country property is
          annotated on its field.</p></li></ul></div><div class="example"><a name="d0e3460"></a><p class="title"><b>Example&nbsp;4.24.&nbsp;Java Persistence aware TraversableResolver</b></p><pre class="programlisting">public class JPATraversableResolver implements TraversableResolver {

    public boolean isReachable(Object traversableObject, 
                               Path.Node traversableProperty, 
                               Class&lt;?&gt; rootBeanType, 
                               Path pathToTraversableObject, 
                               ElementType elementType) {
        return traversableObject == null ||
                Persistence.getPersistenceUtil().isLoaded( 
                        traversableObject, 
                        traversableProperty.getName() );
    }

    public boolean isCascadable(Object traversableObject, 
                               Path.Node traversableProperty, 
                               Class&lt;?&gt; rootBeanType, 
                               Path pathToTraversableObject, 
                               ElementType elementType) {
        return true;
    }
}</pre></div><p>The traversable resolver used by default in a Bean Validation
      behaves as followed:</p><div class="itemizedlist"><ul type="disc"><li><p>if Java Persistence is available in the runtime environment, a
          property is considered reachable if Java Persistence considers the
          property as loaded. A typical implementation will use
          <tt class="code">Persistence.getPersistenceUtil().isLoaded(Object,
          String)</tt> to implement such contract.</p></li><li><p>if Java Persistence is not available in the runtime
          environment, all properties are considered reachable.</p></li><li><p>all properties are considered cascadable.</p></li></ul></div><p>See <a href="#bootstrapping" title="5.5.&nbsp;Bootstrapping">Section&nbsp;5.5, &#8220;Bootstrapping&#8221;</a> to know how to pass a custom
      <tt class="classname">TraversableResolver</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typevalidatorresolution"></a>4.6.4.&nbsp;ConstraintValidator resolution algorithm</h3></div></div><div></div></div><p>A constraint is associated to one or more
      <tt class="classname">ConstraintValidator</tt> implementations. Each
      <tt class="classname">ConstraintValidator&lt;A, T&gt;</tt> accepts the type
      <tt class="classname">T</tt>. The <tt class="classname">ConstraintValidator</tt>
      executed depends on the type hosting the constraint. For a given
      constraint evaluation, a single
      <tt class="classname">ConstraintValidator</tt> is considered.</p><p>If the constraint declaration is hosted on a class or an
      interface, the targeted type is the class or the interface. If the
      constraint is hosted on a class attribute, the type of the attribute is
      the targeted type. If the constraint is hosted on a getter, the return
      type of the getter is the targeted type. In other words, the resolution
      algorithm considers the type as defined in the method signature and not
      the runtime type of the value.</p><p>The rules written below describe formally the following statement:
      the <tt class="classname">ConstraintValidator</tt> chosen to validate a
      declared type <tt class="classname">T</tt> is the one where the type
      supported by the <tt class="classname">ConstraintValidator</tt> is a
      supertype of <tt class="classname">T</tt> and where there is no other
      <tt class="classname">ConstraintValidator</tt> whose supported type is a
      supertype of <tt class="classname">T</tt> and not a supertype of the chosen
      <tt class="classname">ConstraintValidator</tt> supported type.</p><p>When validating a constraint A placed on a target declaring the
      type <tt class="classname">T</tt>, the following resolution rules
      apply:</p><div class="itemizedlist"><ul type="disc"><li><p>Primitive types are considered equivalent to their respective
          primitive wrapper class. Likewise, arrays of primitive types are
          considered equivalent to arrays of their wrapper classes.</p></li><li><p>A <tt class="classname">ConstraintValidator&lt;A, U&gt;</tt> is
          said to be <span class="emphasis"><em>compliant</em></span> with
          <tt class="classname">T</tt> if <tt class="classname">T</tt> is a subtype of
          <tt class="classname">U</tt> (according to the<a href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.10" target="_top">
          Java Language Specification 3rd edition chapter 4.10
          Subtyping</a>). Note that <tt class="classname">T</tt> is a subtype
          of <tt class="classname">U</tt> if <tt class="classname">T</tt> =
          <tt class="classname">U</tt>.</p></li><li><p>If no <tt class="classname">ConstraintValidator</tt> compliant
          with <tt class="classname">T</tt> is found amongst the
          <tt class="classname">ConstraintValidator</tt>s listed by the constraint
          <tt class="classname">A</tt>, a
          <tt class="classname">UnexpectedTypeException</tt> is raised.</p></li><li><p>A <tt class="classname">ConstraintValidator&lt;A, U&gt;</tt>
          compliant with <tt class="classname">T</tt> is considered
          <span class="emphasis"><em>strictly more specific</em></span> than a
          <tt class="classname">ConstraintValidator&lt;A, V&gt;</tt> compliant
          with <tt class="classname">T</tt> if <tt class="classname">U</tt> is a
          strict subtype of <tt class="classname">V</tt>. <tt class="classname">U</tt>
          is a strict subtype of <tt class="classname">V</tt> if
          <tt class="classname">U</tt> is a subtype of <tt class="classname">V</tt>
          and <tt class="classname">U</tt> != <tt class="classname">V</tt> (according
          to the <a href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.10" target="_top">Java
          Language Specification 3rd edition chapter 4.10
          Subtyping</a>).</p></li><li><p>A <tt class="classname">ConstraintValidator&lt;A, U&gt;</tt>
          compliant with <tt class="classname">T</tt> is considered maximally
          specific if no other <tt class="classname">ConstraintValidator&lt;A,
          V&gt;</tt> compliant with <tt class="classname">T</tt> is
          strictly more specific than <tt class="classname">ConstraintValidator&lt;A,
          U&gt;</tt>.</p></li><li><p>If more than one maximally specific
          <tt class="classname">ConstraintValidator</tt> is found, a
          <tt class="classname">UnexpectedTypeException</tt> is raised.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>While the Java compiler itself cannot determine if a constraint
        declaration will lead to a
        <tt class="classname">UnexpectedTypeException</tt>, rules can be
        statically checked. A tool such as an IDE or a Java 6 annotation
        processor can apply these rules and prevent compilation in case of
        ambiguity. The specification encourages Bean Validation providers to
        provide such a tool to their users.</p></div><p>Let's see a couple of declarations and their respective
      <tt class="classname">ConstraintValidator</tt> resolution. Assuming the
      definitions shown in <a href="#example-constraintvalidator-resolution" title="Example&nbsp;4.25.&nbsp;ConstraintValidator and type resolution">Example&nbsp;4.25, &#8220;ConstraintValidator and type resolution&#8221;</a>:</p><div class="example"><a name="example-constraintvalidator-resolution"></a><p class="title"><b>Example&nbsp;4.25.&nbsp;ConstraintValidator and type resolution</b></p><pre class="programlisting">[...]
@Constraint(validatedBy={
    SizeValidatorForCollection.class,
    SizeValidatorForSet.class,
    SizeValidatorForSerializable.class })
public @interface Size { ...}

public class SizeValidatorForCollection implements ConstraintValidator&lt;Size, Collection&gt; { ... }
public class SizeValidatorForSet implements ConstraintValidator&lt;Size, Set&gt; { ... }
public class SizeValidatorForSerializable implements ConstraintValidator&lt;Size, Serializable&gt; { ... }

public interface SerializableCollection extends Serializable,  Collection {}</pre></div><p>The resolutions shown in <a href="#table-constraintvalidator-resolution" title="Table&nbsp;4.1.&nbsp;Resolution of ConstraintValidator for various constraints&#xA;        declarations">Table&nbsp;4.1, &#8220;Resolution of ConstraintValidator for various constraints
        declarations&#8221;</a> occur.</p><div class="table"><a name="table-constraintvalidator-resolution"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;Resolution of ConstraintValidator for various constraints
        declarations</b></p><table summary="Resolution of ConstraintValidator for various constraints&#xA;        declarations" border="1"><colgroup><col align="center"><col></colgroup><thead><tr><th align="center">Declaration</th><th>Resolution</th></tr></thead><tbody><tr><td align="center"><tt class="code">@Size Collection getAddresses() { ...
              }</tt></td><td><tt class="classname">SizeValidatorForCollection</tt>: direct
              match</td></tr><tr><td align="center"><tt class="code">@Size Collection&lt;?&gt; getAddresses() { ...
              }</tt></td><td><tt class="classname">SizeValidatorForCollection</tt>:
              <tt class="classname">Collection</tt> is a direct supertype of
              <tt class="classname">Collection&lt;?&gt;</tt></td></tr><tr><td align="center"><tt class="code">@Size Collection&lt;Address&gt; getAddresses() {
              ... }</tt></td><td><tt class="classname">SizeValidatorForCollection</tt>:
              <tt class="classname">Collection</tt> is a direct supertype of
              <tt class="classname">Collection&lt;Address&gt;</tt></td></tr><tr><td align="center"><tt class="code">@Size Set&lt;Address&gt; getAddresses() { ...
              }</tt></td><td><tt class="classname">SizeValidatorForSet</tt>: direct
              supertype of <tt class="classname">Set&lt;Address&gt;</tt></td></tr><tr><td align="center"><tt class="code">@Size SortedSet&lt;Address&gt; getAddresses() { ...
              }</tt></td><td><tt class="classname">SizeValidatorForSet</tt>:
              <tt class="classname">Set</tt> is the closest supertype of
              <tt class="classname">SortedSet&lt;Address&gt;</tt></td></tr><tr><td align="center"><tt class="code">@Size SerializableCollection getAddresses() { ...
              }</tt></td><td><tt class="classname">UnexpectedTypeException</tt>:
              <tt class="classname">SerializableCollection</tt> is a subtype of
              both <tt class="classname">Collection</tt> and
              <tt class="classname">Serializable</tt> and neither
              <tt class="classname">Collection</tt> nor
              <tt class="classname">Serializable</tt> are subtypes of each
              other.</td></tr><tr><td align="center"><tt class="code">@Size String getName() { ... }</tt></td><td><tt class="classname">UnexpectedTypeException</tt>: none of
              the <tt class="classname">ConstraintValidator</tt> types are
              supertypes of <tt class="classname">String</tt>.</td></tr></tbody></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3792"></a>4.7.&nbsp;Examples</h2></div></div><div></div></div><p>The first example demonstrates how beans, fields and getters are
    annotated to express some constraints.</p><div class="example"><a name="d0e3797"></a><p class="title"><b>Example&nbsp;4.26.&nbsp;Place constraint declarations on the element to validate</b></p><pre class="programlisting">@ZipCodeCityCoherenceChecker
public class Address {
    @NotNull @Size(max=30)
    private String addressline1;

    @Size(max=30)
    private String addressline2;

    private String zipCode;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}</pre></div><p>During the validation routine execution on an
    <tt class="classname">Address</tt> object,</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">addressline1</tt> field value is passed to
        the <tt class="classname">@NotNull</tt> as well as
        <tt class="classname">@Size</tt> constraint validation
        implementation.</p></li><li><p><tt class="methodname">addressline2</tt> field value is passed to
        the <tt class="classname">@Size</tt> constraint validation
        implementation.</p></li><li><p><tt class="methodname">getCity</tt> value is passed to the
        <tt class="classname">@Size</tt> and <tt class="classname">@NotNull</tt>
        constraint validation implementations</p></li><li><p><tt class="classname">@ZipCodeCoherenceChecker</tt> is a constraint
        whose validation implementation's <tt class="methodname">isValid</tt>
        method receives the <tt class="classname">Address</tt> object</p></li></ul></div><p>The second example demonstrates object graph validation</p><div class="example"><a name="d0e3851"></a><p class="title"><b>Example&nbsp;4.27.&nbsp;Define object graph validation</b></p><pre class="programlisting">public class Country {
    @NotNull
    private String name;
    @Size(max=2) private String ISO2Code;
    @Size(max=3) private String ISO3Code;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getISO2Code() {
        return ISO2Code;
    }

    public void setISO2Code(String ISO2Code) {
        this.ISO2Code = ISO2Code;
    }

    public String getISO3Code() {
        return ISO3Code;
    }

    public void setISO3Code(String ISO3Code) {
        this.ISO3Code = ISO3Code;
    }
}

public class Address {
    @NotNull @Size(max=30)
    private String addressline1;
    @Size(max=30)
    private String addressline2;
    @Size(max=11)
    private String zipCode;
    <span class="bold"><b>@NotNull @Valid</b></span>
    private Country country;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }
}</pre></div><p>During the validation routine execution on an
    <tt class="classname">Address</tt> object, constraints on
    <tt class="methodname">addressLine1</tt>,
    <tt class="methodname">addressLine2</tt>, <tt class="methodname">zipCode</tt>,
    <tt class="classname">getCity</tt> and <tt class="methodname">country</tt> are
    processed as well as the validation of the <tt class="classname">Country</tt>
    object itself, more specifically <tt class="methodname">country.name</tt> is
    checked for <tt class="classname">@NotNull</tt>,
    <tt class="methodname">ISO2Code</tt> and <tt class="methodname">ISO3Code</tt>
    are checked for <tt class="classname">@Size</tt>.</p><p>Assuming that <tt class="classname">@NotEmpty</tt> is defined as
    such</p><pre class="programlisting">package com.acme.constraint;

@Documented
@NotNull
@Size(min=1)
@ReportAsSingleViolation
@Constraint(validatedBy = NotEmpty.NotEmptyValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface NotEmpty {
    String message() default "{com.acme.constraint.NotEmpty.message}"
    Class&lt;?&gt; groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        NotEmpty[] value();
    }    

    class NotEmptyValidator implements ConstraintValidator&lt;NotEmpty, String&gt; {
        public void initialize(NotEmpty constraintAnnotation) {}

        public boolean isValid(String value, ConstraintValidatorContext context) {
            return true;
        }
    }
}</pre><p>The third example demonstrates superclass, inheritance and composite
    constraints.</p><div class="example"><a name="d0e3906"></a><p class="title"><b>Example&nbsp;4.28.&nbsp;Use inheritance, constraints on superclasses and composite
      constraints</b></p><pre class="programlisting">public interface Person {
    @NotEmpty
    String getFirstName();

    String getMiddleName();
    
    @NotEmpty
    String getLastName();
}

public class Customer implements Person {
    private String firstName;
    private String middleName;
    private String lastName;
    @NotNull
    private String customerId;
    @Password(robustness=5)
    private String password;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getMiddleName() {
        return middleName;
    }

    public void setMiddleName(String middleName) {
        this.middleName = middleName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCustomerId() {
        return customerId;
    }

    public void setCustomerId(String customerId) {
        this.customerId = customerId;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

public class PreferredGuest extends Customer {
    @CreditCard
    private String guestCreditCardNumber;

    public String getGuestCreditCardNumber() {
        return guestCreditCardNumber;
    }

    public void setGuestCreditCardNumber(String guestCreditCardNumber) {
        this.guestCreditCardNumber = guestCreditCardNumber;
    }
}

public class CommonGuest extends customer {}</pre></div><p>When validating a <tt class="classname">PreferredGuest</tt> the
    following constraints are processed:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">@NotEmpty</tt>,
        <tt class="classname">@NotNull</tt> and
        <tt class="classname">@Size(min=1)</tt> on
        <tt class="methodname">firstName</tt></p></li><li><p><tt class="classname">@NotEmpty</tt>,
        <tt class="classname">@NotNull</tt> and
        <tt class="classname">@Size(min=1)</tt> on
        <tt class="methodname">lastName</tt></p></li><li><p><tt class="classname">@NotNull</tt> on
        <tt class="methodname">customerId</tt>, <tt class="classname">@Password</tt>
        on <tt class="methodname">password</tt></p></li><li><p><tt class="classname">@CreditCard</tt> on
        <tt class="methodname">guestCreditCardNumber</tt></p></li></ul></div><p>When validating <tt class="classname">CommonGuest</tt>, the following
    constraints are processed:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">@NotEmpty</tt>,
        <tt class="classname">@NotNull</tt> and
        <tt class="classname">@Size(min=1)</tt> on
        <tt class="methodname">firstName</tt></p></li><li><p><tt class="classname">@NotEmpty</tt>,
        <tt class="classname">@NotNull</tt> and
        <tt class="classname">@Size(min=1)</tt> on
        <tt class="methodname">lastName</tt></p></li><li><p><tt class="classname">@NotNull</tt> on
        <tt class="methodname">customerId</tt>, <tt class="classname">@Password</tt>
        on <tt class="methodname">password</tt></p></li></ul></div><p>The fourth example demonstrates the influence of group
    sequence.</p><div class="example"><a name="d0e4010"></a><p class="title"><b>Example&nbsp;4.29.&nbsp;Use groups and group sequence to define constraint
      ordering</b></p><pre class="programlisting"><span class="bold"><b>@GroupSequence({First.class, Second.class, Last.class})</b></span>
public interface Complete {}

public class Book {
    @NotEmpty(groups=First.class)
    private String title;

    @Size(max=30, groups=Second.class)
    private String subtitle;

    @Valid
    @NotNull(groups=First.class)
    private Author author;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getSubtitle() {
        return subtitle;
    }

    public void setSubtitle(String subtitle) {
        this.subtitle = subtitle;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }
}

public class Author {
    @NotEmpty(groups=Last.class)
    private String firstName;
    
    @NotEmpty(groups=First.class)
    private String lastName;

    @Size(max=30, groups=Last.class)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}</pre></div><p>Assuming the validation of the <tt class="classname">Complete</tt> group
    on the following book instance:</p><pre class="programlisting">Author author = new Author();
author.setLastName( "Baudelaire" );
author.setFirstName( "" );
Book book = new Book();
book.setAuthor( author );</pre><p>the validation routine will return the following failure:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">@NotNull</tt> failure (from
        <tt class="classname">@NotEmpty</tt>) on the <tt class="literal">title</tt>
        field</p></li></ul></div><p>As both <tt class="methodname">title</tt> and
    <tt class="methodname">author.lastname</tt> are checked as part of the
    <tt class="literal"><tt class="classname">First</tt></tt> group. If the instance is
    updated:</p><pre class="programlisting">book.setTitle( "Les fleurs du mal" );
author.setCompany("Some random publisher with a very very very long name");</pre><p>the validation routine will return the following failures:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">author.firstName</tt> fails to pass the
        <tt class="classname">@Size(min=1)</tt> (from
        <tt class="classname">@NotEmpty</tt>) constraint</p></li><li><p><tt class="methodname">author.company</tt> fails to pass the
        <tt class="classname">@Size</tt> constraint</p></li></ul></div><p>As the <tt class="classname">First</tt> and
    <tt class="classname">Second</tt> groups pass without failure, the
    <tt class="classname">Last</tt> group is going through validation.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="validationapi"></a>Chapter&nbsp;5.&nbsp;Validation APIs</h2></div></div><div></div></div><p>The default package for the Bean Validation APIs is
  <tt class="classname">javax.validation.</tt></p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validationapi-validatorapi"></a>5.1.&nbsp;Validator API</h2></div></div><div></div></div><p>The main Bean Validation API is the
    <tt class="classname">javax.validation.Validator</tt> interface.</p><p>A <tt class="classname">Validator</tt> instance is able to validate
    instances of beans and their associated objects if any. It is recommended
    to leave the caching of <tt class="classname">Validator</tt> instances to the
    <tt class="classname">ValidatorFactory</tt>. <tt class="classname">Validator</tt>
    implementations are thread-safe.</p><div class="changed"><div class="example"><a name="d0e4114"></a><p class="title"><b>Example&nbsp;5.1.&nbsp;Validator interface</b></p><pre class="programlisting">/**
 * Validates bean instances. Implementations of this interface must be thread-safe.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @author Gunnar Morling
 */
public interface Validator {
    /**
     * Validates all constraints on {@code object}.
     *
     * @param object object to validate
     * @param groups The group or list of groups targeted for validation (defaults to
     * {@link Default}).
     *
     * @return constraint violations or an empty set if none
     *
     * @throws IllegalArgumentException if object is {@code null}
     * or if {@code null} is passed to the varargs groups
     * @throws ValidationException if a non recoverable error happens
     * during the validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T object, Class&lt;?&gt;... groups);

    /**
     * Validates all constraints placed on the property of {@code object}
     * named {@code propertyName}.
     *
     * @param object object to validate
     * @param propertyName property to validate (i.e. field and getter constraints)
     * @param groups The group or list of groups targeted for validation (defaults to
     * {@link Default}).
     *
     * @return constraint violations or an empty set if none
     *
     * @throws IllegalArgumentException if {@code object} is {@code null},
     * if {@code propertyName} is {@code null}, empty or not a valid object property
     * or if {@code null} is passed to the varargs groups
     * @throws ValidationException if a non recoverable error happens
     * during the validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateProperty(T object,
                                                     String propertyName,
                                                     Class&lt;?&gt;... groups);

    /**
     * Validates all constraints placed on the property named {@code propertyName}
     * of the class {@code beanType} would the property value be {@code value}.
     * &lt;p&gt;
     * {@code ConstraintViolation} objects return {@code null} for
     * {@link ConstraintViolation#getRootBean()} and {@link ConstraintViolation#getLeafBean()}
     * &lt;/p&gt;
     *
     * @param beanType the bean type
     * @param propertyName property to validate
     * @param value property value to validate
     * @param groups The group or list of groups targeted for validation (defaults to
     * {@link Default}).
     *
     * @return constraint violations or an empty set if none
     *
     * @throws IllegalArgumentException if {@code beanType} is {@code null},
     * if {@code propertyName} is {@code null}, empty or not a valid object property
     * or if {@code null} is passed to the varargs groups
     * @throws ValidationException if a non recoverable error happens
     * during the validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue(Class&lt;T&gt; beanType,
                                                  String propertyName,
                                                  Object value,
                                                  Class&lt;?&gt;... groups);

    /**
     * Return the descriptor object describing bean constraints.
     * The returned object (and associated objects including
     * {@code ConstraintDescriptor}s) are immutable.
     *
     * @param clazz class or interface type evaluated
     *
     * @return the bean descriptor for the specified class.
     *
     * @throws IllegalArgumentException if clazz is {@code null}
     * @throws ValidationException if a non recoverable error happens
     * during the metadata discovery or if some
     * constraints are invalid.
     */
    BeanDescriptor getConstraintsForClass(Class&lt;?&gt; clazz);

    /**
     * Return an instance of the specified type allowing access to
     * provider-specific APIs. If the Bean Validation provider
     * implementation does not support the specified class,
     * {@code ValidationException} is thrown.
     *
     * @param type the class of the object to be returned.
     *
     * @return an instance of the specified class
     *
     * @throws ValidationException if the provider does not support the call.
     */
    &lt;T&gt; T unwrap(Class&lt;T&gt; type);

    /**
     * Returns a delegate for validating parameters and return values of methods
     * respectively constructors.
     *
     * @return A delegate for method validation.
     *
     * @since 1.1
     */
    MethodValidator forMethods();
}</pre></div></div><div class="added"><p>The methods
    <tt class="methodname">validate()</tt>,
    <tt class="methodname">validateProperty()</tt> and
    <tt class="methodname">validateValue()</tt> are used for the validation of
    Java beans respectively single bean properties. See the next section for
    more details.</p></div><div class="added"><p><tt class="methodname">forMethods()</tt> provides
    access to a delegate for the validation of method and constructor
    parameters respectively return values. The individual methods for method
    validation are described in <a href="#validationapi-validatorapi-methodlevelvalidationmethods" title="5.1.2.&nbsp;Methods for validating method and constructor constraints">Section&nbsp;5.1.2, &#8220;Methods for validating method and constructor constraints&#8221;</a>.</p></div><div class="added"><i><span class="remark">TODO: Do we find another term than
    "delegate"?</span></i></div><div class="changed"><p><tt class="methodname">getConstraintsForClass()</tt>
    returns constraint-related metadata for given types and is described in
    detail in <a href="#constraintmetadata" title="Chapter&nbsp;6.&nbsp;Constraint metadata request APIs">Chapter&nbsp;6, <i>Constraint metadata request APIs</i></a>.</p></div><div class="changed"><p><tt class="methodname">unwrap()</tt> is provided
    as a way to access objects of a given type specific to a Bean Validation
    provider typically as a complement to the <tt class="classname">Validator</tt>
    contract. Using this method makes your code non portable.</p></div><div class="example"><a name="d0e4151"></a><p class="title"><b>Example&nbsp;5.2.&nbsp;Using unwrap to access a provider specific contract</b></p><pre class="programlisting">//if using the ACME provider
ACMEValidator acmeValidator = factory.unwrap(ACMEValidator.class);
acmeValidator.setSpecificConfiguration(...);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="validationapi-validatorapi-validationmethods"></a>5.1.1.&nbsp;Validation methods</h3></div></div><div></div></div><p><tt class="methodname">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
      validate(T object, Class&lt;?&gt;... groups)</tt> is used to
      validate a given object. This method implements the logic described in
      <a href="#constraintdeclarationvalidationprocess-validationroutine" title="4.6.&nbsp;Validation routine">Section&nbsp;4.6, &#8220;Validation routine&#8221;</a>. A
      <tt class="classname">Set</tt> containing all
      <tt class="classname">ConstraintViolation</tt> objects representing the
      failing constraints is returned, an empty <tt class="classname">Set</tt> is
      returned otherwise.</p><p><tt class="methodname">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
      validateProperty(T object, String propertyName, Class&lt;?&gt;...
      groups)</tt> validates a given field or property of an object.
      The property name is the JavaBeans property name (as defined by the
      JavaBeans <tt class="classname">Introspector</tt> class). This method
      implements the logic described in <a href="#constraintdeclarationvalidationprocess-validationroutine" title="4.6.&nbsp;Validation routine">Section&nbsp;4.6, &#8220;Validation routine&#8221;</a> but
      only to the given property. <tt class="literal">@Valid</tt> is not honored by
      this method. This method is useful for partial object validation.</p><p><tt class="methodname">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
      validateValue(Class&lt;T&gt; beanType, String propertyName, Object
      value, Class&lt;?&gt;... groups)</tt> validates the property
      referenced by <i class="parameter"><tt>propertyName</tt></i> present on
      <tt class="literal">beanType</tt> or any of its superclasses, if the property
      value were <i class="parameter"><tt>value</tt></i>. This method implements the
      logic described in <a href="#constraintdeclarationvalidationprocess-validationroutine" title="4.6.&nbsp;Validation routine">Section&nbsp;4.6, &#8220;Validation routine&#8221;</a> and
      apply it only to the given property and for the given value.
      <tt class="literal">@Valid</tt> is not honored by this method. This method is
      useful for ahead of time validation (i.e. before the JavaBean is
      populated or updated).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If multiple constrained fields or getters share the same name
        and hide one another in the class hierarchy according to the Java
        visibility rules, the list of constraints evaluated is unspecified.
        This will be clarified in a later version of this specification. Note
        that method overriding is not impacted.</p><p>If getters and fields share the same name and are present at
        different levels of the hierarchy, the list of constraints evaluated
        is unspecified. This will be clarified in a later version of this
        specification.</p><p>However, constraints hosted on the most specific (hierarchy
        wise) element type are always evaluated.</p></div><p>If some unrecoverable failure happens during validation, a
      <tt class="classname">ValidationException</tt> is raised. This exception can
      be specialized in some situations (invalid group definition, invalid
      constraint definition, invalid constraint declaration). See <a href="#exception" title="Chapter&nbsp;9.&nbsp;Exception model">Chapter&nbsp;9, <i>Exception model</i></a> or the relative sections for more
      information).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4218"></a>5.1.1.1.&nbsp;Examples</h4></div></div><div></div></div><p>All the examples will be based on the following class
        definition, constraint declarations and address instance.</p><pre class="programlisting">public class Address {
    <span class="bold"><b>@NotNull @Size(max=30)</b></span>
    private String addressline1;

    <span class="bold"><b>@Size(max=30)</b></span>
    private String addressline2;

    private String zipCode;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    <span class="bold"><b>@Size(max=30) @NotNull</b></span>
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}

Address address = new Address();
address.setAddressline1( null );
address.setAddressline2( null );
address.setCity("Llanfairpwllgwyngyllgogerychwyrndrobwyll-llantysiliogogogoch");
//town in North Wales</pre><p>The following code will return two
        <tt class="classname">ConstraintViolation</tt> objects. One for
        <tt class="literal">addressline1</tt> violating <tt class="literal">@NotNull</tt>
        and one for <tt class="literal">city</tt> violating
        <tt class="literal">@Size</tt>.</p><pre class="programlisting">validator.validate(address).size() == 2</pre><p>The following code will return one
        <tt class="classname">ConstraintViolation</tt> since
        <tt class="literal">city</tt> violates <tt class="literal">@Size</tt> and only
        <tt class="literal">city</tt> is validated.</p><pre class="programlisting">validator.validateProperty(address, "city").size() == 1</pre><p>The following code will return no
        <tt class="classname">ConstraintViolation</tt> object because the value
        "Paris" for <tt class="literal">city</tt> would not raise any constraint
        failure.</p><pre class="programlisting">validator.validateValue("city", "Paris").size() == 0</pre></div></div><div class="added"><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="validationapi-validatorapi-methodlevelvalidationmethods"></a>5.1.2.&nbsp;Methods for validating method and constructor constraints</h3></div></div><div></div></div><p>The methods for the validation of parameters and return values of
      methods respectively constructors can be found on the interface
      <tt class="classname">javax.validation.MethodValidator</tt>.</p><div class="example"><a name="d0e4287"></a><p class="title"><b>Example&nbsp;5.3.&nbsp;MethodValidator interface</b></p><pre class="programlisting">/**
 * Validates parameters and return values of methods respectively constructors.
 * Implementations of this interface must be thread-safe.
 *
 * @author Gunnar Morling
 * @since 1.1
 */
public interface MethodValidator {

    /**
     * Validates all constraints placed on the parameters of the given method.
     *
     * @param &lt;T&gt; The type hosting the method to validate.
     * @param object The object on which the method to validate was invoked.
     * @param method The method for which the parameter constraints shall be validated.
     * @param parameterValues The values provided by the caller for the given method's
     * parameters.
     * @param groups The group or list of groups targeted for validation (defaults to
     * {@link Default}).
     *
     * @return A set with the constraint violations caused by this validation.
     *         Will be empty, if no error occurs, but never {@code null}.
     *
     * @throws ValidationException if a non recoverable error happens during the
     * validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateParameters(
        T object, Method method, Object[] parameterValues, Class&lt;?&gt;... groups);

    /**
     * Validates all return value constraints of the given method.
     *
     * @param &lt;T&gt; The type hosting the method to validate.
     * @param object The object on which the method to validate was invoked.
     * @param method The method for which the return value constraints shall be validated.
     * @param returnValue The value returned by the given method.
     * @param groups The group or list of groups targeted for validation (defaults to
     * {@link Default}).
     *
     * @return A set with the constraint violations caused by this validation.
     *         Will be empty, if no error occurs, but never {@code null}.
     *
     * @throws ValidationException if a non recoverable error happens during the
     * validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateReturnValue(
        T object, Method method, Object returnValue, Class&lt;?&gt;... groups);

    /**
     * Validates all constraints placed on the parameters of the given constructor.
     *
     * @param &lt;T&gt; The type hosting the constructor to validate.
     * @param constructor The constructor for which the parameter constraints shall be
     * validated.
     * @param parameterValues The values provided by the caller for the given constructor's
     * parameters.
     * @param groups The group or list of groups targeted for validation (defaults to
     * {@link Default}).
     *
     * @return A set with the constraint violations caused by this validation.
     *         Will be empty, if no error occurs, but never {@code null}.
     *
     * @throws ValidationException if a non recoverable error happens during the
     * validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateConstructorParameters(
        Constructor&lt;T&gt; constructor, Object[] parameterValues, Class&lt;?&gt;... groups);

    /**
     * Validates all return value constraints of the given constructor.
     *
     * @param &lt;T&gt; The type hosting the constructor to validate.
     * @param constructor The constructor for which the return value constraints shall be
     * validated.
     * @param createdObject The object instantiated by the given method.
     * @param groups The group or list of groups targeted for validation (defaults to
     * {@link Default}).
     *
     * @return A set with the constraint violations caused by this validation.
     *         Will be empty, if no error occurs, but never {@code null}.
     *
     * @throws ValidationException if a non recoverable error happens during the
     * validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateConstructorReturnValue(
        Constructor&lt;T&gt; constructor, T createdObject, Class&lt;?&gt;... groups);
}</pre></div><p><tt class="methodname">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
      validateParameters(T object, Method method, Object[] parameterValues,
      Class&lt;?&gt;... groups)</tt> validates the arguments (as given
      in <tt class="varname">parameterValues</tt>) for the parameters of a given
      method (identified by <tt class="varname">method</tt>). A set containing all
      <tt class="classname">ConstraintViolation</tt> objects representing the
      failing constraints is returned, an empty set is returned if no
      constraint violation occurred.</p><p><tt class="methodname">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
      validateReturnValue(T object, Method method, Object returnValue,
      Class&lt;?&gt;... groups)</tt> validates the return value
      (specified by <tt class="varname">returnValue</tt>) of a given method
      (identified by <tt class="varname">method</tt>). A set containing all
      <tt class="classname">ConstraintViolation</tt> objects representing the
      failing constraints is returned, an empty set is returned if no
      constraint violation occurred.</p><p><tt class="methodname">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
      validateConstructorParameters(Constructor&lt;T&gt; constructor, Object[]
      parameterValues, Class&lt;?&gt;... groups)</tt> validates the
      arguments (as given in <tt class="varname">parameterValues</tt>) for the
      parameters of a given constructor (identified by
      <tt class="varname">constructor</tt>). A set containing all
      <tt class="classname">ConstraintViolation</tt> objects representing the
      failing constraints is returned, an empty set is returned if no
      constraint violation occurred.</p><p><tt class="methodname">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
      validateConstructorReturnValue(Constructor&lt;T&gt; constructor, T
      createdObject, Class&lt;?&gt;... groups)</tt> validates the
      object (specified by <tt class="varname">createdObject</tt>) of a given
      constructor (identified by <tt class="varname">constructor</tt>). A set
      containing all <tt class="classname">ConstraintViolation</tt> objects
      representing the failing constraints is returned, an empty set is
      returned if no constraint violation occurred.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4344"></a>5.1.2.1.&nbsp;Examples</h4></div></div><div></div></div><p>All the examples will be based on the following class
        definitions, constraint declarations and instances.</p><pre class="programlisting">public class OrderService {

    @NotNull
    private CreditCardProcessor creditCardProcessor;

    @Valid
    public OrderService(@NotNull CreditCardProcessor creditCardProcessor) {
        //...
    }

    @NotNull
    public Order placeOrder(
        @NotNull @Size(min=3, max=20) String customerCode,
        @NotNull @Valid Item item,
        @Min(1) int quantity) {

        //...
    }
}

public class Item {

    @NotNull;
    private String name;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}

Item item1 = new Item();
item1.setName("Kiwi");

Item item2 = new Item();
item2.setName(null);

Constructor&lt;OrderService&gt; constructor = ... ; //get constructor object
Method&lt;OrderService&gt; placeOrder = ... ; //get method object

OrderService orderService = new OrderService(new DefaultCreditCardProcessor());

MethodValidator methodValidator = Validation
    .buildDefaultValidatorFactory().getValidator().forMethods();</pre><p>The following method parameter validation will return one
        <tt class="classname">ConstraintViolation</tt> object as the customer code
        is null:</p><pre class="programlisting">//orderService.placeOrder(null, item1, 1);
methodValidator.validateParameters(
    orderService, placeOrder, new Object[] { null, item1, 1 }).size() == 1</pre><p>The following method parameter validation will return one
        <tt class="classname">ConstraintViolation</tt> object as the
        <tt class="varname">item</tt> parameter is marked for cascaded validation
        and the given <tt class="classname">Item</tt> instance is not valid (its
        name is null):</p><pre class="programlisting">//orderService.placeOrder("CUST-123", item2, 1);
methodValidator.validateParameters(
    orderService, placeOrder, new Object[] { "CUST-123", item2, 1 }).size() == 1</pre><p>The following constructor parameter validation will return one
        <tt class="classname">ConstraintViolation</tt> object as null is passed
        for the <tt class="varname">creditCardProcessor</tt> parameter:</p><pre class="programlisting">//new OrderService(null);
methodValidator.validateConstructorParameters(constructor, new Object[] { null }).size() == 1</pre><p>Assuming the <tt class="methodname">placeOrder()</tt> method
        returned <tt class="varname">null</tt>, the following return value
        validation will return one
        <tt class="classname">ConstraintViolation</tt>:</p><pre class="programlisting">methodValidator.validateReturnValue(orderService, placeOrder, null).size() == 1</pre><p>Assuming the constructor of <tt class="classname">OrderService</tt>
        failed to store the given credit card processor into the
        <tt class="varname">creditCardProcessor</tt>, field the following validation
        of the constructor return value would fail as the constructor is
        marked with <tt class="classname">@Valid</tt> and the
        <tt class="classname">@NotNull</tt> constraint of the
        <tt class="classname">OrderService</tt> class would be violated:</p><pre class="programlisting">methodValidator.validateConstructorReturnValue(constructor, orderService).size() == 1</pre><p><i><span class="remark">Do we need more examples?</span></i></p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="validationapi-validatorapi-groups"></a>5.1.3.&nbsp;groups</h3></div></div><div></div></div><div class="changed"><p>Groups allow you to restrict the set of
      constraints applied during validation. Groups targeted are passed as
      parameters to the <tt class="methodname">validate</tt>,
      <tt class="methodname">validateProperty</tt> and
      <tt class="methodname">validateValue</tt> methods as well as the methods to
      validate method/constructor constraints (see <a href="#validationapi-validatorapi-methodlevelvalidationmethods" title="5.1.2.&nbsp;Methods for validating method and constructor constraints">Section&nbsp;5.1.2, &#8220;Methods for validating method and constructor constraints&#8221;</a>).
      All constraints belonging to the targeted group are applied during the
      <a href="#constraintdeclarationvalidationprocess-validationroutine" title="4.6.&nbsp;Validation routine">Section&nbsp;4.6, &#8220;Validation routine&#8221;</a>. If
      no group is passed, the
      <tt class="literal"><tt class="classname">Default</tt></tt> group is assumed.
      <a href="#constraintsdefinitionimplementation-constraintdefinition-groups" title="3.1.1.2.&nbsp;groups">Section&nbsp;3.1.1.2, &#8220;groups&#8221;</a>
      describes how to define groups on constraints.</p></div><p>When more than one group is evaluated and passed to the various
      validate methods, order is not constrained. It is equivalent to the
      validation of a group <tt class="literal">G</tt> inheriting all groups (i.e.
      implementing all interfaces) passed to the validation method.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4445"></a>5.1.3.1.&nbsp;Examples</h4></div></div><div></div></div><pre class="programlisting">/** Validates a minimal set of constraints */
public interface Minimal {}

public class Address {

    @NotEmpty(groups = Minimal.class)
    @Size(max=50)
    private String street1;
    
    @NotEmpty
    private String city;

    @NotEmpty(groups = {Minimal.class, Default.class})
    private String zipCode;
    ...
}</pre><p>In the previous example, <tt class="classname">@NotEmpty</tt> (and
        it's composing constraints) on <tt class="methodname">street1</tt>
        applies to the group <tt class="classname">Minimal</tt>,
        <tt class="classname">@Size</tt> on <tt class="methodname">street1</tt>
        applies to the group <tt class="literal">Default</tt> and
        <tt class="classname">@NotEmpty </tt>(and it's composing constraints) on
        <tt class="methodname">zipCode</tt> applies to the groups
        <tt class="literal"><tt class="classname">Default</tt></tt> and
        <tt class="literal"><tt class="classname">Minimal</tt></tt>.</p><pre class="programlisting">validator.validate(address);</pre><p>validates the group <tt class="classname">Default</tt> (implicitly)
        and applies <tt class="classname">@Size</tt> on
        <tt class="methodname">street1</tt>, <tt class="classname">@NotEmpty</tt>
        (and its composing constraints) on <tt class="methodname">city</tt>,
        <tt class="classname">@NotEmpty</tt> (and its composing constraints) on
        <tt class="methodname">zipCode</tt>. Particularly,
        <tt class="classname">@NotEmpty</tt> (and its composing constraints) on
        <tt class="methodname">street1</tt> are not applied.</p><pre class="programlisting">validator.validate(address, Minimal.class);</pre><p>applies <tt class="classname">@NotEmpty</tt> (and its composing
        constraints) on <tt class="methodname">street1</tt> and
        <tt class="classname">@NotEmpty</tt> (and its composing constraints) on
        <tt class="methodname">zipCode</tt> because they belong to the
        <tt class="classname">Minimal</tt> group.</p><pre class="programlisting">validator.validate(address, Minimal.class, Default.class);</pre><p>validates both <tt class="classname">Default</tt> and
        <tt class="classname">Minimal</tt> groups. The routine applies
        <tt class="classname">@NotEmpty</tt> (and its composing constraints) and
        <tt class="classname">@Size</tt> on <tt class="methodname">street1</tt>,
        <tt class="classname">@NotEmpty</tt> (and its composing constraints) on
        <tt class="methodname">city</tt>, <tt class="classname">@NotEmpty</tt> (and
        its composing constraints) on <tt class="methodname">zipCode</tt>. Note
        that if <tt class="methodname">zipCode</tt> is empty, only one
        <tt class="classname">ConstraintViolation</tt> object will represent the
        failure and the not empty validation will only be executed
        once.</p><p>Let's look at a more complex example involving group
        sequence.</p><pre class="programlisting">public class Address {
    @NotEmpty(groups = Minimal.class)
    @Size(max=50, groups=FirstStep.class)
    private String street1;
    
    @NotEmpty(groups=SecondStep.class)
    private String city;

    @NotEmpty(groups = {Minimal.class, SecondStep.class})
    private String zipCode;
    ...

    public interface FirstStep {}

    public interface SecondStep {}
    
    @GroupSequence({Firststep.class, SecondStep.class})
    public interface Total {}
}</pre><p>When running:</p><pre class="programlisting">validator.validate(address, Minimal.class, Total.class);</pre><p>the validation process will process
        <tt class="classname">@NotEmpty</tt> (and it's composing constraints) and
        <tt class="classname">@Size</tt> from <tt class="methodname">street1</tt> and
        <tt class="classname">@NotEmpty</tt> (and it's composing constraints) from
        <tt class="methodname">zipCode</tt>. If <tt class="classname">@Size</tt> from
        <tt class="methodname">street1</tt> does not generate a failure, then
        <tt class="classname">@NotEmpty</tt> (and it's composing constraints) from
        <tt class="methodname">city</tt> will be processed as part of
        <tt class="classname">SecondStep</tt>. Note that
        <tt class="classname">@NotEmpty</tt> (and it's composing constraints) from
        <tt class="methodname">zipCode</tt> are not reprocessed as they have
        already been processed before.</p><p>When running:</p><pre class="programlisting">validator.validate(address, Total.class, SecondStep.class);</pre><p><tt class="classname">@NotEmpty</tt> (and it's composing
        constraints) from <tt class="methodname">city</tt> and
        <tt class="classname">@NotEmpty</tt> (and it's composing constraints) from
        <tt class="methodname">zipCode</tt> will be processed even if
        <tt class="classname">@Size</tt> from <tt class="methodname">street1</tt>
        fails: while <tt class="literal"><tt class="classname">SecondStep</tt></tt> is
        in the <tt class="literal"><tt class="classname">Total</tt></tt> group sequence
        and hence should not be triggered if
        <tt class="literal"><tt class="classname">FirstStep</tt></tt> has a failure, it
        also has been requested outside the sequence (in this case
        explicitly).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If the group definition is invalid, a
          <tt class="classname">GroupDefinitionException</tt> is raised.</p></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validationapi-constraintviolation"></a>5.2.&nbsp;ConstraintViolation</h2></div></div><div></div></div><p><tt class="classname">ConstraintViolation</tt> is the class describing a
    single constraint failure. A set of
    <tt class="classname">ConstraintViolation</tt> is returned for an object
    validation.</p><div class="changed"><pre class="programlisting">/**
 * Describe a constraint violation. This object exposes the constraint
 * violation context as well as the message describing the violation.
 *
 * @author Emmanuel Bernard
 */
public interface ConstraintViolation&lt;T&gt; {

    /**
     * @return The interpolated error message for this constraint violation.
     */
    String getMessage();

    /**
     * @return The non-interpolated error message for this constraint violation.
     */
    String getMessageTemplate();

    /**
     * @return The root bean being validated. Null when returned by
     *         {@link javax.validation.Validator#validateValue(Class, String, Object, Class[])}
     */
    T getRootBean();

    /**
     * @return The class of the root bean being validated
     */
    Class&lt;T&gt; getRootBeanClass();

    /**
     * If a bean constraint, the bean instance the constraint is applied on
     * If a property constraint, the bean instance hosting the property the
     * constraint is applied on
     *
     * @return the leaf bean the constraint is applied on. Null when returned by
     *         {@link javax.validation.Validator#validateValue(Class, String, Object, Class[])}
     */
    Object getLeafBean();

    /**
     * @return the property path to the value from {@code rootBean}.
     */
    Path getPropertyPath();

    /**
     * Returns the value failing to pass the constraint.
     * For cross-parameter constraints, an {@code Object[]} representing
     * the method invocation arguments is returned.
     *
     * @return the value failing to pass the constraint.
     */
    Object getInvalidValue();

    /**
     * Constraint metadata reported to fail.
     * The returned instance is immutable.
     *
     * @return constraint metadata
     */
    ConstraintDescriptor&lt;?&gt; getConstraintDescriptor();
}</pre></div><p>The <tt class="methodname">getMessage</tt> method returns the
    interpolated (localized) message for the failing constraint (see <a href="#validationapi-message" title="5.3.&nbsp;Message interpolation">Section&nbsp;5.3, &#8220;Message interpolation&#8221;</a> for more information on message
    interpolator). This can be used by clients to expose user friendly
    messages.</p><p>The <tt class="methodname">getMessageTemplate</tt> method returns the
    non-interpolated error message (usually the <tt class="literal">message</tt>
    attribute on the constraint declaration). Frameworks can use this as an
    error code key.</p><p>The <tt class="methodname">getRootBean</tt> method returns the root
    object being validated that led to the failing constraint (i.e. the object
    the client code passes to the <tt class="methodname">Validator.validate</tt>
    method).</p><p>The <tt class="methodname">getInvalidValue</tt> method returns the
    value (field, property<span class="added"><span>, method/constructor
    parameter, method/constructor return value</span></span> or validated object)
    being passed to <tt class="methodname">isValid</tt>. <span class="added"><span>For a cross-parameter constraint, an
    <tt class="code">Object[]</tt> representing the method/constructor invocation
    arguments is returned.</span></span></p><p><tt class="methodname">getConstraintDescriptor</tt> provides access to
    the failing constraint metadata (see <a href="#constraintmetadata-constraintdescriptor" title="6.9.&nbsp;ConstraintDescriptor">Section&nbsp;6.9, &#8220;ConstraintDescriptor&#8221;</a>).</p><p>The <tt class="methodname">getPropertyPath</tt> returns the Path object
    representing the navigation path from the root object to the failing
    object.</p><div class="changed"><div class="example"><a name="d0e4720"></a><p class="title"><b>Example&nbsp;5.4.&nbsp;Path and Node interfaces</b></p><pre class="programlisting">/**
 * Represents the navigation path from an object to another
 * in an object graph.
 * Each path element is represented by a &lt;code&gt;Node&lt;/code&gt;.
 *
 * The path corresponds to the succession of nodes
 * in the order they are returned by the &lt;code&gt;Iterator&lt;/code&gt;
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 */
public interface Path extends Iterable&lt;Path.Node&gt; {

    /**
     * Represents an element of a navigation path.
     */
    interface Node {
        /**
         * Name of the property, constructor, method or parameter which the node
         * represents or null if representing an entity on the leaf node or the
         * return value of a constructor or method (in particular the node in a
         * &lt;code&gt;Path&lt;/code&gt; representing the root object has its name null).
         * 
         * @return Name of the property, constructor, method or parameter which
         *         the node represents
         */
        String getName();

        /**
         * @return true if the node represents an object contained in an Iterable
         * or in a Map.
         */
        boolean isInIterable();

        /**
         * @return The index the node is placed in if contained
         * in an array or List. Null otherwise.
         */
        Integer getIndex();

        /**
         * @return The key the node is placed in if contained
         * in a Map. Null otherwise.
         */
        Object getKey();

        /**
         * Returns a descriptor for the element (bean, property, method etc.)
         * represented by this node. The specific type of the element can be
         * determined using {@link ElementDescriptor#getKind()}.
         *
         * @return An element descriptor for this node.
         */
        ElementDescriptor getElementDescriptor();
    }
}</pre></div></div><p><tt class="classname">Path</tt> is made of <tt class="classname">Node</tt>s
    and is built according to the following rules:</p><div class="itemizedlist"><ul type="disc"><li><div class="added"><p>The runtime type is considered, not the static type. For example
        if a property is declared
        <tt class="classname">Collection&lt;String&gt;</tt> but its runtime type
        is <tt class="classname">ArrayList&lt;String&gt;</tt>, the property is
        considered an <tt class="classname">ArrayList&lt;String&gt;</tt>.</p></div></li><li><p>If the failing object is the root object, a
        <tt class="classname">Node</tt> with name set to null is added to the
        <tt class="classname">Path</tt>. <span class="added"><span>The
        <tt class="classname">Kind</tt> of the node's
        <tt class="classname">ElementDescriptor</tt> is
        <tt class="varname">Kind.BEAN</tt>. </span></span></p></li><li><p>When an association is traversed:</p><div class="itemizedlist"><ul type="circle"><li><p>a <tt class="classname">Node</tt> object whose
            <tt class="literal">name</tt> equals the name of the association
            property (field name or Java Bean property name) is added to
            <tt class="classname">Path</tt>. <span class="added"><span>The
            <tt class="classname">Kind</tt> of the node's
            <tt class="classname">ElementDescriptor</tt> is
            <tt class="varname">Kind.PROPERTY</tt>.</span></span></p></li><li><p>if the association is a <tt class="classname">List</tt> or an
            array, the following <tt class="classname">Node</tt> object added
            contains the index value in
            <tt class="methodname">getIndex</tt>.</p></li><li><p>if the association is a <tt class="classname">Map</tt>, the
            following <tt class="classname">Node</tt> object added (representing a
            given map entry) contains the key value in
            <tt class="methodname">getKey</tt></p></li><li><p>for all <tt class="classname">Iterable</tt> or
            <tt class="classname">Map</tt>, the following
            <tt class="classname">Node</tt> object added is marked as
            <tt class="literal">inIterable</tt>
            (<tt class="methodname">isInIterable</tt>)</p></li></ul></div></li><li><p>For a property level constraint (field and getter)</p><div class="itemizedlist"><ul type="circle"><li><p>a <tt class="classname">Node</tt> object is added to
            <tt class="classname">Path</tt> whose <tt class="literal">name</tt> equals
            the name of the property (field name or Java Bean property name).
            <span class="added"><span>The <tt class="classname">Kind</tt> of
            the node's <tt class="classname">ElementDescriptor</tt> is
            <tt class="varname">Kind.PROPERTY</tt>.</span></span></p></li><li><p>the property path is considered complete</p></li></ul></div></li><li><p>For a class level constraint:</p><div class="itemizedlist"><ul type="circle"><li><p>a <tt class="classname">Node</tt> object is added to
            <tt class="classname">Path</tt> whose <tt class="literal">name</tt> is null.
            <span class="added"><span>The <tt class="classname">Kind</tt> of
            the node's <tt class="classname">ElementDescriptor</tt> is
            <tt class="varname">Kind.BEAN</tt>.</span></span></p></li><li><p>the property path is considered complete</p></li></ul></div></li><li><div class="added"><p>For a method/constructor constraint (parameter or return value
        constraint on a method or constructor):</p><div class="itemizedlist"><ul type="circle"><li><p>a <tt class="classname">Node</tt> object is added to the
            <tt class="classname">Path</tt> which represents the validated method
            or constructor. The <tt class="literal">name</tt> of the node equals the
            validated method or constructor, the <tt class="classname">Kind</tt>
            of the node's <tt class="classname">ElementDescriptor</tt> is
            <tt class="varname">Kind.METHOD</tt> respectively
            <tt class="varname">Kind.CONSTRUCTOR</tt>.</p></li><li><p>a <tt class="classname">Node</tt> object is added to the
            <tt class="classname">Path</tt> which represents the validated
            parameter or return value. In the parameter case, the
            <tt class="literal">name</tt> of the node equals the parameter name as
            determined by the current parameter name provider (see <a href="#constraintdeclarationvalidationprocess-methodlevelconstraints-definingparameterconstraints-namingparameters" title="4.5.2.2.&nbsp;Naming parameters">Section&nbsp;4.5.2.2, &#8220;Naming parameters&#8221;</a>).
            In the return value case, the <tt class="literal">name</tt> of the node
            is null. The <tt class="classname">Kind</tt> of the node's
            <tt class="classname">ElementDescriptor</tt> is
            <tt class="varname">Kind.PARAMETER</tt> respectively
            <tt class="varname">Kind.RETURN_VALUE</tt>.</p></li><li><p>the property path is considered complete</p></li><li><i><span class="remark">TODO: Decide what to return for cross-parameter
            constraints. Maybe we could have a
            <tt class="classname">CrossParameterDescriptor</tt>/<tt class="varname">Kind.CROSS_PARAMETER</tt>?</span></i></li></ul></div></div></li><li><div class="added"><p>If a parameter or the return value of a method or constructor is
        traversed:</p><div class="itemizedlist"><ul type="circle"><li><p>a <tt class="classname">Node</tt> object is added to the
            <tt class="classname">Path</tt> which represents the concerned method
            or constructor. The <tt class="literal">name</tt> of the node equals the
            concerned method or constructor, the <tt class="classname">Kind</tt>
            of the node's <tt class="classname">ElementDescriptor</tt> is
            <tt class="varname">Kind.METHOD</tt> respectively
            <tt class="varname">Kind.CONSTRUCTOR</tt>.</p></li><li><p>a <tt class="classname">Node</tt> object is added to the
            <tt class="classname">Path</tt> which represents the traversed
            parameter or return value. In the parameter case, the
            <tt class="literal">name</tt> of the node equals the parameter name as
            determined by the current parameter name provider. In the return
            value case, the <tt class="literal">name</tt> of the node is null. The
            <tt class="classname">Kind</tt> of the node's
            <tt class="classname">ElementDescriptor</tt> is
            <tt class="varname">Kind.PARAMETER</tt> respectively
            <tt class="varname">Kind.RETURN_VALUE</tt>.</p></li><li><p>if the parameter/return value is a
            <tt class="classname">List</tt> or an array, the following
            <tt class="classname">Node</tt> object added contains the index value
            in <tt class="methodname">getIndex</tt>.</p></li><li><p>if the parameter/return value is a
            <tt class="classname">Map</tt>, the following
            <tt class="classname">Node</tt> object added (representing a given map
            entry) contains the key value
            in<tt class="methodname">getKey</tt>.</p></li><li><p>for all <tt class="classname">Iterable</tt> or
            <tt class="classname">Map</tt>, the following
            <tt class="classname">Node</tt> object added is marked as
            <tt class="literal">inIterable</tt>
            (<tt class="methodname">isInIterable</tt>)</p></li></ul></div></div></li></ul></div><div class="changed"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A given <tt class="classname">Node</tt> object derives its
      <tt class="literal">inIterable</tt>, <tt class="literal">key</tt> and
      <tt class="literal">index</tt> properties from the previous association,
      method parameter or return value traversed.</p></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>From <tt class="methodname">rootBean</tt> and
      <tt class="methodname">propertyPath</tt>, it is possible to rebuild the
      context of the failure</p></div><div class="added"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><tt class="classname">ConstraintViolation</tt>s occurred during
      standard bean validation can be distinguished from violations occurred
      during method/constructor validation by analyzing the
      <tt class="classname">Kind</tt> of the
      <tt class="classname">ElementDescriptor</tt> of the first node in the
      violation's property path. In case of method-validation, that
      <tt class="classname">Kind</tt> will be either
      <tt class="varname">CONSTRUCTOR</tt> or <tt class="varname">METHOD</tt>.</p></div></div><div class="changed"><p>Let there be the following object
    definitions:</p></div><div class="changed"><div class="example"><a name="d0e5105"></a><p class="title"><b>Example&nbsp;5.5.&nbsp;Object model definition for examples</b></p><pre class="programlisting">@SecurityChecking
public class Author {
    private String firstName;
    
    @NotEmpty(message="lastname must not be null")
    private String lastName;

    @Size(max=30)
    private String company;
    ...
}

@AvailableInStore(groups={Availability.class})
public class Book {
    @NotEmpty(groups={FirstLevelCheck.class, Default.class})
    private String title;

    @Valid
    @NotNull
    private List&lt;Author&gt; authors;

    @Valid
    private Map&lt;String, Review&gt; reviewsPerSource;

    @Valid
    private Review pickedReview;
    ...
}

public class Review {
    @Min(0) private int rating;
    ...
}

public class Library {

    public Library(@NotNull name, @NotNull location) { ... }

    public void addBook(@NotNull @Valid Book book) { ... }

    public void addAllBooks(@NotNull @Valid List&lt;Book&gt; books) { ... }

    @NotNull public String getLocation() { ... }

    @Valid public Map&lt;Author, Book&gt; getMostPopularBookPerAuthor() { ... }
}</pre></div></div><div class="changed"><p>Assuming a <tt class="classname">Book</tt>
    instance gets validated, the property paths to the different constraints
    would be as described in <a href="#table-propertypath" title="Table&nbsp;5.1.&nbsp;propertyPath examples">Table&nbsp;5.1, &#8220;propertyPath examples&#8221;</a>:</p></div><div class="table"><a name="table-propertypath"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;propertyPath examples</b></p><table summary="propertyPath examples" border="1"><colgroup><col><col></colgroup><thead><tr><th>Constraint</th><th>propertyPath</th></tr></thead><tbody><tr><td><tt class="classname">@AvailableInStore</tt> on
            <tt class="classname">Book</tt></td><td><p>Node(name=null,inIterable=false, index=null,
            key=null<span class="added"><span>,
            elementDescriptor=BeanDescriptor()</span></span>)</p></td></tr><tr><td><tt class="classname">@NotEmpty</tt> on
            <tt class="classname">Book.title</tt></td><td><p>Node(name=title,inIterable=false, index=null,
            key=null<span class="added"><span>,
            elementDescriptor=PropertyDescriptor()</span></span>)</p></td></tr><tr><td><tt class="classname">@NotNull</tt> on
            <tt class="classname">Book.authors</tt></td><td><p>Node(name=authors,inIterable=false, index=null,
            key=null<span class="added"><span>,
            elementDescriptor=PropertyDescriptor()</span></span>)</p></td></tr><tr><td><tt class="classname">@SecurityChecking</tt> on the fourth
            author, <tt class="classname">Author</tt></td><td><p>Node(name=authors,inIterable=false, index=null,
            key=null<span class="added"><span>,
            elementDescriptor=PropertyDescriptor()</span></span>)</p><p>Node(name=null,inIterable=true,
            index=3, key=null<span class="added"><span>,
            elementDescriptor=BeanDescriptor()</span></span>)</p></td></tr><tr><td><tt class="classname">@Size</tt> on the fourth author,
            <tt class="classname">Author.lastname</tt></td><td><p>Node(name=authors,inIterable=false, index=null,
            key=null<span class="added"><span>,
            elementDescriptor=PropertyDescriptor()</span></span>)</p><p>Node(name=lastname,inIterable=true,
            index=4, key=null<span class="added"><span>,
            elementDescriptor=PropertyDescriptor()</span></span>)</p></td></tr><tr><td><tt class="classname">@NotEmpty</tt> on the first author,
            <tt class="classname">Author.company</tt></td><td><p>Node(name=authors,inIterable=false, index=null,
            key=null<span class="added"><span>,
            elementDescriptor=PropertyDescriptor()</span></span>)</p><p>Node(name=company,inIterable=true,
            index=0, key=null<span class="added"><span>,
            elementDescriptor=PropertyDescriptor()</span></span>)</p></td></tr><tr><td><tt class="classname">@Min</tt> on the review associated to
            Consumer Report, <tt class="classname">Review.rating</tt></td><td><p>Node(name=reviewsPerSource,inIterable=false,
            index=null, key=null<span class="added"><span>,
            elementDescriptor=PropertyDescriptor()</span></span>)</p><p>Node(name=rating,inIterable=true,
            index=null, key="Consumer Report"<span class="added"><span>,
            elementDescriptor=PropertyDescriptor()</span></span>)</p></td></tr><tr><td><tt class="classname">@Min</tt> on the picked review,
            <tt class="classname">Review.rating</tt></td><td><p>Node(name=pickedReview,inIterable=false, index=null,
            key=null<span class="added"><span>,
            elementDescriptor=PropertyDescriptor()</span></span>)</p><p>Node(name=rating,inIterable=false,
            index=null, key=null<span class="added"><span>,
            elementDescriptor=PropertyDescriptor()</span></span>)</p></td></tr></tbody></table></div><div class="added"><p>Assuming the constructor and methods of the
    <tt class="classname">Library</tt> class are subject to method constraint
    validation, the following property paths would exist for the different
    constraints:</p></div><div class="added"><div class="table"><a name="table-method-level-propertypath"></a><p class="title"><b>Table&nbsp;5.2.&nbsp;Property path examples for constrained methods or
        constructors</b></p><table summary="Property path examples for constrained methods or&#xA;        constructors" border="1"><colgroup><col><col></colgroup><thead><tr><th>Constraint</th><th>propertyPath</th></tr></thead><tbody><tr><td><tt class="classname">@NotNull</tt> on the <tt class="varname">location
              </tt>parameter of the constructor</td><td><p>Node(name=Library, inIterable=false, index=null,
              key=null,
              elementDescriptor=ConstructorDescriptor())</p><p>Node(name=arg1,
              inIterable=false, index=null, key=null,
              elementDescriptor=ParameterDescriptor())</p></td></tr><tr><td><tt class="classname">@NotNull </tt>on the <tt class="varname">book
              </tt>parameter of the <tt class="methodname">addBook()</tt>
              method</td><td><p>Node(name=addBook, inIterable=false, index=null,
              key=null,
              elementDescriptor=MethodDescriptor())</p><p>Node(name=arg0,
              inIterable=false, index=null, key=null,
              elementDescriptor=ParameterDescriptor())</p></td></tr><tr><td><tt class="classname">@NotEmpty</tt> on
              <tt class="classname">Book.title</tt> during validation of
              <tt class="methodname">addBook()</tt></td><td><p>Node(name=addBook, inIterable=false, index=null,
              key=null,
              elementDescriptor=MethodDescriptor())</p><p>Node(name=arg0,
              inIterable=false, index=null, key=null,
              elementDescriptor=ParameterDescriptor())</p><p>Node(name=title,
              inIterable=false, index=null, key=null,
              elementDescriptor=PropertyDescriptor())</p></td></tr><tr><td><tt class="classname">@NotEmpty</tt> on fourth book,
              <tt class="classname">Book.title</tt> during validation of
              <tt class="methodname">addAllBooks()</tt></td><td><p>Node(name=addAllBooks, inIterable=false,
              index=null, key=null,
              elementDescriptor=MethodDescriptor())</p><p>Node(name=arg0,
              inIterable=false, index=null, key=null,
              elementDescriptor=ParameterDescriptor())</p><p>Node(name=title,inIterable=true,
              index=3, key=null,
              elementDescriptor=PropertyDescriptor())</p></td></tr><tr><td><tt class="classname">@NotNull</tt> on the return value of
              the <tt class="methodname">getLocation()</tt> method</td><td><p>Node(name=getLocation, inIterable=false,
              index=null, key=null,
              elementDescriptor=MethodDescriptor())</p><p>Node(name=null,
              inIterable=false, index=null, key=null,
              elementDescriptor=ReturnValueDescriptor())</p></td></tr><tr><td><tt class="classname">@NotEmpty</tt> on most popular book of
              author "John Doe", <tt class="classname">Book.title</tt> during
              validation of
              <tt class="methodname">getMostPopularBookPerAuthor()</tt></td><td><p>Node(name=getMostPopularBookPerAuthor,
              inIterable=false, index=null, key=null,
              elementDescriptor=MethodDescriptor())</p><p>Node(name=null,
              inIterable=false, index=null, key=null,
              elementDescriptor=ReturnValueDescriptor())</p><p>Node(name=title,inIterable=true,
              index=null, key=Author(firstName=John, lastName=Doe),
              elementDescriptor=PropertyDescriptor())</p></td></tr></tbody></table></div></div><p><i><span class="remark">TODO: Add paths for cross-parameter
    constraints.</span></i></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Bean Validation implementations should ensure that a
      <tt class="classname">ConstraintViolation</tt> implementation is
      <tt class="classname">Serializable</tt> provided that the root bean, the
      leaf bean, the invalid value and keys in the <tt class="classname">Path</tt>
      object are <tt class="classname">Serializable</tt> objects.</p><p>If a user wishes to send
      <tt class="classname">ConstraintViolation</tt> remotely, it should make sure
      the object graph validated is itself
      <tt class="classname">Serializable</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5392"></a>5.2.1.&nbsp;Examples</h3></div></div><div></div></div><p>These examples assume the following definition of
      <tt class="classname">@NotEmpty</tt>.</p><pre class="programlisting">package com.acme.constraint;

@Documented
@NotNull
@Size(min=1)
@ReportAsSingleViolation
@Constraint(validatedBy = NotEmpty.NotEmptyValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface NotEmpty {
    String message() default "{com.acme.constraint.NotEmpty.message}"
    Class&lt;?&gt; groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        NotEmpty[] value();
    }

    class NotEmptyValidator implements ConstraintValidator&lt;NotEmpty, String&gt; {
        public void initialize(NotEmpty constraintAnnotation) {}

        public boolean isValid(String value, ConstraintValidatorContext context) {
            return true;
        }
    }
}</pre><p>and the following class definitions</p><pre class="programlisting">public class Author {
    private String firstName;
    
    @NotEmpty(message="lastname must not be null")
    private String lastName;

    @Size(max=30)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}

public class Book {
    @NotEmpty(groups={FirstLevelCheck.class, Default.class})
    private String title;

    @Valid
    @NotNull
    private Author author;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }
}

Author author = new Author();
author.setCompany("ACME");
Book book = new Book();
book.setTitle("");
book.setAuthor(author);

Set&lt;ConstraintViolation&gt; constraintViolations = validator.validate(book);</pre><p><tt class="classname">ConstraintViolations</tt> is a set of size 2.
      One of the entries represents the failure of
      <tt class="literal">@NotEmpty</tt> (or more precisely
      <tt class="classname">@Size(min=1)</tt> a composing constraint of
      <tt class="classname">@NotEmpty</tt>) on the <tt class="literal">title</tt>
      property.</p><p>The <tt class="classname">ConstraintViolation</tt> object for this
      failure passes the following assertions:</p><div class="changed"><div class="example"><a name="d0e5427"></a><p class="title"><b>Example&nbsp;5.6.&nbsp;Test assertions on ContraintViolation</b></p><pre class="programlisting">//assuming an english locale, the interpolated message is returned
assert "may not be null or empty".equals( constraintViolation.getMessage() );
assert book == constraintViolation.getRootBean();
assert book == constraintViolation.getLeafBean();

//the offending value
assert book.getTitle().equals( constraintViolation.getInvalidValue() );

//the offending property
Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();
Node node = nodeIter.next();
assert "title".equals( node.getName() );
assert Kind.PROPERTY.equals( node.getElementDescriptor().getKind() );

assert false == nodeIter.hasNext();</pre></div></div><p>The second failure, <tt class="literal">@NotEmpty</tt> (or more
      precisely <tt class="classname">@NotNull</tt> a composing constraint of
      <tt class="classname">@NotEmpty</tt>) on the author's
      <tt class="methodname">lastname</tt>, will produce the
      <tt class="classname">ConstraintViolation</tt> object satisfying the
      following assertions:</p><pre class="programlisting">assert "lastname must not be null".equals( constraintViolation.getMessage() );
assert book == constraintViolation.getRootBean();
assert author == constraintViolation.getLeafBean();

//the offending value
assert book.getAuthor().getLastName() == constraintViolation.getInvalidValue();

//the offending property
Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "author".equals( node.getName() );
assert Kind.PROPERTY.equals( node.getElementDescriptor().getKind() );

node = nodeIter.next();
assert "lastName".equals( node.getName() );
assert Kind.PROPERTY.equals( node.getElementDescriptor().getKind() );

assert false == nodeIter.hasNext();</pre></div><div class="added"><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5451"></a>5.2.2.&nbsp;Examples for method/constructor constraint violations</h3></div></div><div></div></div><i><span class="remark">TODO: Add examples for cross-parameter constraints. Do we need
      any more examples here?</span></i><p>The following examples assume the constraint, class and object
      definitions given in the previous section. Additionally the following
      class and object definitions are assumed:</p><pre class="programlisting">public class Library {

    public void addBook(@NotNull @Valid Book book) { ... }

    @Valid public Map&lt;Author, Book&gt; getMostPopularBookPerAuthor() { ... }
}

Library library = new Library();
author.setLastName("Doe");</pre><p>Assuming the following invocation of
      <tt class="methodname">addBook()</tt> is subject to method constraint
      validation:</p><pre class="programlisting">library.addBook(null);</pre><p>Then one <tt class="classname">ConstraintViolation</tt> object would
      be returned by
      <tt class="methodname">MethodValidator#validateParameters()</tt> which
      satisfies the following assertions:</p><pre class="programlisting">//assuming an english locale, the interpolated message is returned
assert "may not be null".equals( constraintViolation.getMessage() );
assert library == constraintViolation.getRootBean();
assert library == constraintViolation.getLeafBean();

assert null == constraintViolation.getInvalidValue();

Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "addBook".equals( node.getName() );
assert Kind.METHOD.equals( node.getElementDescriptor().getKind() );

node = nodeIter.next();
//assuming the default parameter name provider is used
assert "arg0".equals( node.getName() );
assert Kind.PARAMETER.equals( node.getElementDescriptor().getKind() );

assert false == nodeIter.hasNext();</pre><p>Assuming the following invocation of
      <tt class="methodname">addBook()</tt> is subject to method constraint
      validation:</p><pre class="programlisting">library.addBook(book);</pre><p>Then one <tt class="classname">ConstraintViolation</tt> object would
      be returned by
      <tt class="methodname">MethodValidator#validateParameters()</tt> which
      satisfies the following assertions:</p><pre class="programlisting">//assuming an english locale, the interpolated message is returned
assert "may not be null or empty".equals( constraintViolation.getMessage() );
assert library == constraintViolation.getRootBean();
assert book == constraintViolation.getLeafBean();

assert book.getTitle().equals( constraintViolation.getInvalidValue() );

Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "addBook".equals( node.getName() );
assert Kind.METHOD.equals( node.getElementDescriptor().getKind() );

node = nodeIter.next();
//assuming the default parameter name provider is used
assert "arg0".equals( node.getName() );
assert Kind.PARAMETER.equals( node.getElementDescriptor().getKind() );

node = nodeIter.next();
assert "title".equals( node.getName() );
assert Kind.PROPERTY.equals( node.getElementDescriptor().getKind() );

assert false == nodeIter.hasNext();</pre><p>Assuming the following invocation of
      <tt class="methodname">getMostPopularBookPerAuthor()</tt> is subject to
      method constraint validation and returns a <tt class="classname">Map</tt>
      containing one entry with key <tt class="varname">author</tt> and value
      <tt class="varname">book</tt>:</p><pre class="programlisting">Map&lt;Author, Book&gt; mostPopularBookPerAuthor = library.getMostPopularBookPerAuthor();</pre><p>Then one <tt class="classname">ConstraintViolation</tt> object would
      be returned by
      <tt class="methodname">MethodValidator#validateReturnValue()</tt> which
      satisfies the following assertions:</p><pre class="programlisting">//assuming an english locale, the interpolated message is returned
assert "may not be null or empty".equals( constraintViolation.getMessage() );
assert library == constraintViolation.getRootBean();
assert book == constraintViolation.getLeafBean();

assert book.getTitle().equals( constraintViolation.getInvalidValue() );

Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();

Node node = nodeIter.next();
assert "getMostPopularBookPerAuthor".equals( node.getName() );
assert Kind.METHOD.equals( node.getElementDescriptor().getKind() );

node = nodeIter.next();
assert null == node.getName();
assert Kind.RETURN_VALUE.equals( node.getElementDescriptor().getKind() );

node = nodeIter.next();
assert "title".equals( node.getName() );
assert Kind.PROPERTY.equals( node.getElementDescriptor().getKind() );
assert author.equals( node.getKey() );
assert true == node.isInIterable();

assert false == nodeIter.hasNext();</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validationapi-message"></a>5.3.&nbsp;Message interpolation</h2></div></div><div></div></div><p>A message interpolator is responsible for transforming the message
    string from the constraint into a human readable error message.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="default-messageresolver"></a>5.3.1.&nbsp;Default message interpolation</h3></div></div><div></div></div><p>A conforming implementation includes a default message
      interpolator. This message interpolator shall use the algorithm defined
      here to interpolate message descriptors into human-readable
      messages.</p><p>Each constraint defines a message descriptor via its
      <tt class="methodname">message</tt> property. Every constraint definition
      shall define a default message descriptor for that constraint. Messages
      can be overridden at declaration time in constraints by setting the
      <tt class="methodname">message</tt> property on the constraint.</p><p>The message descriptor is a string literal and may contain one or
      more message parameters. Message parameters are string literals enclosed
      in braces. The following character escaping apply:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="code">\{</tt> is considered as the literal
          <tt class="literal">{</tt> instead of being considered as the beginning of
          a message parameter</p></li><li><p><tt class="code">\}</tt> is considered as the literal
          <tt class="literal">}</tt> instead of being considered as the end of a
          message parameter</p></li><li><p><tt class="code">\\</tt> is considered as the literal
          <tt class="literal">\</tt> instead of being considered as the escaping
          character</p></li></ul></div><div class="example"><a name="d0e5565"></a><p class="title"><b>Example&nbsp;5.7.&nbsp;Message using parameters</b></p><pre class="programlisting">Value must be between {min} and {max}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="default-resolution-algorithm"></a>5.3.1.1.&nbsp;Default message interpolation algorithm</h4></div></div><div></div></div><p>The default message interpolator uses the following
        steps:</p><div class="orderedlist"><ol type="1"><li><p>Message parameters are extracted from the message string and
            used as keys to search the <tt class="classname">ResourceBundle</tt>
            named <tt class="literal">ValidationMessages</tt> (often materialized as
            the property file
            <tt class="filename">/ValidationMessages.properties</tt> and its locale
            variations) using the defined locale (see below). If a property is
            found, the message parameter is replaced with the property value
            in the message string. Step 1 is applied recursively until no
            replacement is performed (i.e. a message parameter value can
            itself contain a message parameter).</p></li><li><p>Message parameters are extracted from the message string and
            used as keys to search the Bean Validation provider's built-in
            <tt class="classname">ResourceBundle</tt> using the defined locale
            (see below). If a property is found, the message parameter is
            replaced with the property value in the message string. Contrary
            to step 1, step 2 is not processed recursively.</p></li><li><p>If step 2 triggers a replacement, then step 1 is applied
            again. Otherwise step 4 is performed.</p></li><li><p>Message parameters are extracted from the message string.
            Those matching the name of an attribute of the constraint are
            replaced by the value of that attribute in the constraint
            declaration.</p></li></ol></div><p>The defined locale is as followed:</p><div class="itemizedlist"><ul type="disc"><li><p>if the locale is passed to the interpolator method
            i<tt class="methodname">nterpolate(String, Context, Locale)</tt>,
            this <tt class="classname">Locale</tt> instance is used.</p></li><li><p>otherwise, the default <tt class="classname">Locale</tt> as
            provided by <tt class="methodname">Locale.getDefault()</tt> is
            used.</p></li></ul></div><p>The proposed algorithm ensures that custom resource bundle
        always have priority over built-in resource bundle at all level of the
        recursive resolution. It also ensures that constraint declarations
        attributes values are not interpolated further.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-message-resolution"></a>5.3.2.&nbsp;Custom message interpolation</h3></div></div><div></div></div><p>A custom message interpolator may be provided (e.g., to
      interpolate contextual data, or to adjust the default <tt class="classname">Locale
      </tt>used). A message interpolator implements the
      <tt class="classname">MessageInterpolator</tt> interface.</p><pre class="programlisting">/**
 * Interpolate a given constraint violation message.
 * Implementations should be as tolerant as possible on syntax errors.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface MessageInterpolator {
    /**
     * Interpolate the message template based on the contraint validation context.
     * The locale is defaulted according to the &lt;code&gt;MessageInterpolator&lt;/code&gt;
     * implementation. See the implementation documentation for more detail.
     *
     * @param messageTemplate The message to interpolate.
     * @param context contextual information related to the interpolation
     *
     * @return Interpolated error message.
     */
    String interpolate(String messageTemplate, Context context);

    /**
     * Interpolate the message template based on the contraint validation context.
     * The &lt;code&gt;Locale&lt;/code&gt; used is provided as a parameter.
     *
     * @param messageTemplate The message to interpolate.
     * @param context contextual information related to the interpolation
     * @param locale the locale targeted for the message
     *
     * @return Interpolated error message.
     */
    String interpolate(String messageTemplate, Context context,  Locale locale);

    /**
     * Information related to the interpolation context
     */
    interface Context {
        /**
         * @return ConstraintDescriptor corresponding to the constraint being validated
         */
        ConstraintDescriptor&lt;?&gt; getConstraintDescriptor();

        /**
         * @return value being validated
         */
        Object getValidatedValue();
    }
}</pre><p><i class="parameter"><tt>messageTemplate</tt></i> is the value of the
      <tt class="literal">message</tt> attribute of the constraint declaration or
      provided to the <tt class="classname">ConstraintValidatorContext</tt>
      methods.</p><p>The <tt class="classname">Context</tt> object contains contextual
      information related to the interpolation.</p><p><i class="parameter"><tt>getConstraintDescriptor</tt></i> is the
      <tt class="classname">ConstraintDescriptor</tt> object representing the
      metadata of the failing constraint (see <a href="#constraintmetadata" title="Chapter&nbsp;6.&nbsp;Constraint metadata request APIs">Chapter&nbsp;6, <i>Constraint metadata request APIs</i></a>).</p><p><i class="parameter"><tt>getValidatedValue</tt></i> is the value being
      validated.</p><p><tt class="methodname">MessageInterpolator.interpolate(String,
      Context)</tt> is invoked for each constraint violation report
      generated. The default <tt class="classname">Locale</tt> is implementation
      specific.</p><p><tt class="methodname">MessageInterpolator.interpolate(String, Context,
      Locale)</tt> can be invoked by a wrapping
      <tt class="classname">MessageInterpolator</tt> to enforce a specific
      <tt class="classname">Locale</tt> value by bypassing or overriding the
      default <tt class="classname">Locale</tt> strategy (see <a href="#validationapi-message-examples-specificlocale" title="Example&nbsp;5.8.&nbsp;Use MessageInterpolator to use a specific Locale value">Example&nbsp;5.8, &#8220;Use MessageInterpolator to use a specific Locale value&#8221;</a>).</p><p>A message interpolator implementation shall be thread-safe.</p><p>The message interpolator is provided to the
      <tt class="classname">ValidatorFactory</tt> at construction time using
      <tt class="methodname">Configuration.messageInterpolator(MessageInterpolator)</tt>.
      This message interpolator is shared by all
      <tt class="classname">Validator</tt> objects generated by this
      <tt class="classname">ValidatorFactory</tt>.</p><p>It is possible to override the
      <tt class="classname">MessageInterpolator</tt> implementation for a given
      <tt class="classname">Validator</tt> instance by invoking
      <tt class="methodname">ValidatorFactory.usingContext().messageInterpolator(messageInterpolator).getValidator()</tt>.</p><p>It is recommended that <tt class="classname">MessageInterpolator</tt>
      implementations delegate final interpolation to the Bean Validation
      default <tt class="classname">MessageInterpolator</tt> to ensure standard
      Bean Validation interpolation rules are followed, The default
      implementation is accessible through
      <tt class="methodname">Configuration.getDefaultMessageInterpolator()</tt>.</p><p>If the interpolation process leads to an exception, the exception
      is wrapped into a <tt class="classname">ValidationException</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="validationapi-message-examples"></a>5.3.3.&nbsp;Examples</h3></div></div><div></div></div><p>These examples describe message interpolation based on the default
      message interpolator's built-in messages (see <a href="#standard-resolver-messages" title="Appendix&nbsp;B.&nbsp;Standard ResourceBundle messages">Appendix&nbsp;B, <i>Standard ResourceBundle messages</i></a>), and the
      <tt class="filename">ValidationMessages.properties</tt> file shown in table
      <a href="#table-messageinterpolation" title="Table&nbsp;5.3.&nbsp;message interpolation">Table&nbsp;5.3, &#8220;message interpolation&#8221;</a>. The current locale is
      assumed English.</p><pre class="programlisting">//ValidationMessages.properties
myapp.creditcard.error=credit card number not valid</pre><div class="table"><a name="table-messageinterpolation"></a><p class="title"><b>Table&nbsp;5.3.&nbsp;message interpolation</b></p><table summary="message interpolation" border="1"><colgroup><col align="center"><col></colgroup><tbody><tr><td align="center">Failing constraint declaration</td><td>interpolated message</td></tr><tr><td align="center"><tt class="classname">@NotNull</tt></td><td>must not be null</td></tr><tr><td align="center"><tt class="classname">@Max(30)</tt></td><td>must be less than or equal to 30</td></tr><tr><td align="center"><tt class="classname">@Size(min=5, max=15, message="Key must have
              \\{{min}\\} \\ \\{{max}\\} characters")</tt></td><td>Key must have {5} \ {15} characters</td></tr><tr><td align="center"><tt class="classname">@Digits(integer=9,
              fraction=2)</tt></td><td>numeric value out of bounds (&lt;9 digits&gt;.&lt;2
              digits&gt; expected)</td></tr><tr><td align="center"><tt class="classname">@CreditCard(message={myapp.creditcard.error})</tt></td><td>credit card number not valid</td></tr></tbody></table></div><p>Here is an approach to specify the <tt class="classname">Locale</tt>
      value to choose on a given <tt class="classname">Validator</tt>.
      <tt class="classname">Locale</tt> aware
      <tt class="classname">MessageInterpolator</tt>. See <a href="#bootstrapping" title="5.5.&nbsp;Bootstrapping">Section&nbsp;5.5, &#8220;Bootstrapping&#8221;</a> for more details on the APIs.</p><div class="example"><a name="validationapi-message-examples-specificlocale"></a><p class="title"><b>Example&nbsp;5.8.&nbsp;Use MessageInterpolator to use a specific Locale value</b></p><pre class="programlisting">/**
 * delegates to a MessageInterpolator implementation but enforce a given Locale
 */
public class LocaleSpecificMessageInterpolator implements MessageInterpolator {
    private final MessageInterpolator defaultInterpolator;
    private final Locale defaultLocale;

    public LocaleSpecificMessageInterpolator(MessageInterpolator interpolator, Locale locale) {
        this.defaultLocale = locale;
        this.defaultInterpolator = interpolator;
    }

    /**
     * enforece the locale passed to the interpolator
     */
    public String interpolate(String message, 
                              Context context) {
        return defaultInterpolator.interpolate(message, 
                                               context, 
                                               this.defaultLocale);
    }

    // no real use, implemented for completeness
    public String interpolate(String message,
                              Context context,
                              Locale locale) {
        return defaultInterpolator.interpolate(message, context, locale);
    }
}


Locale locale = getMyCurrentLocale();
MessageInterpolator interpolator = new LocaleSpecificMessageInterpolator(
                                       validatorFactory.getMessageInterpolator(),
                                       locale);

Validator validator = validatorFactory.usingContext()
                                      .messageInterpolator(interpolator)
                                      .getValidator();</pre></div><p>Most of the time, however, the relevant
      <tt class="classname">Locale</tt> will be provided by your application
      framework transparently. This framework will implement its own version
      of <tt class="classname">MessageInterpolator</tt> and pass it during the
      <tt class="classname">ValidatorFactory</tt> configuration. The application
      will not have to set the <tt class="classname">Locale</tt> itself. This
      example shows how a container framework would implement
      <tt class="classname">MessageInterpolator</tt> to provide a user specific
      default locale.</p><div class="example"><a name="validationapi-message-examples-jsflocale"></a><p class="title"><b>Example&nbsp;5.9.&nbsp;Contextual container possible
        <tt class="classname">MessageInterpolator</tt> implementation</b></p><pre class="programlisting">public class ContextualMessageInterpolator implements MessageInterpolator {
    private final MessageInterpolator delegate;

    public ContextualMessageInterpolator(MessageInterpolator delegate) { 
        this.delegate = delegate; 
    }

    public String interpolate(String message, Context context) {
        Locale locale = Container.getManager().getUserLocale();
        return this.delegate.interpolate(
                        message, context, locale );
    }

    public String interpolate(String message, Context context, Locale locale) {
        return this.delegate.interpolate(message, context, locale);
    }
}


//Build the ValidatorFactory
Configuration&lt;?&gt; configuration = Validation.byDefaultProvider().configure();
ValidatorFactory factory = configuration
    .messageInterpolator( 
        new ContextualMessageInterpolator( 
                configuration.getDefaultMessageInterpolator() ) )
    .buildValidatorFactory();

//The container uses the factory to validate constraints using the specific MessageInterpolator
Validator validator = factory.getValidator();</pre></div></div></div><div class="added"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validationapi-triggeringmethodvalidation"></a>5.4.&nbsp;Triggering method validation</h2></div></div><div></div></div><p>Bean Validation itself doesn't trigger the evaluation of method
    constraints. That is, just annotating any methods or constructors with
    parameter or return value constraints doesn't automatically enforce these
    constraints, just as annotating any fields or properties with bean
    constraints doesn't enforce these either.</p><p>Instead method constraints must be validated by invoking the
    appropriate methods on
    <tt class="classname">javax.validation.MethodValidator</tt>. Typically this
    won't happen by manually calling these methods but rather automatically
    upon invocation of the constrained methods or constructors, using
    approaches and techniques such as CDI/EJB interceptors, aspect-oriented
    programming or dynamic proxies.</p><p>The validation of method / constructor constraints comprises the
    following steps:</p><div class="itemizedlist"><ul type="disc"><li><p>Intercept the method call to be validated</p></li><li><p>Validate the parameter values provided by the method caller
        using <tt class="methodname">MethodValidator#validateParameters()</tt> or
        <tt class="methodname">MethodValidator#validateConstructorParameters()</tt>.</p></li><li><p>If this validation yields a non-empty set of constraint
        violations, throw a
        <tt class="classname">ConstraintViolationException</tt> wrapping the
        violations. Otherwise proceed with the actual method
        invocation.</p></li><li><p>Validate the result returned by the invoked method using
        <tt class="methodname">MethodValidator#validateReturnValue()</tt> or
        <tt class="methodname">MethodValidator#validateConstructorReturnValue()</tt>.</p></li><li><p>If this validation yields a non-empty set of constraint
        violations, throw a
        <tt class="classname">ConstraintViolationException</tt> wrapping the
        violations. Otherwise return the invocation result to the method
        caller.</p></li></ul></div><p>By throwing a <tt class="classname">ConstraintViolationException</tt> if
    either of the validation steps fails, it is ensured that the control
    flow</p><div class="itemizedlist"><ul type="disc"><li><p>only arrives at the method's body if the caller has satisfied
        the method's preconditions and</p></li><li><p>only returns to the method caller if the method's postconditions
        are guaranteed.</p></li></ul></div><p>By default, integrators should intercept and validate all methods
    hosting either a constraint or cascading constraint violation
    (<tt class="classname">@Valid</tt>) whether it be on the method itself or on
    any of its parameters. The <tt class="classname">Default</tt> group should be
    used for validation out of the box.</p><p>Integrators are encouraged to use Bean Validation's metadata API to
    find whether or not a method or a constructor should be intercepted. This
    guarantees that XML descriptors as well as future mapping strategies are
    taken into account. Here is an example of what such usage would be:</p><div class="example"><a name="d0e5898"></a><p class="title"><b>Example&nbsp;5.10.&nbsp;Using metadata API to figure out if method interception is
      required</b></p><pre class="programlisting">//For methods

// is there any constrained method on this type
public boolean interceptMethods(Class&lt;?&gt; type) {
    return validator.getConstraintsForClass( type ).getConstrainedMethods().size() &gt; 0;
}

// is this method constrained
public boolean interceptMethod(Class&lt;?&gt; type, Method method) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod(
        method.getName(), method.getParameterTypes() );
    return methodDescriptor != null;
}

// should method parameters be validated
public boolean requiresParametersValidation(Class&lt;?&gt; type, Method method) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod(
        method.getName(), method.getParameterTypes() );
    if ( methodDescriptor != null ) {
        return methodDescriptor.areParametersConstrained();
    }
    else {
        return false;
    }
}

// should method return value be validated?
public boolean requiresReturnValueValidation(Class&lt;?&gt; type, Method method) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod(
        method.getName(), method.getParameterTypes() );
    if ( methodDescriptor != null ) {
        return methodDescriptor.isReturnValueConstrained();
    }
    else {
        return false;
    }
}</pre></div><div class="example"><a name="d0e5903"></a><p class="title"><b>Example&nbsp;5.11.&nbsp;Using metadata API to figure out if constructor interception is
      required</b></p><pre class="programlisting">//For constructors

// is there any constrained constructor on this type
public &lt;T&gt; boolean interceptConstructors(Class&lt;T&gt; type) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    return bean.getConstrainedConstructors().size() &gt; 0;
}

// is this constructor constrained
public &lt;T&gt; boolean interceptConstructor(Class&lt;T&gt; type, Constructor&lt;T&gt; ctor) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    ConstructorDescriptor constructorDescriptor = bean.getConstraintsForConstructor(
        ctor.getParameterTypes() );
    return constructorDescriptor != null;
}

// should constructor parameters be validated
public &lt;T&gt; boolean requiresParametersValidation(Class&lt;T&gt; type, Constructor&lt;T&gt; ctor) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    ConstructorDescriptor constructorDescriptor = bean.getConstraintsForConstructor(
        ctor.getParameterTypes() );
    if ( constructorDescriptor != null ) {
        return constructorDescriptor.areParametersConstrained();
    }
    else {
        return false;
    }
}

// should constructor return value be validated?
public boolean requiresReturnValueValidation(Class&lt;?&gt; type, Constructor&lt;T&gt; ctor) {
    BeanDescriptor bean = validator.getConstraintsForClass( type );
    ConstructorDescriptor constructorDescriptor = bean.getConstraintsForConstructor(
        ctor.getName(), 
        ctor.getParameterTypes()
    );
    if ( constructorDescriptor != null ) {
        return constructorDescriptor.isReturnValueConstrained();
    }
    else {
        return false;
    }
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Calls to the metadata API is likely only going to be needed during
      the initialization phase of the interception framework. Results can then
      be cached.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Only methods or constructors intercepted by the underlying
      interception technology can be validated.</p></div><p>The integration technology must put the validation interceptor as
    late as possible (if not last) in the interception stack. In particular,
    validation of parameters should be done after the security and transaction
    start logic. Likewise, return value validation should be done before the
    transaction stop logic. Putting the validation interceptor as late as
    possible in the stack ensures this.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Why have the validation interceptor after other
      interceptors?</h3><p>There are several reasons for delaying validation compared to
      other interceptors:</p><div class="itemizedlist"><ul type="disc"><li><p>You don't want to start business code before security has been
          cleared</p></li><li><p>You might need transaction support in your validations</p></li><li><p>You want transaction to fail if the return value is
          invalid</p></li><li><p>Generally speaking, it makes more sense to apply technical
          layers around the more business focused constraints</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5934"></a>5.4.1.&nbsp;PROPOSAL: customizing method interception</h3></div></div><div></div></div><p>By default, all constrained methods (that can be intercepted) are
      validated using the default group.</p><p>You can customize whether or not a method is validated and which
      group is used via the <tt class="classname">MethodValidationActivator</tt>
      and <tt class="classname">MethodValidationGroupSelector</tt> contracts and
      providing implementations to the Bean Validation bootstrap or via the
      XML deployment descriptor.</p><div class="example"><a name="d0e5947"></a><p class="title"><b>Example&nbsp;5.12.&nbsp;MethodValidationActivator contract</b></p><pre class="programlisting">/**
 * Decides if constraints of a given method should be validated
 * 
 * @author Emmanuel Bernard
 */
interface MethodValidationActivator {
    boolean activateMethodValidation(Method method):
    boolean activateConstructorValidation(Constructor constructor);
}</pre></div><div class="example"><a name="d0e5952"></a><p class="title"><b>Example&nbsp;5.13.&nbsp;MethodValidationGroupSelector contract</b></p><pre class="programlisting">/**
 * Provides the (set of) groups that should be used when validating the
 * given constrained method.
 * 
 * @author Emmanuel Bernard
 */
interface MethodValidationGroupSelector {
    Class&lt;?&gt;[] selectGroupsForMethod(Method method):
    Class&lt;?&gt;[] selectGroupsForConstructor(Constructor constructor);
}</pre></div><p>The components <tt class="classname">MethodValidationActivator</tt>
      and <tt class="classname">MethodValidationGroupSelector</tt> are accepting
      injection points in a container environment (CDI in particular).
      Implementations must be thread-safe.</p><p>Method and constructor validations can be globally disabled via
      the XML configuration descriptor by using the
      <tt class="literal">disable-method-validation</tt> element. Likewise, you can
      disable validation for a specific method / constructor or for all
      methods / constructors of a given bean by using the
      <tt class="literal">disable-method-validation</tt> attribute on the respective
      elements.</p><i><span class="remark">TODO: should we change the boolean disable-method-validation
      with the following enum based method-validation: NONE, PARAMETERS,
      RETURN_VALUE, ALL. What would be the use case for PARAMETERS /
      RETURN_VALUE? We could also use the enum but restrict it to NONE and ALL
      to plan for the future.</span></i><p>Here are a few use cases :</p><div class="itemizedlist"><ul type="disc"><li><p>choose a different group depending on the caller stack: a
          batch input might want different validation than a user input</p></li><li><p>choose a different group depending on a specific context: if a
          user is flagged as rogue, enforce more constraints</p></li><li><p>disable validations for a given deployment as it is considered
          a "safe" environment</p></li><li><p>disable a specific method validation for development purposes
          either via a custom
          <tt class="classname">MethodValidationGroupSelector</tt> implementation
          or via the XML deployment descriptor</p></li></ul></div><p>Context or caller stack implementations can be implemented in a
      couple of ways:</p><div class="itemizedlist"><ul type="disc"><li><p>use a thread local variable to carry the groups</p></li><li><p>use a request scoped CDI component to carry the groups: this
          component being injected in the
          <tt class="classname">MethodValidationGroupSelector</tt>
          implementation.</p></li></ul></div><p>Should we provide in the CDI integration a way to customize the
      group via an annotation? An annotation in the caller stack would set the
      expected group. This would resurrect the
      <tt class="classname">@MethodValidated</tt> annotation but not on the
      validated method itself.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bootstrapping"></a>5.5.&nbsp;Bootstrapping</h2></div></div><div></div></div><p>The bootstrapping API aims at providing a
    <tt class="classname">ValidatorFactory</tt> object which is used to create
    <tt class="classname">Validator</tt> instances. The bootstrap process is
    decoupled from the provider implementation initialization: a bootstrap
    implementation must be able to bootstrap any Bean Validation provider
    implementation. The bootstrap sequence has been designed to achieve
    several goals:</p><div class="itemizedlist"><ul type="disc"><li><p>plug multiple implementations</p></li><li><p>choose a specific implementation</p></li><li><p>extensibility: an application using a specific provider
        implementation can use specific configurations</p></li><li><p>share and reuse of metadata across
        <tt class="classname">Validator</tt>s</p></li><li><p>leave as much freedom as possible to implementations</p></li><li><div class="changed"><p>provide integration mechanisms to Java EE
        (starting from version 6) and other containers</p></div></li><li><p>type safety</p></li></ul></div><p>The main artifacts involved in the bootstrap process are:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">Validation</tt>: API entry point. Lets you
        optionally define the Bean Validation provider targeted as well as a
        provider resolution strategy. <tt class="classname">Validation</tt>
        generates <tt class="classname">Configuration</tt> objects and can
        bootstrap any provider implementation.</p></li><li><p><tt class="classname">ValidationProvider</tt>: contract between the
        bootstrap procedure and a Bean Validation provider
        implementation.</p></li><li><p><tt class="classname">ValidationProviderResolver</tt>: returns a
        list of all Bean Validation providers available in the execution
        context (generally the classpath).</p></li><li><p><tt class="classname">Configuration</tt>: collects the configuration
        details that will be used to build
        <tt class="classname">ValidatorFactory</tt>. A specific sub interface of
        <tt class="classname">Configuration</tt> must be provided by Bean
        Validation providers. This sub interface typically hosts provider
        specific configurations.</p></li><li><p><tt class="classname">ValidatorFactory</tt>: result of the bootstrap
        process. Build <tt class="classname">Validator</tt> instances from a given
        Bean Validation provider.</p></li><li><p><tt class="filename">META-INF/validation.xml</tt>: a configuration
        file, Bean Validation users can use to customize the configuration of
        the default <tt class="classname">ValidatorFactory</tt>.</p></li></ul></div><p>Let's first see the API in action through some examples before
    diving into the concrete definitions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6099"></a>5.5.1.&nbsp;Examples</h3></div></div><div></div></div><p>The most simple approach is to initialize the default Bean
      Validation provider or the one defined in the XML configuration file.
      The <tt class="classname">ValidatorFactory</tt> is then ready to provide
      <tt class="classname">Validator</tt> instances.</p><div class="changed"><div class="example"><a name="d0e6110"></a><p class="title"><b>Example&nbsp;5.14.&nbsp;Simple Bean Validation bootstrap sequence</b></p><pre class="programlisting">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();

//when the application shuts down, close ValidatorFactory
factory.close()</pre></div></div><p>The <tt class="classname">ValidatorFactory</tt> object is thread-safe.
      Building <tt class="classname">Validator</tt> instances is typically a cheap
      operation. Building a <tt class="classname">ValidatorFactory</tt> is
      typically more expensive. Make sure to check your Bean Validation
      implementation documentation for more accurate details.</p><p>The second example shows how a container can customize some Bean
      Validator resource handling to match its own behavior.</p><div class="changed"><div class="example"><a name="d0e6128"></a><p class="title"><b>Example&nbsp;5.15.&nbsp;Customize message resolution, traversable resolver, constraint
        Validator factory and parameter name provider implementation</b></p><pre class="programlisting">//some customization from a container
ValidatorFactory factory = Validation
       .byDefaultProvider().configure()
          .messageInterpolator( new ContainerMessageInterpolator() )
          .constraintValidatorFactory( new ContainerComponentConstraintValidatorFactory() )
          .traversableResolver( new JPAAwareTraversableResolver() )
          .parameterNameProvider( new AnnotationBasedParameterNameProvider() )
          .buildValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();

//when the application shuts down, close ValidatorFactory
factory.close()</pre></div></div><p>The third example shows how to bootstrap Bean Validation in an
      environment not following the traditional Java classloader strategies
      (such as tools or alternative service containers like OSGi). They can
      provider some alternative provider resolution strategy to discover Bean
      Validation providers.</p><div class="changed"><div class="example"><a name="d0e6135"></a><p class="title"><b>Example&nbsp;5.16.&nbsp;Customize the Bean Validation provider resolution
        mechanism</b></p><pre class="programlisting">//osgi environment
ValidatorFactory factory = Validation
       .byDefaultProvider()
          .providerResolver( new OSGiServiceDiscoverer() )
          .configure()
             .buildValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();

//when the bundle shuts down, close ValidatorFactory
factory.close()</pre></div></div><p>The next example shows how a client can choose a specific Bean
      Validation provider and configure provider specific properties
      programmatically in a type-safe way.</p><div class="example"><a name="d0e6142"></a><p class="title"><b>Example&nbsp;5.17.&nbsp;Use a specific provider and add specific configuration</b></p><pre class="programlisting">ValidatorFactory factory = Validation
       .byProvider( ACMEProvider.class )  //chose a specific provider
       .configure()
          .messageInterpolator( new ContainerMessageInterpolator() ) //default configuration option
          .addConstraint(Address.class, customConstraintDescriptor) //ACME specific method
          .buildValidatorFactory();

//same initialization decomposing calls
ACMEConfiguration acmeConfiguration = Validation
       .byProvider( ACMEProvider.class )
       .configure();

ValidatorFactory factory = acmeConfiguration
          .messageInterpolator( new ContainerMessageInterpolator() ) //default configuration option
          .addConstraint(Address.class, customConstraintDescriptor) //ACME specific method
          .buildValidatorFactory();

/**
 * ACME specific validator configuration and configuration options
 */
public interface ACMEConfiguration extends Configuration&lt;ACMEConfiguration&gt; {
    /**
     * Programmatically add constraints. Specific to the ACME provider.
     */
    ACMEConfiguration addConstraint(Class&lt;?&gt; entity, 
                                    ACMEConstraintDescriptor constraintDescriptor);
}

/**
 * ACME validation provider
 * Note how ACMEConfiguration and ACMEProvider are linked together 
 * via the generic parameter.
 */
public class ACMEProvider implements ValidationProvider&lt;ACMEConfiguration&gt; {
    ...
}</pre></div><p>The last example shows how a <tt class="classname">Validator</tt> can
      use a specific <tt class="classname">MessageInterpolator</tt>
      implementation</p><div class="example"><a name="d0e6155"></a><p class="title"><b>Example&nbsp;5.18.&nbsp;Use a specific MessageInterpolator instance for a given
        Validator</b></p><pre class="programlisting">ValidatorFactory factory = ...;
MessageInterpolator customInterpolator = new LocaleSpecificMessageInterpolator(
    locale, 
    factory.getMessageInterpolator()
);

Validator localizedValidator = 
    factory.usingContext()
                   .messageInterpolator(customInterpolator)
                   .getValidator();</pre></div><p>In the same way, a custom
      <tt class="classname">TraversableResolver</tt> can be passed.</p><p>We will now explore the various interfaces, their constraints and
      usage. We will go from the <tt class="classname">ValidatorFactory</tt> to
      the <tt class="classname">Validation</tt> class walking up the bootstrap
      chain.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6173"></a>5.5.2.&nbsp;ValidatorFactory</h3></div></div><div></div></div><div class="changed"><p><tt class="classname">ValidatorFactory</tt>
      objects build and provide initialized instances of
      <tt class="classname">Validator</tt> to Bean Validation clients. Each
      <tt class="classname">Validator</tt> instance is configured for a given
      context (message interpolator, traversable resolver). Clients should
      cache <tt class="classname">ValidatorFactory</tt> objects and reuse them for
      optimal performances. The API is designed to allow implementors to share
      constraint metadata in <tt class="classname">ValidatorFactory</tt>.
      <tt class="classname">ValidatorFactory</tt> instances must be closed (by
      calling the <tt class="methodname">close()</tt> method) by its creator when
      no longer in use.</p></div><p><tt class="classname">ValidatorFactory</tt> implementations must be
      thread-safe. <tt class="classname">ValidatorFactory</tt> implementations can
      cache <tt class="classname">Validator</tt> instances if needed.</p><div class="changed"><div class="example"><a name="d0e6208"></a><p class="title"><b>Example&nbsp;5.19.&nbsp;ValidatorFactory interface</b></p><pre class="programlisting">/**
 * Factory returning initialized {@code Validator} instances.
 *
 * Implementations are thread-safe and instances are typically cached and reused.
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 * @author Hardy Ferentschik
 */
public interface ValidatorFactory {
    /**
     * Returns an initialized {@code Validator} instance using the
     * factory defaults for message interpolator, traversable resolver
     * and constraint validator factory.
     * &lt;p&gt;
     * Validator instances can be pooled and shared by the implementation.
     * &lt;/p&gt;
     *
     * @return an initialized {@code Validator} instance
     */
    Validator getValidator();

    /**
     * Defines a new validator context and return a {@code Validator}
     * compliant this new context.
     *
     * @return a {@code ValidatorContext} instance
     */
    ValidatorContext usingContext();

    /**
     * Returns the {@code MessageInterpolator} instance configured at
     * initialization time for the {@code ValidatorFactory}.
     * This is the instance used by {@link #getValidator()}.
     *
     * @return MessageInterpolator instance
     */
    MessageInterpolator getMessageInterpolator();

    /**
     * Returns the {@code TraversableResolver} instance configured
     * at initialization time for the {@code ValidatorFactory}.
     * This is the instance used by {@link #getValidator()}.
     *
     * @return TraversableResolver instance
     */
    TraversableResolver getTraversableResolver();

    /**
     * Returns the {@code ConstraintValidatorFactory} instance
     * configured at initialization time for the
     * {@code ValidatorFactory}.
     * This is the instance used by #getValidator().
     *
     * @return ConstraintValidatorFactory instance
     */
    ConstraintValidatorFactory getConstraintValidatorFactory();

    /**
     * Returns the {@code ParameterNameProvider} instance configured at
     * initialization time for the {@code ValidatorFactory}.
     * This is the instance used by #getValidator().
     *
     * @return ParameterNameProvider instance
     */
    ParameterNameProvider getParameterNameProvider();
 
    /**
     * Returns an instance of the specified type allowing access to
     * provider-specific APIs. If the Bean Validation provider
     * implementation does not support the specified class, a
     * {@code ValidationException} is thrown.
     *
     * @param type the class of the object to be returned
     *
     * @return an instance of the specified class
     *
     * @throws ValidationException if the provider does not
     * support the call.
     */
    public &lt;T&gt; T unwrap(Class&lt;T&gt; type);

    /**
     * Close the {@code ValidatorFactory} instance.
     *
     * After the {@code ValidatorFactory} instance is closed, it is not allowed to call:
     * &lt;ul&gt;
     * &lt;li&gt;methods of this {@code ValidatorFactory} instance&lt;/li&gt;
     * &lt;li&gt;methods of {@code Validator} instances created by this {@code ValidatorFactory}&lt;/li&gt;
     * &lt;/ul&gt;
     */
    public void close();
}</pre></div></div><p>A <tt class="classname">ValidatorFactory</tt> is provided by a
      <tt class="classname">Configuration</tt> object.</p><p><tt class="methodname">unwrap</tt> is provided as a way to access
      objects of a given type specific to a Bean Validation provider typically
      as a complement to the <tt class="classname">ValidatorFactory</tt> contract.
      Using this method makes your code non portable.</p><div class="added"><p><tt class="methodname">close</tt> closes the
      <tt class="classname">ValidatorFactory</tt> instance which becomes
      unavailable and should be immediately discarded. This is also true of
      all the <tt class="classname">Validator</tt> instances it has
      spawned.</p></div><div class="example"><a name="d0e6238"></a><p class="title"><b>Example&nbsp;5.20.&nbsp;Using unwrap to access a provider specific contract</b></p><pre class="programlisting">//if using the ACME provider
ACMEValidatorFactory acmeFactory = factory.unwrap(ACMEValidatorFactory.class);
acmeFactory.setSpecificConfiguration(...);</pre></div><p><tt class="methodname">getMessageInterpolator()</tt> returns the
      <tt class="classname">MessageInterpolator</tt> instance configured during
      the initialization of the <tt class="classname">ValidatorFactory</tt>. It is
      particularly useful to build a <tt class="classname">Validator</tt> specific
      <tt class="classname">MessageInterpolator</tt> wrapping the one from the
      <tt class="classname">ValidatorFactory</tt>.</p><p><tt class="methodname">getTraversableResolver()</tt> returns the
      <tt class="classname">TraversableResolver</tt> instance configured during
      the initialization of the <tt class="classname">ValidatorFactory</tt>. It is
      particularly useful to build a <tt class="classname">Validator</tt> specific
      <tt class="classname">TraversableResolver</tt> wrapping the one from the
      <tt class="classname">ValidatorFactory</tt>.</p><p><tt class="methodname">getConstraintValidatorFactory()</tt> returns
      the <tt class="classname">ConstraintValidatorFactory</tt> instance
      configured during the initialization of the
      <tt class="classname">ValidatorFactory</tt>. It is particularly useful to
      build a <tt class="classname">Validator</tt> specific
      <tt class="classname">ConstraintValidatorFactory</tt> wrapping the one from
      the <tt class="classname">ValidatorFactory</tt>.</p><div class="added"><p><tt class="methodname">getParameterNameProvider()</tt>
      returns the <tt class="classname">ParameterNameProvider</tt> instance
      configured during the initialization of the
      <tt class="classname">ValidatorFactory</tt>. It is particularly useful to
      build a <tt class="classname">Validator</tt> specific
      <tt class="classname">ParameterNameProvider</tt> wrapping the one from the
      <tt class="classname">ValidatorFactory</tt>.</p></div><p><tt class="classname">ValidatorContext</tt> returned by
      <tt class="methodname">usingContext</tt> can be used to customize the state
      in which the <tt class="classname">Validator</tt> must be initialized. This
      is used to customize the <tt class="classname">MessageInterpolator</tt>, the
      <tt class="classname">TraversableResolver</tt> or the
      <tt class="classname">ConstraintValidatorFactory</tt>.</p><div class="changed"><div class="example"><a name="d0e6338"></a><p class="title"><b>Example&nbsp;5.21.&nbsp;ValidatorContext interface</b></p><pre class="programlisting">/**
 * Represents the context that is used to create &lt;code&gt;Validator&lt;/code&gt;
 * instances.
 *
 * A client may use methods of the &lt;code&gt;ValidatorContext&lt;/code&gt; returned by
 * &lt;code&gt;ValidatorFactory#usingContext&lt;/code&gt; to customize
 * the context used to create &lt;code&gt;Validator&lt;/code&gt; instances
 * (for instance establish different message interpolators or
 * traversable resolvers).
 * 
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 */
public interface ValidatorContext {
    /**
     * Defines the message interpolator implementation used by the
     * &lt;code&gt;Validator&lt;/code&gt;.
     * If not set or if null is passed as a parameter,
     * the message interpolator of the &lt;code&gt;ValidatorFactory&lt;/code&gt;
     * is used.
     *
     * @return self following the chaining method pattern
     */
    ValidatorContext messageInterpolator(MessageInterpolator messageInterpolator);

    /**
     * Defines the traversable resolver implementation used by the
     * &lt;code&gt;Validator&lt;/code&gt;.
     * If not set or if null is passed as a parameter,
     * the traversable resolver of the &lt;code&gt;ValidatorFactory&lt;/code&gt; is used.
     *
     * @return self following the chaining method pattern
     */
    ValidatorContext traversableResolver(TraversableResolver traversableResolver);

    /**
     * Defines the constraint validator factory implementation used by the
     * &lt;code&gt;Validator&lt;/code&gt;.
     * If not set or if null is passed as a parameter,
     * the constraint validator factory of the &lt;code&gt;ValidatorFactory&lt;/code&gt; is used.
     *
     * @return self following the chaining method pattern
     */
    ValidatorContext constraintValidatorFactory(ConstraintValidatorFactory factory);

    /**
     * Defines the parameter name provider implementation used by the
     * &lt;code&gt;Validator&lt;/code&gt;. If not set or if null is passed as a parameter,
     * the parameter name provider of the &lt;code&gt;ValidatorFactory&lt;/code&gt; is used.
     *
     * @param parameterNameProvider Parameter name provider implementation.
     *
     * @return self following the chaining method pattern
     */
    ValidatorContext parameterNameProvider(ParameterNameProvider parameterNameProvider);

    /**
     * @return an initialized &lt;code&gt;Validator&lt;/code&gt; instance respecting the defined state.
     * Validator instances can be pooled and shared by the implementation.
     */
    Validator getValidator();
}</pre></div></div><div class="changed"><p>The
      <tt class="classname">MessageInterpolator</tt>, the
      <tt class="classname">TraversableResolver</tt>, the
      <tt class="classname">ConstraintValidatorFactory</tt> or the
      <tt class="classname">ParameterNameProvider</tt> passed to the
      <tt class="classname">ValidatorContext</tt> are used instead of the
      <tt class="classname">ValidatorFactory</tt>'s
      <tt class="classname">MessageInterpolator</tt>,
      <tt class="classname">TraversableResolver</tt>,
      <tt class="classname">ConstraintValidatorFactory</tt> or
      <tt class="classname">ParameterNameProvider</tt> instances.</p></div><div class="example"><a name="d0e6375"></a><p class="title"><b>Example&nbsp;5.22.&nbsp;Use of ValidatorFactory</b></p><pre class="programlisting">ValidatorFactory factory = ...
Validator validatorUsingDefaults = factory.getValidator();
Validator validatorUsingCustomTraversable = factory
                     .usingContext()
                     .traversableResolver( new JPATraversableResolver() )
                     .getValidator();</pre></div><p>See <a href="#validationapi-message-examples-specificlocale" title="Example&nbsp;5.8.&nbsp;Use MessageInterpolator to use a specific Locale value">Example&nbsp;5.8, &#8220;Use MessageInterpolator to use a specific Locale value&#8221;</a> for an example
      using
      <tt class="methodname">ValidatorFactory.getMessageInterpolator()</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6387"></a>5.5.3.&nbsp;Configuration</h3></div></div><div></div></div><div class="changed"><p>The responsibility of the
      <tt class="classname">Configuration</tt> is to collect configuration
      information, to determine the correct provider implementation and to
      delegate the <tt class="classname">ValidatorFactory</tt> creation to the
      seleced provider. More concretely <tt class="classname">Configuration</tt>
      lets you define:</p></div><div class="itemizedlist"><ul type="disc"><li><div class="changed"><p>the message interpolator
          instance</p></div></li><li><div class="changed"><p>the traversable resolver
          instance</p></div></li><li><p>the constraint validator factory instance</p></li><li><div class="added"><p>the parameter name provider instance</p></div></li><li><p>XML constraint mappings</p></li><li><p>provider specific properties</p></li><li><div class="changed"><p>whether or not
          <tt class="classname">META-INF/validation.xml</tt> is considered</p></div></li></ul></div><p><tt class="classname">Configuration</tt> does provide a
      <tt class="classname">MessageInterpolator</tt> implementation following the
      default Bean Validation <tt class="classname">MessageInterpolator</tt> rules
      as defined in <a href="#default-messageresolver" title="5.3.1.&nbsp;Default message interpolation">Section&nbsp;5.3.1, &#8220;Default message interpolation&#8221;</a>. You can access
      it by calling <tt class="methodname">getDefaultMessageInterpolator()</tt>.
      Such an implementation is useful to let a custom
      <tt class="classname">MessageInterpolator</tt> delegate to the standard
      <tt class="classname">MessageInterpolator</tt> (see <a href="#custom-message-resolution" title="5.3.2.&nbsp;Custom message interpolation">Section&nbsp;5.3.2, &#8220;Custom message interpolation&#8221;</a> and an example making use of
      <tt class="methodname">getDefaultMessageInterpolator()</tt> in <a href="#validationapi-message-examples-jsflocale" title="Example&nbsp;5.9.&nbsp;Contextual container possible&#xA;        MessageInterpolator implementation">Example&nbsp;5.9, &#8220;Contextual container possible
        MessageInterpolator implementation&#8221;</a>).</p><p><tt class="classname">Configuration</tt> does provide a
      <tt class="classname">TraversableResolver</tt> implementation following the
      default Bean Validation <tt class="classname">TraversableResolver</tt> rules
      as defined in <a href="#constraintdeclarationvalidationprocess-validationroutine-traversable" title="4.6.3.&nbsp;Traversable property">Section&nbsp;4.6.3, &#8220;Traversable property&#8221;</a>.
      You can access it by calling
      <tt class="methodname">getDefaultTraversableResolver()</tt>. Such an
      implementation is useful to let a custom
      <tt class="classname">TraversableResolver</tt> delegate to the standard
      <tt class="classname">TraversableResolver</tt>.</p><p><tt class="classname">Configuration</tt> does provide a
      <tt class="classname">ConstraintValidatorFactory</tt> implementation
      following the default Bean Validation
      <tt class="classname">ConstraintValidatorFactory</tt> rules as defined in
      <a href="#constraintsdefinitionimplementation-constraintfactory" title="3.5.&nbsp;The ConstraintValidatorFactory">Section&nbsp;3.5, &#8220;The ConstraintValidatorFactory&#8221;</a>.
      You can access it by calling
      <tt class="methodname">getDefaultConstraintValidatorFactory()</tt>. Such an
      implementation is useful to let a custom
      <tt class="classname">ConstraintValidatorFactory</tt> delegate to the
      standard <tt class="classname">ConstraintValidatorFactory</tt>.</p><div class="added"><p><tt class="classname">Configuration</tt> does
      provide a <tt class="classname">ParameterNameProvider</tt> implementation
      following the default Bean Validation
      <tt class="classname">ParameterNameProvider</tt> rules as defined in <a href="#constraintdeclarationvalidationprocess-methodlevelconstraints-definingparameterconstraints-namingparameters" title="4.5.2.2.&nbsp;Naming parameters">Section&nbsp;4.5.2.2, &#8220;Naming parameters&#8221;</a>.
      You can access it by calling
      <tt class="methodname">getDefaultParameterNameProvider()</tt>. Such an
      implementation is useful to let a custom
      <tt class="classname">ParameterNameProvider</tt> delegate to the standard
      <tt class="classname">ParameterNameProvider</tt>.</p></div><div class="added"><p>Via
      <tt class="classname">getBootstrapConfiguration()</tt>,
      <tt class="classname">Configuration</tt> also exposes data stored in
      <tt class="classname">META-INF/validation.xml</tt> (see <a href="#xml-config" title="5.5.6.&nbsp;XML Configuration: META-INF/validation.xml">Section&nbsp;5.5.6, &#8220;XML Configuration: META-INF/validation.xml&#8221;</a>). This is particularly useful for containers
      wishing to control the instance creation and life cycle (more
      information at <a href="#bootstrapping-usageandcontainerexpectation" title="5.5.7.&nbsp;Bootstrapping considerations">Section&nbsp;5.5.7, &#8220;Bootstrapping considerations&#8221;</a>).</p></div><div class="added"><p>Using <tt class="methodname">addMapping()</tt>,
      additional constraint mapping XML descriptors can be added to the
      configuration (see <a href="#xml-config" title="5.5.6.&nbsp;XML Configuration: META-INF/validation.xml">Section&nbsp;5.5.6, &#8220;XML Configuration: META-INF/validation.xml&#8221;</a>). The given input
      streams should support the <tt class="methodname">mark()</tt> and
      <tt class="methodname">reset()</tt> methods defined by
      <tt class="classname">java.io.InputStream</tt>. Streams not supporting the
      <tt class="methodname">mark()</tt> and <tt class="methodname">reset()</tt>
      methods will be wrapped with an <tt class="classname">InputStream</tt>
      implementation supporting these methods by the Bean Validation provider
      in order to allow the streams to be read several times.</p></div><p>Clients call
      <tt class="methodname">Configuration.buildValidatorFactory()</tt> to
      retrieve the initialized <tt class="classname">ValidatorFactory</tt>
      instance.<span class="added"><span> It is legal to invoke
      <tt class="methodname">buildValidatorFactory()</tt> several times, e.g. in
      order to retrieval several <tt class="classname">ValidatorFactory</tt>
      instances with a slightly different configuration (see <a href="#using-configuration-several-times" title="Example&nbsp;5.27.&nbsp;Using Configuration to create several validator&#xA;        factories">Example&nbsp;5.27, &#8220;Using Configuration to create several validator
        factories&#8221;</a>).</span></span></p><div class="changed"><div class="example"><a name="d0e6575"></a><p class="title"><b>Example&nbsp;5.23.&nbsp;Configuration and BootstrapConfiguration interfaces</b></p><pre class="programlisting">package javax.validation;

/**
 * Receives configuration information, selects the appropriate
 * Bean Validation provider and builds the appropriate {@code ValidatorFactory}.
 * &lt;p/&gt;
 * Usage:
 * &lt;pre&gt;
 * {@code
 * Configuration&lt;?&gt; configuration = //provided by one of the Validation bootstrap methods
 *     ValidatorFactory = configuration
 *         .messageInterpolator( new CustomMessageInterpolator() )
 *         .buildValidatorFactory();}
 * &lt;/pre&gt;
 * &lt;p/&gt;
 * By default, the configuration information is retrieved from
 * &lt;i&gt;META-INF/validation.xml&lt;/i&gt;.
 * It is possible to override the configuration retrieved from the XML file
 * by using one or more of the {@code Configuration} methods.
 * &lt;p/&gt;
 * The {@link ValidationProviderResolver} is specified at configuration time
 * (see {@link javax.validation.spi.ValidationProvider}).
 * If none is explicitly requested, the default {@code ValidationProviderResolver} is used.
 * &lt;p/&gt;
 * The provider is selected in the following way:
 * &lt;ul&gt;
 * &lt;li&gt;if a specific provider is requested programmatically using
 * {@code Validation.byProvider(Class)}, find the first provider implementing
 * the provider class requested and use it&lt;/li&gt;
 * &lt;li&gt;if a specific provider is requested in &lt;i&gt;META-INF/validation.xml&lt;/i&gt;,
 * find the first provider implementing the provider class requested and use it&lt;/li&gt;
 * &lt;li&gt;otherwise, use the first provider returned by the {@code ValidationProviderResolver}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * Implementations are not meant to be thread-safe.
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 * @author Hardy Ferentschik
 */
public interface Configuration&lt;T extends Configuration&lt;T&gt;&gt; {

    /**
     * Ignore data from the &lt;i&gt;META-INF/validation.xml&lt;/i&gt; file if this
     * method is called.
     * This method is typically useful for containers that parse
     * &lt;i&gt;META-INF/validation.xml&lt;/i&gt; themselves and pass the information
     * via the {@code Configuration} methods.
     *
     * @return {@code this} following the chaining method pattern.
     */
    T ignoreXmlConfiguration();

    /**
     * Defines the message interpolator used. Has priority over the configuration
     * based message interpolator.
     * If {@code null} is passed, the default message interpolator is used
     * (defined in XML or the specification default).
     *
     * @param interpolator message interpolator implementation.
     *
     * @return {@code this} following the chaining method pattern.
     */
    T messageInterpolator(MessageInterpolator interpolator);

    /**
     * Defines the traversable resolver used. Has priority over the configuration
     * based traversable resolver.
     * If {@code null} is passed, the default traversable resolver is used
     * (defined in XML or the specification default).
     *
     * @param resolver traversable resolver implementation.
     *
     * @return {@code this} following the chaining method pattern.
     */
    T traversableResolver(TraversableResolver resolver);

    /**
     * Defines the constraint validator factory. Has priority over the configuration
     * based constraint factory.
     * If null is passed, the default constraint validator factory is used
     * (defined in XML or the specification default).
     *
     * @param constraintValidatorFactory constraint factory implementation.
     *
     * @return {@code this} following the chaining method pattern.
     */
    T constraintValidatorFactory(ConstraintValidatorFactory constraintValidatorFactory);

    /**
     * Defines the parameter name provider. Has priority over the configuration
     * based provider.
     * If null is passed, the default parameter name provider is used
     * (defined in XML or the specification default).
     *
     * @param parameterNameProvider Parameter name provider implementation.
     *
     * @return {@code this} following the chaining method pattern.
     */
    T parameterNameProvider(ParameterNameProvider parameterNameProvider);

    /**
     * Add a stream describing constraint mapping in the Bean Validation XML
     * format.
     * &lt;p/&gt;
     * The stream should be closed by the client API after the
     * {@code ValidatorFactory} has been built. The Bean Validation provider
     * must not close the stream.
     *
     * @param stream
     *            XML mapping stream. The given stream should support the
     *            mark/reset contract (see {@link InputStream#markSupported()}).
     *            If it doesn't, it will be wrapped into a stream supporting the
     *            mark/reset contract by the Bean Validation provider.
     *
     * @return {@code this} following the chaining method pattern.
     *
     * @throws IllegalArgumentException
     *             if {@code stream} is null
     */
    T addMapping(InputStream stream);

    /**
     * Add a provider specific property. This property is equivalent to
     * XML configuration properties.
     * If the underlying provider does not know how to handle the property,
     * it must silently ignore it.
     * &lt;p/&gt;
     * Note: Using this non type-safe method is generally not recommended.
     * &lt;p/&gt;
     * It is more appropriate to use, if available, the type-safe equivalent provided
     * by a specific provider via its {@code Configuration} subclass.
     * &lt;pre&gt;{@code ValidatorFactory factory = Validation.byProvider(ACMEProvider.class)
     * .configure()
     * .providerSpecificProperty(ACMEState.FAST)
     * .buildValidatorFactory();}
     * &lt;/pre&gt;
     * This method is typically used by containers parsing &lt;i&gt;META-INF/validation.xml&lt;/i&gt;
     * themselves and injecting the state to the Configuration object.
     * &lt;p/&gt;
     * If a property with a given name is defined both via this method and in the
     * XML configuration, the value set programmatically has priority.
     * &lt;p/&gt;
     * If null is passed as a value, the value defined in XML is used. If no value
     * is defined in XML, the property is considered unset.
     *
     * @param name property name.
     * @param value property value.
     *
     * @return {@code this} following the chaining method pattern.
     *
     * @throws IllegalArgumentException if {@code name} is null
     */
    T addProperty(String name, String value);

    /**
     * Return an implementation of the {@code MessageInterpolator} interface
     * following the default {@code MessageInterpolator} defined in the
     * specification:
     * &lt;ul&gt;
     * &lt;li&gt;use the ValidationMessages resource bundle to load keys&lt;/li&gt;
     * &lt;li&gt;use Locale.getDefault()&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return default MessageInterpolator implementation compliant with the specification
     */
    MessageInterpolator getDefaultMessageInterpolator();

    /**
     * Return an implementation of the {@code TraversableResolver} interface
     * following the default {@code TraversableResolver} defined in the
     * specification:
     * &lt;ul&gt;
     * &lt;li&gt;if Java Persistence is available in the runtime environment,
     * a property is considered reachable if Java Persistence considers
     * the property as loaded&lt;/li&gt;
     * &lt;li&gt;if Java Persistence is not available in the runtime environment,
     * all properties are considered reachable&lt;/li&gt;
     * &lt;li&gt;all properties are considered cascadable.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return default TraversableResolver implementation compliant with the specification
     */
    TraversableResolver getDefaultTraversableResolver();

    /**
     * Return an implementation of the {@code ConstraintValidatorFactory} interface
     * following the default {@code ConstraintValidatorFactory} defined in the
     * specification:
     * &lt;ul&gt;
     * &lt;li&gt;uses the public no-arg constructor of the {@code ConstraintValidator}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return default ConstraintValidatorFactory implementation compliant with the specification
     */
    ConstraintValidatorFactory getDefaultConstraintValidatorFactory();

    /**
     * Return an implementation of the {@code ParameterNameProvider}
     * interface following the default {@code ParameterNameProvider}
     * defined in the specification:
     * &lt;ul&gt;
     * &lt;li&gt;returns names in the form {@code arg&amp;lt;PARAMETER_INDEX&amp;gt;}
     * where {@code PARAMETER_INDEX} starts at 0 for the first parameter,
     * e.g. {@code arg0}, {@code arg1} etc.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return default ParameterNameProvider implementation compliant with
     *         the specification
     */
    ParameterNameProvider getDefaultParameterNameProvider();

    /**
     * Return configuration information stored in the &lt;i&gt;META-INF/validation.xml&lt;/i&gt; file.
     * &lt;p/&gt;
     * &lt;b&gt;Note&lt;/b&gt;:&lt;br/&gt;
     * Implementations are encouraged to lazily build this object to delay parsing.
     *
     * @return Returns an instance of {@code BootstrapConfiguration}. This method returns never {@code null}. If there
     *         is no &lt;i&gt;META-INF/validation.xml&lt;/i&gt; the different getters of the returned instance will return {@code null} respective
     *         the empty set or map.
     */
    BootstrapConfiguration getBootstrapConfiguration();

    /**
     * Build a {@code ValidatorFactory} implementation.
     *
     * @return ValidatorFactory
     *
     * @throws ValidationException if the ValidatorFactory cannot be built
     */
    ValidatorFactory buildValidatorFactory();
}</pre><div class="added"><pre class="programlisting">package javax.validation;

/**
 * Represents the user specified default configuration in &lt;i&gt;META-INF/validation.xml&lt;/i&gt;.
 *
 * @author Emmanuel Bernard &lt;emmanuel@hibernate.org&gt;
 * @author Gunnar Morling
 * @author Hardy Ferentschik
 */
public interface BootstrapConfiguration {
    /**
     * Class name of the {@code ValidationProvider} implementation
     * or {@code null} if none is specified.
     *
     * @return validation provider class name
     */
    public String getDefaultProviderClassName();

    /**
     * Class name of the {@code ConstraintValidatorFactory} implementation
     * or {@code null} if none is specified.
     *
     * @return constraint validator factory class name
     */
    public String getConstraintValidatorFactoryClassName();

    /**
     * Class name of the {@code MessageInterpolator} implementation
     * or {@code null} if none is specified.
     *
     * @return message interpolator class name or {@code null}
     */
    public String getMessageInterpolatorClassName();

    /**
     * Class name of the {@code TraversableResolver} implementation
     * or {@code null} if none is specified.
     *
     * @return traversable resolver class name or {@code null}
     */
    public String getTraversableResolverClassName();

    /**
     * Class name of the {@code ParameterNameProvider} implementation
     * or {@code null} if none is specified.
     *
     * @return parameter name provider class name or {@code null}
     */
    public String getParameterNameProviderClassName();

    /**
     * Returns a set of resource paths pointing to XML constraint mapping files.
     * The set is empty if none are specified.
     *
     * @return set of constraint mapping resource paths
     */
    public Set&lt;String&gt; getConstraintMappingResourcePaths();

    /**
     * Returns properties as a map of string based key/value pairs.
     * The map is empty if no property has been specified.
     *
     * @return the properties map
     */
    public Map&lt;String, String&gt; getProperties();
}
</pre></div></div></div><p>A Bean Validation provider must define a sub interface of
      <tt class="classname">Configuration</tt> uniquely identifying the provider.
      This subclass is linked to its provider via the
      <tt class="classname">ValidationProvider</tt> generic parameter. The
      <tt class="classname">Configuration</tt> sub interface typically hosts
      provider specific configuration methods.</p><p>To facilitate the use of provider specific configuration methods,
      <tt class="classname">Configuration</tt> uses generics:
      <tt class="classname">Configuration&lt;T extends
      Configuration&lt;T&gt;&gt;</tt> ; the generic return type
      <tt class="classname">T</tt> is returned by chaining methods. The provider
      specific sub interface must resolve the generic T as itself as shown in
      <a href="#example-providerspecific-config" title="Example&nbsp;5.24.&nbsp;Example of provider specific Configuration sub&#xA;        interface">Example&nbsp;5.24, &#8220;Example of provider specific Configuration sub
        interface&#8221;</a>.</p><div class="example"><a name="example-providerspecific-config"></a><p class="title"><b>Example&nbsp;5.24.&nbsp;Example of provider specific Configuration sub
        interface</b></p><pre class="programlisting">/**
 * Unique identifier of the ACME provider
 * also hosts some provider specific configuration methods
 */
public interface ACMEConfiguration 
    extends Configuration&lt;ACMEConfiguration&gt; {

    /**
     * Enables constraints implementation dynamic reloading when using ACME
     * default to false
     */
    ACMEConfiguration enableDynamicReloading(boolean);

}</pre></div><p>When
      <tt class="methodname">Configuration.buildValidatorFactory()</tt> is
      called, the initialized <tt class="classname">ValidatorFactory</tt> is
      returned. More specifically, the requested Bean Validation provider is
      determined and the result of
      <tt class="code">validationProvider.buildValidatorFactory(ConfigurationState)</tt>
      is returned. <tt class="classname">ConfigurationState</tt> gives access to
      the configuration artifacts defined in
      <tt class="filename">META-INF/validation.xml</tt> (unless XML configuration
      is ignored) and provided programmatically to
      <tt class="classname">Configuration</tt>. Generally speaking,
      programmatically defined elements have priority over XML defined
      configuration elements (read the <tt class="classname">Configuration</tt>
      JavaDoc and see <a href="#xml-config" title="5.5.6.&nbsp;XML Configuration: META-INF/validation.xml">Section&nbsp;5.5.6, &#8220;XML Configuration: META-INF/validation.xml&#8221;</a> for more
      information).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A typical implementation of <tt class="classname">Configuration</tt>
        also implements <tt class="classname">ConfigurationState</tt>, hence
        <tt class="code">this</tt> can be passed to
        <tt class="methodname">buildValidatorFactory(ConfigurationState)</tt>.</p></div><p>Streams represented in the XML configuration and opened by the
      <tt class="classname">Configuration</tt> implementation must be closed by
      the <tt class="classname">Configuration</tt> implementation after the
      <tt class="classname">ValidatorFactory</tt> creation (or if an exception
      occurs). Streams provided programmatically are the responsibility of the
      application.</p><div class="changed"><div class="example"><a name="d0e6662"></a><p class="title"><b>Example&nbsp;5.25.&nbsp;ConfigurationState interface</b></p><pre class="programlisting">package javax.validation.spi;

/**
 * Contract between a {@code Configuration} and a
 * &lt;@code ValidatorProvider} to create a {@code ValidatorFactory}.
 * The configuration artifacts defined in the XML configuration and provided to the
 * {@code Configuration} are merged and passed along via
 * {@code ConfigurationState}.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @author Gunnar Morling
 */
public interface ConfigurationState {

    /**
     * Returns true if Configuration.ignoreXMLConfiguration() has been called
     * In this case, the ValidatorFactory must ignore META-INF/validation.xml
     *
     * @return {@code true} if META-INF/validation.xml should be ignored
     */
    boolean isIgnoreXmlConfiguration();

    /**
     * Returns the message interpolator of this configuration.
     * Message interpolator is defined in the following decreasing priority:
     * &lt;ul&gt;
     * &lt;li&gt;set via the {@code Configuration} programmatic API&lt;/li&gt;
     * &lt;li&gt;defined in META-INF/validation.xml provided that ignoreXmlConfiguration
     * is false. In this case the instance is created via its no-arg constructor.&lt;/li&gt;
     * &lt;li&gt;{@code null} if undefined.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return message provider instance or null if not defined
     */
    MessageInterpolator getMessageInterpolator();

    /**
     * Returns a set of configuration streams. The streams are defined by:
     * &lt;ul&gt;
     * &lt;li&gt;mapping XML streams passed programmatically in {@code Configuration}&lt;/li&gt;
     * &lt;li&gt;mapping XML streams located in the resources defined in&lt;/li&gt;
     * META-INF/validation.xml (constraint-mapping element)
     * &lt;/ul&gt;
     * Streams represented in the XML configuration and opened by the
     * {@code Configuration} implementation must be closed by the
     * {@code Configuration} implementation after the {@code ValidatorFactory}
     * creation (or if an exception occurs). All streams are guaranteed to
     * adhere to the mark/reset contract (see
     * {@link InputStream#markSupported()} by the Bean Validation provider.
     *
     * @return set of input stream
     */
    Set&lt;InputStream&gt; getMappingStreams();

    /**
     * Returns the constraint validator factory of this configuration.
     * The {@code ConstraintValidatorFactory} implementation is defined in the following
     * decreasing priority:
     * &lt;ul&gt;
     * &lt;li&gt;set via the {@code Configuration} programmatic API&lt;/li&gt;
     * &lt;li&gt;defined in META-INF/validation.xml provided that ignoredXmlConfiguration
     * is false. In this case the instance is created via its no-arg constructor.&lt;/li&gt;
     * &lt;li&gt;{@code null} if undefined.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return factory instance or {@code null} if not defined
     */
    ConstraintValidatorFactory getConstraintValidatorFactory();

    /**
     * Returns the traversable resolver for this configuration.
     * {@code TraversableResolver} is defined in the following decreasing priority:
     * &lt;ul&gt;
     * &lt;li&gt;set via the {@code Configuration} programmatic API&lt;/li&gt;
     * &lt;li&gt;defined in META-INF/validation.xml provided that ignoredXmlConfiguration
     * is false. In this case the instance is created via its no-arg constructor.&lt;/li&gt;
     * &lt;li&gt;{@code null} if undefined.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return traversable resolver instance or {@code null} if not defined
     */
    TraversableResolver getTraversableResolver();

    /**
     * Returns the parameter name provider for this configuration.
     * {@code ParameterNameProvider} is defined in the following decreasing priority:
     * &lt;ul&gt;
     * &lt;li&gt;set via the {@code Configuration} programmatic API&lt;/li&gt;
     * &lt;li&gt;defined in META-INF/validation.xml provided that ignoredXmlConfiguration
     * is false. In this case the instance is created via its no-arg constructor.&lt;/li&gt;
     * &lt;li&gt;{@code null} if undefined.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return parameter name provider instance or {@code null} if not defined
     */
    ParameterNameProvider getParameterNameProvider();

    /**
     * Returns a map of non type-safe custom properties.
     * Properties defined via:
     * &lt;ul&gt;
     * &lt;li&gt;Configuration.addProperty(String, String)&lt;/li&gt;
     * &lt;li&gt;META-INF/validation.xml provided that ignoredXmlConfiguration&lt;/li&gt;
     * is false.
     * &lt;/ul&gt;
     * If a property is defined both programmatically and in XML,
     * the value defined programmatically has priority
     *
     * @return Map whose key is the property key and the value the property value
     */
    Map&lt;String, String&gt; getProperties();
}</pre></div></div><p>The requested provider implementation is resolved according to the
      following rules in the following order:</p><div class="itemizedlist"><ul type="disc"><li><p>Use the provider implementation requested if
          <tt class="classname">Configuration</tt> has been created from
          <tt class="classname">Validation.byProvider(Class)</tt>.</p></li><li><p>Use the provider implementation described in the XML
          configuration (under
          <tt class="literal">validation-config.default-provider</tt> see <a href="#xml-config" title="5.5.6.&nbsp;XML Configuration: META-INF/validation.xml">Section&nbsp;5.5.6, &#8220;XML Configuration: META-INF/validation.xml&#8221;</a>) if defined: the value of this element is the
          fully qualified class name of the
          <tt class="classname">ValidationProvider</tt> implementation uniquely
          identifying the provider.</p></li><li><p>Use the first provider implementation returned by
          <tt class="classname">validationProviderResolver.getValidationProviders()</tt>.</p></li></ul></div><p>The <tt class="classname">ValidationProviderResolver</tt> is specified
      when <tt class="classname">Configuration</tt> instances are created (see
      <tt class="classname">ValidationProvider</tt>). If no
      <tt class="classname">ValidationProviderResolver</tt> instance has been
      specified, the default <tt class="classname">ValidationProviderResolver</tt>
      is used.</p><p><tt class="classname">Configuration</tt> instances are provided to the
      Bean Validation client through the <tt class="classname">Validation</tt>
      methods. <tt class="classname">Configuration</tt> instances are created by
      <tt class="classname">ValidationProvider</tt>.</p><p>If a problem occurs while building the
      <tt class="classname">ValidationFactory</tt>, a
      <tt class="classname">ValidationException</tt> is raised. This can be due to
      various reasons including:</p><div class="itemizedlist"><ul type="disc"><li><p>malformed XML configuration</p></li><li><p>malformed XML mapping</p></li><li><p>inability to find the provider (or a provider)</p></li><li><p>inability to instantiate extension classes provided in the XML
          configuration</p></li><li><p>inconsistent XML mapping (entity declared more than once,
          incorrect field etc).</p></li><li><p>invalid constraint declaration or definition</p></li></ul></div><p>Other exception causes may occur.</p><p>Here is an example of <tt class="classname">Configuration</tt>
      use.</p><div class="example"><a name="d0e6760"></a><p class="title"><b>Example&nbsp;5.26.&nbsp;Use Configuration</b></p><pre class="programlisting">Configuration&lt;?&gt; configuration = ...
ValidatorFactory factory = configuration
              .messageInterpolator( new WBMessageInterpolator() )
              .traversableResolver( new JPAAwareTraversableResolver() )
              .buildValidatorFactory();</pre></div><div class="added"><p>The following shows an example of setting up
      a <tt class="classname">Configuration</tt>, retrieving a validator factory
      from it, subsequently altering the configuration and then retrieving
      another factory:</p></div><div class="added"><div class="example"><a name="using-configuration-several-times"></a><p class="title"><b>Example&nbsp;5.27.&nbsp;Using Configuration to create several validator
        factories</b></p><pre class="programlisting">Configuration&lt;?&gt; configuration = ...
ValidatorFactory factory1 = configuration
              .messageInterpolator( new WBMessageInterpolator() )
              .buildValidatorFactory();

ValidatorFactory factory2 = configuration
              .traversableResolver( new JPAAwareTraversableResolver() )
              .buildValidatorFactory();</pre></div></div><div class="added"><p>Here, <tt class="varname">factory1</tt> is set up
      using a custom message interpolator, while <tt class="varname">factory2</tt>
      is set up using the same message interpolator and additionally using a
      custom traversable resolver.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6783"></a>5.5.4.&nbsp;ValidationProvider and ValidationProviderResolver</h3></div></div><div></div></div><p><tt class="classname">ValidationProvider</tt> is the contract between
      the bootstrap process and a specific Bean Validation provider.
      <tt class="classname">ValidationProviderResolver</tt> implements the
      discovery mechanism for Bean Validation provider implementations. Any
      Bean Validation client can implement such a discovery mechanism but it
      is typically implemented by containers having specific classloader
      structures and restrictions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6793"></a>5.5.4.1.&nbsp;ValidationProviderResolver</h4></div></div><div></div></div><p><tt class="classname">ValidationProviderResolver</tt> returns the
        list of Bean Validation providers available at runtime and more
        specifically a <tt class="classname">ValidationProvider</tt> instance for
        each provider available in the context. This service can be customized
        by implementing <tt class="classname">ValidationProviderResolver</tt>.
        Implementations must be thread-safe.</p><div class="example"><a name="d0e6806"></a><p class="title"><b>Example&nbsp;5.28.&nbsp;ValidationProviderResolver</b></p><pre class="programlisting">/**
 * Determines the list of Bean Validation providers available in the runtime environment
 * &lt;p/&gt;
 * Bean Validation providers are identified by the presence of
 * META-INF/services/javax.validation.spi.ValidationProvider
 * files following the Service Provider pattern described
 * &lt;a href="http://java.sun.com/j2se/1.5.0/docs/guide/jar/jar.html#Service%20Provider"&gt;here&lt;/a&gt;
 * &lt;p/&gt;
 * Each META-INF/services/javax.validation.spi.ValidationProvider file contains the list of
 * &lt;code&gt;ValidationProvider&lt;/code&gt; implementations each of them representing a provider.
 * &lt;p/&gt;
 * Implementations must be thread-safe.
 *
 * @author Emmanuel Bernard
 */
public interface ValidationProviderResolver {
    /**
     * Returns a list of ValidationProviders available in the runtime environment.
     *
     * @return list of validation providers.
     */
    List&lt;ValidationProvider&lt;?&gt;&gt; getValidationProviders();
}</pre></div><p>By default, providers are resolved using the Service Provider
        pattern described in <a href="http://java.sun.com/j2se/1.5.0/docs/guide/jar/jar.html#Service%20Provider" target="_top">http://java.sun.com/j2se/1.5.0/docs/guide/jar/jar.html#Service%20Provider</a>.
        Bean Validation providers must supply a service provider configuration
        file by creating a text file
        <tt class="filename">javax.validation.spi.ValidationProvider</tt> and
        placing it in the <tt class="filename">META-INF/services</tt> directory of
        one of its jar files. The content of the file should contain the name
        of the provider implementation class of the
        <tt class="classname">javax.validation.spi.ValidationProvider</tt>
        interface.</p><p>Bean Validation provider jars may be installed or made available
        in the same ways as other service providers, e.g. as extensions or
        added to the application classpath according to the guidelines in the
        JAR file specification.</p><p>The default <tt class="classname">ValidationProviderResolver</tt>
        implementation will locate all the Bean Validation providers by their
        provider configuration files visible in the classpath. The default
        <tt class="classname">ValidationProviderResolver</tt> implementation is
        recommended and custom
        <tt class="classname">ValidationProviderResolver</tt> implementations
        should be rarely used. A typical use of a custom resolution is
        resolving providers in a classloader constrained container like OSGi
        or in a tool environment (IDE).</p><p>The default <tt class="classname">ValidationProviderResolver</tt>
        can be accessed via
        <tt class="classname">BootStrapState.getDefaultValidationProviderResolver()</tt>.
        This method is typically used by the Bean Validation provider
        <tt class="classname">Configuration</tt> implementation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id-bootstrap-validationprovider"></a>5.5.4.2.&nbsp;ValidationProvider</h4></div></div><div></div></div><p><tt class="classname">ValidationProvider</tt> represents the SPI
        (Service Provider Interface) defining the contract between the
        provider discovery and initialization mechanism, and the provider. A
        <tt class="classname">ValidationProvider</tt> does:</p><div class="itemizedlist"><ul type="disc"><li><p>Provide a generic <tt class="classname">Configuration</tt>
            implementation (i.e. not tied to a given provider).</p></li><li><p>Provide a provider specific
            <tt class="classname">Configuration</tt> implementation. This
            <tt class="classname">Configuration</tt> will specifically build
            <tt class="classname">ValidatorFactory</tt> instances of the provider
            it comes from.</p></li><li><p>Build a <tt class="classname">ValidatorFactory</tt> object from
            the configuration provided by
            <tt class="classname">ConfigurationState</tt>.</p></li></ul></div><div class="example"><a name="d0e6887"></a><p class="title"><b>Example&nbsp;5.29.&nbsp;ValidationProvider</b></p><pre class="programlisting">package javax.validation.spi;

/**
 * Contract between the validation bootstrap mechanism and the provider engine.
 * &lt;p/&gt;
 * Implementations must have a public no-arg constructor. The construction of a provider
 * should be as "lightweight" as possible.
 *
 * &lt;code&gt;T&lt;/code&gt; represents the provider specific Configuration subclass
 * which typically host provider's additional configuration methods.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ValidationProvider&lt;T extends Configuration&lt;T&gt;&gt; {

    /**
     * Returns a &lt;code&gt;Configuration&lt;/code&gt; instance implementing &lt;code&gt;T&lt;/code&gt;,
     * the &lt;code&gt;Configuration&lt;/code&gt; subinterface.
     * The returned &lt;code&gt;Configuration&lt;/code&gt; instance must use the current provider
     * (&lt;code&gt;this&lt;/code&gt;) to build the &lt;code&gt;ValidatorFactory&lt;/code&gt; instance.
     * &lt;p/&gt;
     *
     * @param state bootstrap state
     *
     * @return specific Configuration implementation
     */
    T createSpecializedConfiguration(BootstrapState state);

    /**
     * Returns a &lt;code&gt;Configuration&lt;/code&gt; instance. This instance is not bound to
     * use the current provider. The choice of provider follows the algorithm described
     * in {@link javax.validation.Configuration}
     * &lt;p/&gt;
     * The &lt;code&gt;ValidationProviderResolver&lt;/code&gt; used by &lt;code&gt;Configuration&lt;/code&gt;
     * is provided by &lt;code&gt;state&lt;/code&gt;.
     * If null, the default &lt;code&gt;ValidationProviderResolver&lt;/code&gt; is used.
     *
     * @param state bootstrap state
     *
     * @return Non specialized Configuration implementation
     */
    Configuration&lt;?&gt; createGenericConfiguration(BootstrapState state);

    /**
     * Build a &lt;code&gt;ValidatorFactory&lt;/code&gt; using the current provider implementation.
     * The &lt;code&gt;ValidatorFactory&lt;/code&gt; is assembled and follows the configuration passed
     * via &lt;code&gt;ConfigurationState&lt;/code&gt;.
     * &lt;p&gt;
     * The returned &lt;code&gt;ValidatorFactory&lt;/code&gt; is properly initialized and ready for use.
     * &lt;/p&gt;
     *
     * @param configurationState the configuration descriptor
     *
     * @return the instanciated ValidatorFactory
     * @throws javax.validation.ValidationException if the ValidatorFactory cannot be built
     */
    ValidatorFactory buildValidatorFactory(ConfigurationState configurationState);
}</pre></div><div class="example"><a name="d0e6892"></a><p class="title"><b>Example&nbsp;5.30.&nbsp;BootstrapState interface</b></p><pre class="programlisting">package javax.validation.spi;

/**
 * Defines the state used to bootstrap the &lt;code&gt;Configuration&lt;/code&gt;
 *
 * @author Emmanuel Bernard
 * @author Sebastian Thomschke 
 */
public interface BootstrapState {
    /**
     * User defined &lt;code&gt;ValidationProviderResolver&lt;/code&gt; strategy
     * instance or &lt;code&gt;null&lt;/code&gt; if undefined.
     *
     * @return ValidationProviderResolver instance or null
     */
    ValidationProviderResolver getValidationProviderResolver();

    /**
     * Specification default &lt;code&gt;ValidationProviderResolver&lt;/code&gt;
     * strategy instance.
     * 
     * @return default implementation of ValidationProviderResolver
     */
    ValidationProviderResolver getDefaultValidationProviderResolver();
}</pre></div><p>A client can request a specific Bean Validation provider by
        using <tt class="classname">&lt;T extends Configuration&lt;T&gt;, U extends
        ValidationProvider&lt;T&gt;&gt;
        Validation.byProvider(Class&lt;U&gt;)</tt> or by defining the
        provider in the XML configuration file. The key uniquely identifying a
        Bean Validation provider is the
        <tt class="classname">ValidationProvider</tt> implementation specific to
        this provider.</p><p>A <tt class="classname">ValidationProvider</tt> implementation is
        linked (via it's generic parameter) to a specific sub interface of
        <tt class="classname">Configuration</tt>. The Bean Validation bootstrap
        API makes use of this link to return the specific Configuration
        subinterface implementation in a type-safe way when a specific
        provider is requested. The sub interface does not have to add any new
        method but is the natural holder for provider specific configuration
        methods.</p><div class="example"><a name="d0e6913"></a><p class="title"><b>Example&nbsp;5.31.&nbsp;Example of provider specific Configuration sub
          interface</b></p><pre class="programlisting">/**
 * Unique identifier of the ACME provider
 * also hosts some provider specific configuration methods
 */
public interface ACMEConfiguration 
    extends Configuration&lt;ACMEConfiguration&gt; {

    /**
     * Enables constraints implementation dynamic reloading when using ACME
     * default to false
     */
    ACMEConfiguration enableDynamicReloading(boolean);

}

/**
 * ACME validation provider
 * Note how ACMEConfiguration and ACMEProvider are linked together 
 * via the generic parameter.
 */
public class ACMEProvider implements ValidationProvider&lt;ACMEConfiguration&gt; {
    ...
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><tt class="classname">Configuration</tt> references itself in the
          generic definition. Methods of <tt class="classname">Configuration</tt>
          will return the <tt class="classname">ACMEConfiguration</tt> making the
          API easy to use even for vendor specific extensions.</p></div><p>The provider discovery mechanism uses the following
        algorithm:</p><div class="itemizedlist"><ul type="disc"><li><p>Retrieve available providers using
            <tt class="methodname">ValidationProviderResolver.getValidationProviders()</tt>.</p></li><li><p>The first <tt class="classname">ValidationProvider</tt> matching
            the requested provider is returned. Providers are evaluated in the
            order they are returned by
            <tt class="classname">ValidationProviderResolver</tt>. A provider
            instance is considered matching if it is assignable to the
            requested provider class.</p></li></ul></div><p>When the default Bean Validation provider is requested, the
        first <tt class="classname">ValidationProvider</tt> returned by the
        <tt class="classname">ValidationProviderResolver</tt> strategy is
        returned.</p><p>Every Bean Validation provider must provide a
        <tt class="classname">ValidationProvider</tt> implementation containing a
        public no-arg constructor and add the corresponding
        <tt class="filename">META-INF/services/javax.validation.spi.ValidationProvider</tt>
        file descriptor in one of its jars.</p><p>If a problem occurs while building the
        <tt class="classname">ValidationFactory</tt>, a
        <tt class="classname">ValidationException</tt> is raised. This can be due
        to various reasons including:</p><div class="itemizedlist"><ul type="disc"><li><p>malformed XML mapping</p></li><li><p>inability to find the provider (or a provider)</p></li><li><p>inability to instantiate extension classes provided in the
            XML configuration</p></li><li><p>inconsistent XML mapping (entity declared more than once,
            incorrect field etc).</p></li><li><p>invalid constraint declaration or definition</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="boostrapping-validation"></a>5.5.5.&nbsp;Validation</h3></div></div><div></div></div><p>The <tt class="classname">Validation</tt> class is the entry point
      used to bootstrap Bean Validation providers. The first entry point,
      <tt class="methodname">buildDefaultValidatorFactory()</tt>, is considered
      to be the default <tt class="classname">ValidatorFactory</tt> and is
      equivalent to the <tt class="classname">ValidatorFactory</tt> returned by
      <tt class="code">Validation.byDefaultProvider().configure().buildValidatorFactory()</tt>.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Should the resolver strategy be configurable by XML</p></div><div class="example"><a name="d0e7010"></a><p class="title"><b>Example&nbsp;5.32.&nbsp;Validation methods available</b></p><pre class="programlisting">/**
 * This class is the entry point for Bean Validation. There are three ways
 * to bootstrap it:
 * &lt;ul&gt;
 * &lt;li&gt;
 * The easiest approach is to build the default &lt;code&gt;ValidatorFactory&lt;/code&gt;.
 * &lt;pre&gt;{@code ValidatorFactory factory = Validation.buildDefaultValidatorFactory();}&lt;/pre&gt;
 * In this case, the default validation provider resolver
 * will be used to locate available providers.
 * The chosen provider is defined as followed:
 * &lt;ul&gt;
 * &lt;li&gt;if the XML configuration defines a provider, this provider is used&lt;/li&gt;
 * &lt;li&gt;if the XML configuration does not define a provider or if no XML configuration
 * is present the first provider returned by the 
 * &lt;code&gt;ValidationProviderResolver&lt;/code&gt; instance is used.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/li&gt;
 * &lt;li&gt;
 * The second bootstrap approach allows to choose a custom
 * &lt;code&gt;ValidationProviderResolver&lt;/code&gt;. The chosen
 * &lt;code&gt;ValidationProvider&lt;/code&gt; is then determined in the same way
 * as in the default bootstrapping case (see above).
 * &lt;pre&gt;{@code
 * Configuration&lt;?&gt; configuration = Validation
 *    .byDefaultProvider()
 *    .providerResolver( new MyResolverStrategy() )
 *    .configure();
 * ValidatorFactory factory = configuration.buildValidatorFactory();}
 * &lt;/pre&gt;
 * &lt;/li&gt;
 * &lt;li&gt;
 * The third approach allows you to specify explicitly and in
 * a type safe fashion the expected provider.
 * &lt;p/&gt;
 * Optionally you can choose a custom &lt;code&gt;ValidationProviderResolver&lt;/code&gt;.
 * &lt;pre&gt;{@code
 * ACMEConfiguration configuration = Validation
 *    .byProvider(ACMEProvider.class)
 *    .providerResolver( new MyResolverStrategy() )  // optionally set the provider resolver
 *    .configure();
 * ValidatorFactory factory = configuration.buildValidatorFactory();}
 * &lt;/pre&gt;
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * Note:&lt;br/&gt;
 * &lt;ul&gt;
 * &lt;li&gt;
 * The &lt;code&gt;ValidatorFactory&lt;/code&gt; object built by the bootstrap process should be cached
 * and shared amongst &lt;code&gt;Validator&lt;/code&gt; consumers.
 * &lt;/li&gt;
 * &lt;li&gt;
 * This class is thread-safe.
 * &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public class Validation {

    /**
     * Build and return a &lt;code&gt;ValidatorFactory&lt;/code&gt; instance based on the
     * default Bean Validation provider and following the XML configuration.
     * &lt;p/&gt;
     * The provider list is resolved using the default validation provider resolver
     * logic.
     * &lt;p/&gt; The code is semantically equivalent to
     * &lt;code&gt;Validation.byDefaultProvider().configure().buildValidatorFactory()&lt;/code&gt;
     *
     * @return &lt;code&gt;ValidatorFactory&lt;/code&gt; instance.
     *
     * @throws ValidationException if the ValidatorFactory cannot be built
     */
    public static ValidatorFactory buildDefaultValidatorFactory() {
        [...]
    }

    /**
     * Build a &lt;code&gt;Configuration&lt;/code&gt;. The provider list is resolved
     * using the strategy provided to the bootstrap state.
     * &lt;pre&gt;
     * Configuration&amp;lt?&amp;gt; configuration = Validation
     *    .byDefaultProvider()
     *    .providerResolver( new MyResolverStrategy() )
     *    .configure();
     * ValidatorFactory factory = configuration.buildValidatorFactory();
     * &lt;/pre&gt;
     * The provider can be specified in the XML configuration. If the XML
     * configuration does not exsist or if no provider is specified,
     * the first available provider will be returned.
     *
     * @return instance building a generic &lt;code&gt;Configuration&lt;/code&gt;
     *         compliant with the bootstrap state provided.
     */
    public static GenericBootstrap byDefaultProvider() {
        [...]
    }

    /**
     * Build a &lt;code&gt;Configuration&lt;/code&gt; for a particular provider implementation.
     * Optionally overrides the provider resolution strategy used to determine the provider.
     * &lt;p/&gt;
     * Used by applications targeting a specific provider programmatically.
     * &lt;p/&gt;
     * &lt;pre&gt;
     * ACMEConfiguration configuration =
     *     Validation.byProvider(ACMEProvider.class)
     *             .providerResolver( new MyResolverStrategy() )
     *             .configure();
     * &lt;/pre&gt;,
     * where &lt;code&gt;ACMEConfiguration&lt;/code&gt; is the
     * &lt;code&gt;Configuration&lt;/code&gt; sub interface uniquely identifying the
     * ACME Bean Validation provider. and &lt;code&gt;ACMEProvider&lt;/code&gt; is the
     * &lt;code&gt;ValidationProvider&lt;/code&gt; implementation of the ACME provider.
     *
     * @param providerType the &lt;code&gt;ValidationProvider&lt;/code&gt; implementation type
     *
     * @return instance building a provider specific &lt;code&gt;Configuration&lt;/code&gt;
     *         sub interface implementation.
     */
    public static &lt;T extends Configuration&lt;T&gt;, U extends ValidationProvider&lt;T&gt;&gt;
            ProviderSpecificBootstrap&lt;T&gt; byProvider(Class&lt;U&gt; providerType) {
        [...]
    }

    [...]
}</pre></div><p>The second entry point lets the client provide a custom
      <tt class="classname">ValidationProviderResolution</tt> instance. This
      instance is passed to <tt class="classname">GenericBootstrap</tt>.
      <tt class="classname">GenericBootstrap</tt> builds a generic
      <tt class="classname">Configuration</tt> using the first
      <tt class="classname">ValidationProvider</tt> returned by
      <tt class="classname">ValidationProviderResolution</tt> and calling
      <tt class="code">ValidationProvider.createGenericConfiguration(BootstrapState
      state)</tt>. <tt class="classname">BootstrapState</tt> holds the
      <tt class="classname">ValidationProviderResolution</tt> instance passed to
      <tt class="classname">GenericBootstrap</tt> and will be used by the
      <tt class="classname">Configuration</tt> instance when resolving the
      provider to use. Note that
      <tt class="code">ValidationProvider.createGenericConfiguration</tt> returns a
      <tt class="classname">Configuration</tt> object not bound to any particular
      provider.</p><div class="example"><a name="d0e7056"></a><p class="title"><b>Example&nbsp;5.33.&nbsp;GenericBootstrap interface</b></p><pre class="programlisting">package javax.validation.bootstrap;

/**
 * Defines the state used to bootstrap Bean Validation and
 * creates a provider agnostic &lt;code&gt;Configuration&lt;/code&gt;.
 *
 * @author Emmanuel Bernard
 */
public interface GenericBootstrap {
    /**
     * Defines the provider resolution strategy.
     * This resolver returns the list of providers evaluated
     * to build the &lt;code&gt;Configuration&lt;/code&gt;
     * &lt;p/&gt;
     * If no resolver is defined, the default &lt;code&gt;ValidationProviderResolver&lt;/code&gt;
     * implementation is used.
     *
     * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern
     */
    GenericBootstrap providerResolver(ValidationProviderResolver resolver);

    /**
     * Returns a generic &lt;code&gt;Configuration&lt;/code&gt; implementation.
     * At this stage the provider used to build the &lt;code&gt;ValidatorFactory&lt;/code&gt; 
     * is not defined.
     * &lt;p/&gt;
     * The &lt;code&gt;Configuration&lt;/code&gt; implementation is provided by the first provider 
     * returned by the &lt;code&gt;ValidationProviderResolver&lt;/code&gt; strategy.
     *
     * @return a Configuration implementation compliant with the bootstrap state
     * @throws javax.validation.ValidationException if the Configuration object cannot be built
     *                        this is generally due to an issue with the ValidationProviderResolver
     */
    Configuration&lt;?&gt; configure();
}</pre></div><p>The last entry point lets the client define the specific Bean
      Validation provider requested as well as a custom
      <tt class="classname">ValidationProviderResolver</tt> implementation if
      needed. The entry point method,
      <tt class="methodname">Validation.byProvider(Class&lt;U&gt;
      providerType)</tt>, takes the provider specific
      <tt class="classname">ValidationProvider</tt> implementation type and
      returns a <tt class="classname">ProviderSpecificBootstrap</tt> object that
      guarantees to return an instance of the specific
      <tt class="classname">Configuration</tt> sub interface. Thanks to the use of
      generics, the client API does not have to cast to the
      <tt class="classname">Configuration</tt> sub interface.</p><p>A <tt class="classname">ProviderSpecificBootstrap</tt> object can
      optionally receive a <tt class="classname">ValidationProviderResolver</tt>
      instance.</p><div class="example"><a name="d0e7089"></a><p class="title"><b>Example&nbsp;5.34.&nbsp;ProviderSpecificBootstrap interface</b></p><pre class="programlisting">package javax.validation.bootstrap;

/**
 * Defines the state used to bootstrap Bean Validation and
 * creates a provider specific &lt;code&gt;Configuration&lt;/code&gt;
 * of type&lt;code&gt;T&lt;/code&gt;.
 * &lt;p/&gt;
 * The specific &lt;code&gt;Configuration&lt;/code&gt; is linked to the provider via the generic
 * parameter of the &lt;code&gt;ValidationProvider&lt;/code&gt; implementation.
 * &lt;p/&gt;
 * The requested provider is the first provider instance assignable to
 * the requested provider type (known when &lt;code&gt;ProviderSpecificBootstrap&lt;/code&gt; is built).
 * The list of providers evaluated is returned by {@link ValidationProviderResolver}.
 * If no &lt;code&gt;ValidationProviderResolver&lt;/code&gt; is defined, the
 * default &lt;code&gt;ValidationProviderResolver&lt;/code&gt; strategy is used.
 *
 * @author Emmanuel Bernard
 */
public interface ProviderSpecificBootstrap&lt;T extends Configuration&lt;T&gt;&gt; {

    /**
     * Optionally defines the provider resolver implementation used.
     * If not defined, use the default &lt;code&gt;ValidationProviderResolver&lt;/code&gt;
     *
     * @param resolver &lt;code&gt;ValidationProviderResolver&lt;/code&gt; implementation used
     *
     * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern
     */
    public ProviderSpecificBootstrap&lt;T&gt; providerResolver(ValidationProviderResolver resolver);

    /**
     * Determines the provider implementation suitable for &lt;code&gt;T&lt;/code&gt; and delegates
     * the creation of this specific &lt;code&gt;Configuration&lt;/code&gt; subclass to the provider.
     *
     * @return &lt;code&gt;Configuration&lt;/code&gt; sub interface implementation
     * @throws javax.validation.ValidationException if the Configuration object cannot be built
     *                        this is generally due to an issue with the ValidationProviderResolver
     */
    public T configure();
}</pre></div><p><tt class="methodname">ProviderSpecificBootstrap.configure()</tt>
      must return the result of
      <tt class="methodname">ValidationProvider.createSpecializedConfiguration(BootstrapState
      state)</tt>. The state parameter holds the
      <tt class="classname">ValidationProviderResolver</tt> passed to
      <tt class="classname">ProviderSpecificBootstrap</tt>. The validation
      provider instance used is the one assignable to the type passed as a
      parameter in <tt class="methodname">Validation.byProvider(Class)</tt>. The
      validation provider is selected according to the algorithm described in
      (<a href="#id-bootstrap-validationprovider" title="5.5.4.2.&nbsp;ValidationProvider">Section&nbsp;5.5.4.2, &#8220;ValidationProvider&#8221;</a>).</p><p>The <tt class="classname">Validation</tt> implementation must not
      contain any non private attribute or method aside from the three public
      static bootstrap methods:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">public static ValidatorFactory
          buildDefaultValidatorFactory()</tt></p></li><li><p><tt class="methodname">public static GenericBootstrap
          byDefaultProvider()</tt></p></li><li><p><tt class="methodname">public static &lt;T extends
          Configuration&lt;T&gt;, U extends ValidationProvider&lt;T&gt;&gt;
          ProviderSpecificBootstrap&lt;T&gt; byProvider(Class&lt;U&gt;
          providerType)</tt></p></li></ul></div><p>The bootstrap API is designed to allow complete portability
      amongst Bean Validation provider implementations. The bootstrap
      implementation must ensure it can bootstrap third party
      providers.</p><p>When building the <tt class="classname">Configuration</tt> object, if
      the <tt class="classname">ValidationProviderResolver</tt> either fail or if
      the expected provider is not found, a
      <tt class="classname">ValidationException</tt> is raised.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml-config"></a>5.5.6.&nbsp;XML Configuration: META-INF/validation.xml</h3></div></div><div></div></div><p>Unless explicitly ignored by calling
      <tt class="classname">Configuration.ignoreXMLConfiguration()</tt>, a
      <tt class="classname">Configuration</tt> takes into account the
      configuration available in <tt class="filename">META-INF/validation.xml</tt>.
      This configuration file is optional but can be used by applications to
      refine some of the Bean Validation behavior. If more than one
      <tt class="filename">META-INF/validation.xml</tt> file is found in the
      classpath, a <tt class="classname">ValidationException</tt> is
      raised.</p><div class="added"><p>Implementations supporting Bean Validation
      1.1 must properly parse deployment descriptors of Bean Validation 1.0
      and 1.1.</p></div><p>Unless stated otherwise, XML based configuration settings are
      overridden by values explicitly set via the
      <tt class="classname">Configuration</tt> API. For example, the
      <tt class="classname">MessageInterpolator</tt> defined via
      <tt class="methodname">Configuration.messageInterpolator(MessageInterpolator)</tt>
      has priority over the <tt class="literal">message-interpolator</tt>
      definition.</p><p><tt class="literal">default-provider</tt>: represents the class name of
      the provider specific <tt class="classname">ValidationProvider</tt>
      implementation class. If defined, the specific provider is used (unless
      a specific provider has been chosen via the programmatic
      approach).</p><p><tt class="literal">message-interpolator</tt>: represents the fully
      qualified class name of the <tt class="classname">MessageInterpolator</tt>
      implementation. When defined in XML, the implementation must have a
      public no-arg constructor. This element is optional.</p><p><tt class="literal">traversable-resolver</tt>: represents the fully
      qualified class name of the <tt class="classname">TraversableResolver</tt>
      implementation. When defined in XML, the implementation must have a
      public no-arg constructor. This element is optional.</p><p><tt class="literal">constraint-validator-factory</tt>: represents the
      fully qualified class name of the
      <tt class="classname">ConstraintValidatorFactory</tt> implementation. When
      defined in XML, the implementation must have a public no-arg
      constructor. This element is optional.</p><div class="added"><p><tt class="literal">parameter-name-provider</tt>:
      represents the fully qualified class name of the
      <tt class="classname">ParameterNameProvider</tt> implementation. When
      defined in XML, the implementation must have a public no-arg
      constructor. This element is optional.</p></div><p><tt class="literal">constraint-mapping</tt>: represents the resource
      path of an XML mapping file. More than one
      <tt class="literal">constraint-mapping</tt> element can be present. Mappings
      provided via
      <tt class="methodname">Configuration.addMapping(InputStream)</tt> are added
      to the list of mappings described via
      <tt class="literal">constraint-mapping</tt>.</p><p><tt class="literal">property</tt>: represents a key/value pair property
      providing room to provider specific configurations. Vendors should use
      vendor namespaces for properties (e.g.,
      <tt class="literal">com.acme.validation.logging</tt>). Entries that make use
      of the namespace <tt class="literal">javax.validation</tt> and its
      subnamespaces must not be used for vendor-specific information. The
      namespace <tt class="literal">javax.validation</tt> is reserved for use by
      this specification. Properties defined via
      <tt class="methodname">Configuration.addProperty(String, String)</tt> are
      added to the properties defined via <tt class="literal">property</tt>. If a
      property with the same name are defined in both XML and via the
      programmatic API, the value provided via programmatic API has
      priority.</p><p>If a public no-arg constructor is missing, a
      <tt class="classname">ValidationException</tt> is raised during the
      <tt class="methodname">Configuration.buildValidatorFactory()</tt>
      call.</p><div class="changed"><div class="example"><a name="d0e7254"></a><p class="title"><b>Example&nbsp;5.35.&nbsp;Example of META-INF/validation.xml file</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;validation-config
        xmlns="http://jboss.org/xml/ns/javax/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/configuration validation-configuration-1.1.xsd"
        version="1.1"&gt;
    &lt;default-provider&gt;com.acme.ACMEProvider&lt;/default-provider&gt;
    &lt;message-interpolator&gt;com.acme.ACMEAwareMessageInterpolator&lt;/message-interpolator&gt;

    &lt;constraint-mapping&gt;META-INF/validation/order-constraints.xml&lt;/constraint-mapping&gt;
    &lt;constraint-mapping&gt;META-INF/validation/catalog-constraints.xml&lt;/constraint-mapping&gt;
    &lt;constraint-mapping&gt;META-INF/validation/customer-constraints.xml&lt;/constraint-mapping&gt;

    &lt;property name="com.acme.validation.logging"&gt;WARN&lt;/property&gt;
    &lt;property name="com.acme.validation.safetyChecking"&gt;failOnError&lt;/property&gt;

&lt;/validation-config&gt;</pre></div></div><p>The XML schema is described in <a href="#xml-config-xsd" title="8.2.&nbsp;Configuration schema">Section&nbsp;8.2, &#8220;Configuration schema&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="bootstrapping-usageandcontainerexpectation"></a>5.5.7.&nbsp;Bootstrapping considerations</h3></div></div><div></div></div><p>The Bean Validation bootstrap API can be used directly by any
      application or made available through a container or other framework. In
      all cases, the following rules apply:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">ValidatorFactory</tt> is a thread-safe
          object that should be built once per deployment unit</p></li><li><div class="added"><p><tt class="classname">ValidatorFactory</tt>
          should be closed when it is no longer needed (eg when the unit is
          undeployed or the server stopped).</p></div></li><li><p><tt class="classname">Validator</tt> is a thread-safe and
          lightweight object which can be cached by the
          <tt class="classname">ValidatorFactory</tt> instance.</p></li></ul></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="constraintmetadata"></a>Chapter&nbsp;6.&nbsp;Constraint metadata request APIs</h2></div></div><div></div></div><p>The Bean Validation specification provides a way to query the
  constraint repository. This API is expected to be used for tooling support
  as well as integration with other frameworks, libraries and JSRs. The Bean
  Validation specification aims to provide both a validation engine and a
  metadata repository for object constraints. Frameworks (EE or SE) in need
  for constraint definition, validation and metadata will be able to rely on
  the Bean Validation specification for these services avoiding any
  unnecessary duplication work from an application and infrastructure point of
  view.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7292"></a>6.1.&nbsp;Validator</h2></div></div><div></div></div><p>The main API to access all metadata related to a given object is
    <tt class="classname">Validator</tt> (see <a href="#bootstrapping" title="5.5.&nbsp;Bootstrapping">Section&nbsp;5.5, &#8220;Bootstrapping&#8221;</a> for
    more information on how to retrieve a <tt class="classname">Validator</tt>
    instance).</p><p>A <tt class="classname">Validator</tt> instance hosts the method to
    access to the metadata repository for a given class. It is recommended to
    leave the caching of <tt class="classname">Validator</tt> instances to the
    <tt class="classname">ValidatorFactory</tt>. <tt class="classname">Validator</tt>
    implementations are thread-safe.</p><div class="changed"><div class="example"><a name="d0e7319"></a><p class="title"><b>Example&nbsp;6.1.&nbsp;Validator interface (metadata request API)</b></p><pre class="programlisting">/**
 * Validate bean instances. Implementations of this interface must be thread-safe.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @author Gunnar Morling
 */
public interface Validator {

    [...] //See 5.1

    /**
     * Return the descriptor object describing bean constraints.
     * The returned object (and associated objects including
     * &lt;code&gt;ConstraintDescriptor&lt;code&gt;s) are immutable.
     *
     * @param clazz class or interface type evaluated
     *
     * @return the bean descriptor for the specified class.
     *
     * @throws IllegalArgumentException if clazz is null
     * @throws ValidationException if a non recoverable error happens
     *                             during the metadata discovery or if some
     *                             constraints are invalid.
     */
    BeanDescriptor getConstraintsForClass(Class&lt;?&gt; clazz);
}</pre></div></div><p><tt class="methodname">getConstraintsForClass</tt> returns a
    <tt class="classname">BeanDescriptor</tt> object describing the bean level
    constraints (see <a href="#constraintdeclarationvalidationprocess-requirements-object" title="4.1.1.&nbsp;Object validation">Section&nbsp;4.1.1, &#8220;Object validation&#8221;</a>)
    and providing access to the property level constraints metadata.</p><p>If a constraint definition or declaration hosted by the requested
    class (or any of it's superclasses and interfaces according to the
    constraint propagation rules) is invalid, a
    <tt class="classname">ValidationException</tt> is raised. This can be a
    subclass of <tt class="classname">ValidationException</tt> like
    <tt class="classname">ConstraintDefinitionException</tt>,
    <tt class="classname">ConstraintDeclarationException</tt>,
    <tt class="classname">UnexpectedTypeException</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintmetadata-elementdescriptor"></a>6.2.&nbsp;ElementDescriptor</h2></div></div><div></div></div><div class="changed"><p><tt class="classname">ElementDescriptor</tt> is
    the root interface describing elements hosting constraints. It is used to
    describe the list of constraints for a given element (whether it be a
    class, property, method etc.).</p></div><p><tt class="classname">ElementDescriptor</tt> lives in the
    <tt class="classname">javax.validation.metadata</tt> package.</p><div class="changed"><div class="example"><a name="d0e7364"></a><p class="title"><b>Example&nbsp;6.2.&nbsp;ElementDescriptor interface</b></p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a validated element (class, property, method etc.).
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 * @author Gunnar Morling
 */
public interface ElementDescriptor {

    /**
     * The kind of an {@link ElementDescriptor}.
     *
     * @author Gunnar Morling
     *
     */
    public enum Kind {

        /**
         * A Java Bean.
         */
        BEAN,

        /**
         * A property of a Java Bean.
         */
        PROPERTY,

        /**
         * A method.
         */
        METHOD,

        /**
         * A constructor.
         */
        CONSTRUCTOR,

        /**
         * A parameter of a method or constructor.
         */
        PARAMETER,

        /**
         * The return value of a method or constructor.
         */
        RETURN_VALUE;
    }

    /**
     * @return Return {@code true} if at least one constraint declaration is present
     * for this element in the class hierarchy, {@code false} otherwise.
     */
    boolean hasConstraints();

    /**
     * @return Statically defined returned type.
     */
    Class&lt;?&gt; getElementClass();

    /**
     * Return all constraint descriptors for this element in the class hierarchy
     * or an empty &lt;code&gt;Set&lt;/code&gt; if none are present.
     *
     * @return &lt;code&gt;Set&lt;/code&gt; of constraint descriptors for this element
     */
    Set&lt;ConstraintDescriptor&lt;?&gt;&gt; getConstraintDescriptors();

    /**
     * Find constraints and potentially restricts them to certain criteria.
     *
     * @return ConstraintFinder object.
     */
    ConstraintFinder findConstraints();

    /**
     * Returns the kind of this descriptor.
     * @return The kind of this descriptor.
     */
    Kind getKind();

    /**
     * Narrows the type of this descriptor down to the given type. The type
     * should be checked before by calling {@link ElementDescriptor#getKind()}.
     *
     * @param &lt;T&gt;
     *            The type to narrow down to.
     * @param descriptorType
     *            Class object representing the descriptor type to narrow down
     *            to.
     *
     * @return This descriptor narrowed down to the given type.
     *
     * @throws ClassCastException
     *             If this descriptor is not assignable to the type
     *             &lt;code&gt;T&lt;/code&gt;.
     */
    &lt;T extends ElementDescriptor&gt; T as(Class&lt;T&gt; descriptorType);

    /**
     * Declare restrictions on retrieved constraints.
     * Restrictions are cumulative.
     *
     * A &lt;code&gt;ConstraintFinder&lt;/code&gt; is not thread-safe. The set of matching
     * &lt;code&gt;ConstraintDescriptor&lt;/code&gt; is.
     */
    interface ConstraintFinder {
        /**
         * Restrict to the constraints matching a given set of groups for this element
         *
         * This method respects group conversion, group sequences
         * and group inheritance (including class-level {@code Default} group
         * overriding) but does not return {@code ConstraintDescriptor}s
         * in any particular order.
         * Specifically, ordering of the group sequence is not respected.
         *
         * @param groups groups targeted
         *
         * @return {@code this} following the chaining method pattern
         */
        ConstraintFinder unorderedAndMatchingGroups(Class&lt;?&gt;... groups);

        /**
         * Restrict to the constraints matching the provided scope for this element.
         *
         * Defaults to &lt;code&gt;Scope.HIERARCHY&lt;/code&gt;
         *
         * @param scope expected scope
         * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern
         */
        ConstraintFinder lookingAt(Scope scope);

        /**
         * Restrict to the constraints hosted on the listed &lt;code&gt;types&lt;/code&gt;
         * for a given element.
         *
         * Default to all possible types of the element.
         *
         * Typically used to restrict to fields (&lt;code&gt;FIELD&lt;/code&gt;)
         * or getters (&lt;code&gt;METHOD&lt;/code&gt;)
         *
         * @param types targeted types
         * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern
         */
        ConstraintFinder declaredOn(ElementType... types);

        /**
         * Retrieve the constraint descriptors following the defined
         * restrictions and hosted on the element described by
         * &lt;code&gt;ElementDescriptor&lt;/code&gt;
         *
         * @return matching constraint descriptors
         */
        Set&lt;ConstraintDescriptor&lt;?&gt;&gt; getConstraintDescriptors();

        /**
         * Returns &lt;code&gt;true&lt;/code&gt; if at least one constraint declaration
         * matching the restrictions is present on the element,
         * &lt;code&gt;false&lt;/code&gt; otherwise.
         *
         * @return is there any constraint
         */
        boolean hasConstraints();
    }
}</pre></div></div><pre class="programlisting">package javax.validation.metadata;

/**
 * Scope looked at when discovering constraints
 *
 * @author Emmanuel Bernard
 */
public enum Scope {
    /**
     * Look for constraints declared on the current class element
     * and ignore inheritance and elements with the same name in
     * the class hierarchy.
     */
    LOCAL_ELEMENT,

    /**
     * Look for constraints declared on all elements of the class hierarchy
     * with the same name.
     */
    HIERARCHY
}</pre><p><tt class="methodname">getElementClass</tt> returns either the object
    type for a class, or the returned type for a property.</p><p><tt class="classname">getConstraintDescriptors</tt> returns all the
    <tt class="classname">ConstraintDescriptor</tt>s (see <a href="#constraintmetadata-constraintdescriptor" title="6.9.&nbsp;ConstraintDescriptor">Section&nbsp;6.9, &#8220;ConstraintDescriptor&#8221;</a>) hosted on the given
    element in the class hierarchy, each
    <tt class="classname">ConstraintDescriptor</tt> describing one of the
    constraints declared on the given element.</p><p><tt class="methodname">hasConstraints</tt> returns true if the given
    element (class, field or property) in the class hierarchy holds at least
    one constraint declaration.</p><div class="added"><p><tt class="methodname">getKind</tt> returns the
    concrete type of the given element.</p></div><div class="added"><p>The method <tt class="methodname">as</tt> returns
    the given element casted down to one of the specific descriptor types,
    e.g. <tt class="classname">BeanDescriptor</tt>,
    <tt class="classname">PropertyDescriptor</tt> etc.</p></div><p>If you need to query the metadata API in a more fine grained way for
    example by restricting the constraints to the one described on fields or
    on getters or by restricting to a given set of groups, you can use the
    <tt class="classname">ConstraintFinder</tt> fluent API by calling
    <tt class="methodname">findConstraints</tt>.</p><p>Here is an example restricting the list of constraints on getters,
    matching the default group and declared physically on the
    <tt class="literal">name</tt> getter of <tt class="classname">Customer</tt> (and not
    any of the getters on the super classes).</p><div class="example"><a name="d0e7422"></a><p class="title"><b>Example&nbsp;6.3.&nbsp;Using the fluent API to restrict matching constraints</b></p><pre class="programlisting">public class User {
    @Size(max=50) 
    String getName() { ... }
    ...
}

public class Customer extends User {
    @NotNull
    String getName() { ... }
}

PropertyDescriptor pd = 
    validator.getConstraintsForClass(Customer.class).getConstraintsForProperty("name");
Set&lt;ConstraintDescriptor&lt;?&gt;&gt; constraints = 
    pd.findConstraints()
        .declaredOn(ElementType.METHOD)
        .unorderedAndMatchingGroups(Default.class)
        .lookingAt(Scope.LOCAL_ELEMENT)
            .getConstraintDescriptors();

assert 1 == constraints.size();

constraints = pd.getConstraintDescriptors();
//equivalent to pd.findConstraints()..getConstraintDescriptors();
assert 2 == constraints.size();      </pre></div><p><tt class="classname">unorderedAndMatchingGroups</tt> restricts to the
    <tt class="classname">ConstraintDescriptor</tt>s (see <a href="#constraintmetadata-constraintdescriptor" title="6.9.&nbsp;ConstraintDescriptor">Section&nbsp;6.9, &#8220;ConstraintDescriptor&#8221;</a>) matching the set of
    groups passed as parameters and present on the element. Order is not
    respected but group inheritance and inheritance via sequence (including
    the <tt class="classname">Default</tt> group overriding at the class level)
    are honored.</p><p><tt class="methodname">declaredOn</tt> lets you restrict the list of
    element types constraints are hosted on. This is particularly useful to
    retrieve constraints only hosted on fields
    (<tt class="classname">ElementType.FIELD</tt>) or only hosted on getters
    (<tt class="classname">ElementType.METHOD</tt>).</p><p><tt class="methodname">lookingAt</tt> lets you restrict which
    constraints are considered. Either constraints belonging to the element
    but hosted on the class represented by
    <tt class="classname">BeanDescritptor</tt>
    (<tt class="classname">Scope.LOCAL_ELEMENT</tt>), or constraints belonging to
    the element but hosted anywhere in the class hierarchy
    (<tt class="classname">Scope.HIERARCHY</tt>).</p><div class="added"><p><i><span class="remark">TODO: add examples for method level
    constraint filtering and see if the API fits.</span></i></p></div><div class="added"><p><i><span class="remark">TODO: Consider renaming
    <tt class="classname">ElementDescriptor$Kind</tt> to
    <tt class="classname">ElementType</tt> or <tt class="classname">Type</tt> and/or
    making it a top-level type. Currently
    <tt class="classname">ElementDescriptor$Type</tt> is being
    considered.</span></i></p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7480"></a>6.3.&nbsp;BeanDescriptor</h2></div></div><div></div></div><p>The <tt class="classname">BeanDescriptor</tt> interface describes a
    constrained Java Bean. This interface is returned by
    <tt class="methodname">Validator.getConstraintsForClass(Class&lt;?&gt;)</tt>.</p><div class="added"><i><span class="remark">TODO: With the introduction of method
    constraints BeanDescriptor isn't limited to "real" JavaBeans any more but
    it can represent any Java type.</span></i></div><p><tt class="classname">BeanDescriptor</tt> lives in the
    <tt class="classname">javax.validation.metadata</tt> package.</p><div class="changed"><div class="example"><a name="d0e7500"></a><p class="title"><b>Example&nbsp;6.4.&nbsp;BeanDescriptor interface</b></p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a constrained Java Bean and the constraints associated to it. All
 * objects returned by the methods of this descriptor (and associated objects
 * including {@code ConstraintDescriptor}s) are immutable.
 *
 * @author Emmanuel Bernard
 * @author Gunnar Morling
 */
public interface BeanDescriptor extends ElementDescriptor {
    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the bean involves validation:
     * &lt;ul&gt;
     * &lt;li&gt; a constraint is hosted on the bean itself &lt;/li&gt;
     * &lt;li&gt; a constraint is hosted on one of the bean properties&lt;/li&gt;
     * &lt;li&gt; or a bean property is marked for cascade (&lt;code&gt;@Valid&lt;/code&gt;)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the bean involves validation, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    boolean isBeanConstrained();

    /**
     * Return the property descriptor for a given property.
     * Return &lt;code&gt;null&lt;/code&gt; if the property does not exist or has no
     * constraint nor is marked as cascaded (see {@link #getConstrainedProperties()} )
     * &lt;p/&gt;
     *
     * @param propertyName property evaluated
     *
     * @return the property descriptor for a given property.
     *
     * @throws IllegalArgumentException if propertyName is null
     */
    PropertyDescriptor getConstraintsForProperty(String propertyName);

    /**
     * Returns a set of property descriptors having at least one constraint defined 
     * or marked as cascaded (&lt;code&gt;@Valid&lt;c/ode&gt;). If not property matches, 
     * an empty set is returned.
     */
    Set&lt;PropertyDescriptor&gt; getConstrainedProperties();

   /**
     * Returns a method descriptor for the given method. Returns {@code null} if
     * no method with the given name and parameter types exists or the specified
     * method neither has parameter or return value constraints nor a parameter
     * or return value marked for cascaded validation.
     *
     * @param methodName The name of the method.
     * @param parameterTypes The parameter types of the method.
     *
     * @return A method descriptor for the given method.
     *
     * @throws IllegalArgumentException if methodName is null
     */
    MethodDescriptor getConstraintsForMethod(String methodName, Class&lt;?&gt;... parameterTypes);

    /**
     * Returns a set with descriptors for the constrained methods of the type
     * represented by this descriptor. Constrained are all those methods which
     * have at least one parameter or return value constraint or at least one
     * parameter or return value marked for cascaded validation.
     *
     * @return A set with descriptors for the constrained methods of this type.
     *         Will be empty if this type has no constrained methods but never
     *         {@code null}.
     */
    Set&lt;MethodDescriptor&gt; getConstrainedMethods();

    /**
     * Returns a constructor descriptor for the given constructor. Returns
     * {@code null} if no constructor with the given parameter types exists or
     * the specified constructor neither has parameter or return value
     * constraints nor a parameter or return value marked for cascaded
     * validation.
     *
     * @param parameterTypes The parameter types of the constructor.
     *
     * @return A constructor descriptor for the given constructor.
     */
    ConstructorDescriptor getConstraintsForConstructor(Class&lt;?&gt;... parameterTypes);

    /**
     * Returns a set with descriptors for the constrained constructors of the
     * type represented by this descriptor. Constrained are all those
     * constructors which have at least one parameter or return value constraint
     * or at least one parameter or return value marked for cascaded validation.
     *
     * @return A set with descriptors for the constrained constructor of this
     *         type. Will be empty if this type has no constrained constructor
     *         but never {@code null}.
     */
    Set&lt;ConstructorDescriptor&gt; getConstrainedConstructors();
}</pre></div></div><p><tt class="methodname">isBeanConstrained</tt> returns true if the given
    class (and superclasses and interfaces) hosts at least one validation
    declaration (either constraint or <tt class="classname">@Valid</tt>
    annotation). If the method returns false, the Bean Validation engine can
    safely ignore the bean as it will not be impacted by validation.</p><div class="added"><p><i><span class="remark">TODO: Specify behavior with respect to
    method constraints, or add a dedicated method for that (see <a href="http://lists.jboss.org/pipermail/beanvalidation-dev/2012-January/000239.html" target="_top">http://lists.jboss.org/pipermail/beanvalidation-dev/2012-January/000239.html</a>)</span></i></p></div><p><tt class="methodname">getConstraintsForProperty</tt> returns a
    <tt class="classname">PropertyDescriptor</tt> object describing the property
    level constraints (See <a href="#constraintdeclarationvalidationprocess-requirements-property" title="4.1.2.&nbsp;Field and property validation">Section&nbsp;4.1.2, &#8220;Field and property validation&#8221;</a>).
    The property is uniquely identified by its name as per the JavaBeans
    convention: field level and getter level constraints of the given name are
    all returned.</p><p><tt class="methodname">getConstrainedProperties</tt> returns the
    <tt class="classname">PropertyDescriptor</tt>s of the bean properties having
    at least one constraint or being cascaded (<tt class="classname">@Valid</tt>
    annotation).</p><div class="added"><p><tt class="methodname">getConstraintsForMethod</tt>
    returns a <tt class="classname">MethodDescriptor</tt> object describing the
    method constraints of the given method. The method is uniquely identified
    by its name and the types of its parameters.</p></div><div class="added"><p><tt class="methodname">getConstrainedMethods</tt>
    returns the <tt class="classname">MethodDescriptor</tt>s of the methods having
    at least one constraint or cascaded parameter or return value.</p></div><div class="added"><p><tt class="methodname">getConstraintsForConstructor</tt>
    returns a <tt class="classname">ConstructorDescriptor</tt> ojbect describing
    the method constraints of the given constructor. The constructor is
    uniquely identified by its name and the types of its parameters.</p></div><div class="added"><p><tt class="methodname">getConstrainedConstructors</tt>
    returns the <tt class="classname">ConstructorDescriptor</tt>s of the
    constructors having at least one constraint or cascaded parameter or
    return value.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7565"></a>6.4.&nbsp;PropertyDescriptor</h2></div></div><div></div></div><p>The <tt class="classname">PropertyDescriptor</tt> interface describes a
    constrained property of a Java Bean.</p><p><tt class="classname">PropertyDescriptor</tt> lives in the
    <tt class="classname">javax.validation.metadata</tt> package.</p><p>This interface is returned by
    <tt class="methodname">BeanDescriptor.getConstraintsForProperty(String)</tt>
    or <tt class="methodname">BeanDescriptor.getConstrainedProperties</tt>.
    Constraints declared on the attribute and the getter of the same name
    according to the Java Bean rules are returned by this descriptor.</p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a Java Bean property hosting validation constraints.
 *
 * Constraints placed on the attribute and the getter of a given property
 * are all referenced.
 *
 * @author Emmanuel Bernard
 */
public interface PropertyDescriptor extends ElementDescriptor {
    /**
     * Is the property marked by the &lt;code&gt;@Valid&lt;/code&gt; annotation.
     * @return &lt;code&gt;true&lt;/code&gt; if the annotation is present, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    boolean isCascaded();

    /**
     * Name of the property acording to the Java Bean specification.
     * @return property name.
     */
    String getPropertyName();
}</pre><p>The <tt class="methodname">isCascaded</tt> method returns
    <tt class="literal">true</tt> if the property is marked with
    <tt class="classname">@Valid</tt>.</p><p><tt class="methodname">getPropertyName</tt> returns the property name
    as described in <a href="#validationapi-constraintviolation" title="5.2.&nbsp;ConstraintViolation">Section&nbsp;5.2, &#8220;ConstraintViolation&#8221;</a>.</p></div><div class="added"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7607"></a>6.5.&nbsp;MethodDescriptor</h2></div></div><div></div></div><p>The <tt class="classname">MethodDescriptor</tt> interface describes a
    constrained method of a Java type.</p><p><tt class="classname">MethodDescriptor</tt> lives in the
    <tt class="classname">javax.validation.metadata</tt> package.</p><p>This interface is returned by
    <tt class="methodname">BeanDescriptor#getConstraintsForMethod(String,
    Class&lt;?&gt;...)</tt> and
    <tt class="methodname">BeanDescriptor#getConstrainedMethods()</tt>.</p><pre class="programlisting">package javax.validation.metadata;

import java.util.List;

/**
 * Describes a validated method.
 *
 * @author Gunnar Morling
 * @author Emmanuel Bernard
 * @since 1.1
 */
public interface MethodDescriptor extends ElementDescriptor {

    /**
     * Returns the name of the method represented by this descriptor.
     *
     * @return The name of the method represented by this descriptor.
     */
    String getName();

    /**
     * &lt;p&gt;
     * Returns a list with descriptors for this method's parameters. The size of
     * this list corresponds to the number of this method's parameters.
     * &lt;/p&gt;
     *
     * @return A list with descriptors for this method's parameters. An empty
     *         list will be returned if this method has no parameters, but never
     *         {@code null}.
     */
    List&lt;ParameterDescriptor&gt; getParameterDescriptors();

    /**
     * Returns a descriptor for this method's return value.
     *
     * @return A descriptor for this method's return value or {@code null}
     *         if this method has no return value.
     */
    ReturnValueDescriptor getReturnValueDescriptor();

    /**
     * Returns {@code true} if the method parameters are constrained either:
     * &lt;ul&gt;
     * &lt;li&gt;because of a constraint on at least one of the parameters&lt;/li&gt;
     * &lt;li&gt;because of a cascade on at least one of the parameters (via {@code @Valid})&lt;/li&gt;
     * &lt;li&gt;because of at least one cross-parameter constraint&lt;/li&gt;
     * &lt;/ul&gt;
     * Also returns {@code false} if there is no parameter.
     *
     * @return true if the method parameters are constrained
     */
    boolean areParametersConstrained();

    /**
     * Returns {@code true} if the method return value is constrained either:
     * &lt;ul&gt;
     * &lt;li&gt;because of a constraint on the return value&lt;/li&gt;
     * &lt;li&gt;because validation is cascaded on the return value (via {@code @Valid})&lt;/li&gt;
     * &lt;/ul&gt;
     * Also returns {@code false} if there is no return value.
     *
     * @return true if the method return value is constrained
     */
    boolean isReturnValueConstrained();
}</pre><p><tt class="methodname">getName()</tt> returns the name of the
    represented method.</p><p><tt class="methodname">getParameterDescriptors</tt>() returns a list of
    <tt class="classname">ParameterDescriptor</tt>s representing the method's
    parameters in their natural order. An empty list will be returned in case
    the method has no parameters.</p><p><tt class="methodname">getReturnValueDescriptor()</tt> returns a
    descriptor for the method's return value or <tt class="varname">null</tt> if the
    method has no return value.</p><p><tt class="classname">isConstrainedOnParameters()</tt> returns true if
    any of the parameters is constrained or cascaded. Returns false if there
    is no parameter.</p><p><tt class="classname">isConstrainedOnReturnValue()</tt> returns true if
    the return value is constrained or cascaded. Returns false if there is no
    return value.</p><i><span class="remark">TODO: Consider overriding ElementDescriptor.hasConstraints() to
    make it return true if at least one a parameter or the return value host a
    constraint</span></i><p><i><span class="remark">TODO: Should
    <tt class="methodname">getReturnValueDescriptor()</tt> return null for void
    methods or a void
    <tt class="classname">ReturnValueDescriptor</tt>?</span></i></p><p><i><span class="remark">TODO: Investigate how cross-parameter constraints fit into
    the picture.</span></i></p></div></div><div class="added"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7672"></a>6.6.&nbsp;ConstructorDescriptor</h2></div></div><div></div></div><p>The <tt class="classname">ConstructorDescriptor</tt> interface describes
    a constrained constructor of a Java type.</p><p><tt class="classname">ConstructorDescriptor</tt> lives in the
    <tt class="classname">javax.validation.metadata</tt> package.</p><p>This interface is returned by
    <tt class="methodname">BeanDescriptor#getConstraintsForConstructor(String,
    Class&lt;?&gt;...)</tt> and
    <tt class="methodname">BeanDescriptor#getConstrainedConstructors()</tt>.</p><pre class="programlisting">package javax.validation.metadata;

import java.util.List;

/**
 * Describes a validated constructor.
 *
 * @author Gunnar Morling
 * @author Emmanuel Bernard
 * @since 1.1
 */
public interface ConstructorDescriptor extends ElementDescriptor {

    /**
     * &lt;p&gt;
     * Returns a list with descriptors for this constructor parameters. The size
     * of this list corresponds to the number of this constructor parameters.
     * &lt;/p&gt;
     *
     * @return A list with descriptors for this constructor's parameters. An
     *         empty list will be returned if this constructor has no
     *         parameters, but never {@code null}.
     */
    List&lt;ParameterDescriptor&gt; getParameterDescriptors();

    /**
     * Returns a descriptor for this constructor's return value.
     *
     * @return A descriptor for this constructor's return value.
     */
    ReturnValueDescriptor getReturnValueDescriptor();

    /**
     * Returns {@code true} if the constructor parameters are constrained either:
     * &lt;ul&gt;
     * &lt;li&gt;because of a constraint on at least one of the parameters&lt;/li&gt;
     * &lt;li&gt;because of a cascade on at least one of the parameters (via {@code @Valid})&lt;/li&gt;
     * &lt;li&gt;because of at least one cross-parameter constraint&lt;/li&gt;
     * &lt;/ul&gt;
     * Also returns {@code false} if there is no parameter.
     *
     * @return true if the constructor parameters are constrained
     */
    boolean areParametersConstrained();

    /**
     * Returns {@code true} if the constructor return value is constrained either:
     * &lt;ul&gt;
     * &lt;li&gt;because of a constraint on the return value&lt;/li&gt;
     * &lt;li&gt;because validation is cascaded on the return value (via {@code @Valid})&lt;/li&gt;
     * &lt;/ul&gt;
     * Also returns {@code false} if there is no return value.
     *
     * @return true if the constructor return value is constrained
     */
    boolean isReturnValueConstrained();
}</pre><p><tt class="methodname">getParameterDescriptors</tt>() returns a list of
    <tt class="classname">ParameterDescriptor</tt>s representing the constructor's
    parameters in their natural order. An empty list will be returned in case
    the constructor has no parameters.</p><p><tt class="methodname">getReturnValueDescriptor()</tt> returns a
    descriptor for the constructor's return value.</p><p><tt class="classname">isConstrainedOnParameters()</tt> returns true if
    any of the parameters is constrained or cascaded. Returns false if there
    is no parameter.</p><p><tt class="classname">isConstrainedOnReturnValue()</tt> returns true if
    the return value is constrained or cascaded. Returns false if there is no
    return value.</p><p><i><span class="remark">TODO: Should we have something like
    <tt class="methodname">hasParameterConstraints()</tt> allowing quickly to
    check whether parameter validation is required or not?</span></i></p></div></div><div class="added"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7722"></a>6.7.&nbsp;ParameterDescriptor</h2></div></div><div></div></div><p>The <tt class="classname">ParameterDescriptor</tt> interface describes a
    constrained parameter of a method or constructor.</p><p><tt class="classname">ParameterDescriptor</tt> lives in the
    <tt class="classname">javax.validation.metadata</tt> package.</p><p>This interface is returned by
    <tt class="methodname">MethodDescriptor#getParameterDescriptors()</tt> and
    <tt class="methodname">ConstructorDescriptor#getParameterDescriptors()</tt>.</p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a validated method or constructor parameter.
 *
 * @author Gunnar Morling
 *
 */
public interface ParameterDescriptor extends ElementDescriptor {

    /**
     * Returns this parameter's index within the parameter array of the method
     * or constructor holding it.
     *
     * @return This parameter's index.
     */
    int getIndex();

    /**
     * Returns this parameter's name as retrieved by the current parameter name
     * resolver.
     *
     * @return This parameter's name.
     */
    String getName();

    /**
     * Whether a cascaded validation of this parameter shall be performed or
     * not.
     *
     * @return &lt;code&gt;true&lt;/code&gt;, if this parameter shall be validated
     *         recursively, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    boolean isCascaded();
}</pre><p><tt class="methodname">getIndex()</tt> returns the index of the
    represented parameter within the parameter array of the method or
    constructor holding it.</p><p><tt class="methodname">getName()</tt> returns the name of the
    represented parameter.</p><p><tt class="methodname">isCascaded()</tt> returns true, if the
    represented parameter is marked for cascaded validation, false
    otherwise.</p></div></div><div class="added"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7759"></a>6.8.&nbsp;ReturnValueDescriptor</h2></div></div><div></div></div><p>The <tt class="classname">ReturnValueDescriptor</tt> interface describes
    a constrained return value of a method or constructor.</p><p><tt class="classname">ReturnValueDescriptor</tt> lives in the
    <tt class="classname">javax.validation.metadata</tt> package.</p><p>This interface is returned by
    <tt class="methodname">MethodDescriptor#getReturnValueDescriptor()</tt> and
    <tt class="methodname">ConstructorDescriptor#getReturnValueDescriptor()</tt>.</p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a validated return value of a method or constructor.
 *
 * @author Gunnar Morling
 */
public interface ReturnValueDescriptor extends ElementDescriptor {

    /**
     * Whether a cascaded validation for this return value shall be performed or
     * not.
     *
     * @return &lt;code&gt;true&lt;/code&gt;, if this return value shall be validated
     *         recursively, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    boolean isCascaded();
}</pre><p><tt class="methodname">isCascaded()</tt> returns true, if the
    represented return value is marked for cascaded validation, false
    otherwise.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintmetadata-constraintdescriptor"></a>6.9.&nbsp;ConstraintDescriptor</h2></div></div><div></div></div><p>A <tt class="classname">ConstraintDescriptor</tt> object describes a
    given constraint declaration (i.e. a constraint annotation).</p><p><tt class="classname">ConstraintDescriptor</tt> lives in the
    <tt class="classname">javax.validation.metadata</tt> package.</p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a single constraint and its composing constraints.
 * &lt;code&gt;T&lt;/code&gt; is the constraint's annotation type.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintDescriptor&lt;T extends Annotation&gt; {
    /**
     * Returns the annotation describing the constraint declaration.
     * If a composing constraint, attribute values are reflecting
     * the overridden attributes of the composing constraint
     *
     * @return The annotation for this constraint.
     */
    T getAnnotation();

    /**
     * The set of groups the constraint is applied on.
     * If the constraint declares no group, a set with only the &lt;code&gt;Default&lt;/code&gt;
     * group is returned.
     *
     * @return The groups the constraint is applied on.
     */
    Set&lt;Class&lt;?&gt;&gt; getGroups();

    /**
     * The set of payload the constraint hosts.
     *
     * @return payload classes hosted on the constraint or an empty set if none.
     */
    Set&lt;Class&lt;? extends Payload&gt;&gt; getPayload();

    /**
     * List of the constraint validation implementation classes.
     *
     * @return list of the constraint validation implementation classes.
     */
    List&lt;Class&lt;? extends ConstraintValidator&lt;T, ?&gt;&gt;&gt;
    getConstraintValidatorClasses();

    /**
     * Returns a map containing the annotation attribute names as keys and the
     * annotation attribute values as value.
     * If this constraint is used as part of a composed constraint, attribute
     * values are reflecting the overridden attribute of the composing constraint.
     *
     * @return a map containing the annotation attribute names as keys
     *         and the annotation attribute values as value.
     */
    Map&lt;String, Object&gt; getAttributes();

    /**
     * Return a set of composing &lt;code&gt;ConstraintDescriptor&lt;/code&gt;s where each
     * descriptor describes a composing constraint. &lt;code&gt;ConstraintDescriptor&lt;/code&gt;
     * instances of composing constraints reflect overridden attribute values in
     * {@link #getAttributes()}  and {@link #getAnnotation()}.
     *
     * @return a set of &lt;code&gt;ConstraintDescriptor&lt;code&gt; objects or an empty set
     *         in case there are no composing constraints.
     */
    Set&lt;ConstraintDescriptor&lt;?&gt;&gt; getComposingConstraints();

    /**
     * @return true if the constraint is annotated with &lt;code&gt;@ReportAsSingleViolation&lt;/code&gt;
     */
    boolean isReportAsSingleViolation();
}</pre><p><tt class="methodname">getAnnotation</tt> returns the annotation
    instance (or an annotation instance representing the given constraint
    declaration). If <tt class="classname">ConstraintDescriptor</tt> represents a
    composing annotation (see <a href="#constraintsdefinitionimplementation-constraintcomposition" title="3.3.&nbsp;Constraint composition">Section&nbsp;3.3, &#8220;Constraint composition&#8221;</a>),
    the returned annotation must reflect parameter overriding. In other words,
    the annotation parameter values are the overridden values.</p><p><tt class="methodname">getAttributes</tt> returns a map containing the
    annotation attribute names as a key, and the annotation attribute values
    as a value (this API is anticipated to be simpler to use by tools than
    reflection over the annotation instance). If
    <tt class="classname">ConstraintDescriptor</tt> represents a composing
    annotation (see <a href="#constraintsdefinitionimplementation-constraintcomposition" title="3.3.&nbsp;Constraint composition">Section&nbsp;3.3, &#8220;Constraint composition&#8221;</a>),
    the returned <tt class="classname">Map</tt> must reflects attribute
    overriding.</p><p><tt class="methodname">getGroups</tt> returns the groups the constraint
    is supposed to be applied upon. If no group is set on the constraint
    declaration, the <tt class="classname">Default</tt> group is returned. The
    groups of a composing constraint are the groups of the composed
    constraint.</p><p><tt class="literal">getPayload</tt> returns the payloads associated to the
    constraint or an empty set if none.</p><p><tt class="methodname">getConstraintValidatorClasses</tt> returns the
    <tt class="classname">ConstraintValidator</tt> classes associated with the
    constraint.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7844"></a>6.10.&nbsp;Example</h2></div></div><div></div></div><div class="added"><p><i><span class="remark">TODO: Extend example to cover method
    constraints, too.</span></i></p></div><p>Assuming the following <tt class="classname">@NotEmpty</tt>
    definition</p><pre class="programlisting">package com.acme.constraint;

@Documented
@NotNull
@Size(min=1)
@ReportAsSingleViolation
@Constraint(validatedBy = NotEmpty.NotEmptyValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface NotEmpty {
    String message() default "{com.acme.constraint.NotEmpty.message}"
    Class&lt;?&gt; groups() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        NotEmpty[] value();
    }

    class NotEmptyValidator implements ConstraintValidator&lt;NotEmpty, String&gt; {
        public void initialize(NotEmpty constraintAnnotation) {}

        public boolean isValid(String value, ConstraintValidatorContext context) {
            return true;
        }
    }
}</pre><p>and the following class definitions</p><pre class="programlisting">public class Author {
    private String firstName;
    
    @NotEmpty(message="lastname must not be null")
    private String lastName;

    @Size(max=30)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}

public class Book {
    private String title;
    private String description;

    @Valid
    @NotNull
    private Author author;

    @NotEmpty(groups={FirstLevelCheck.class, Default.class})
    @Size(max=30)
    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }

    public String getDescription() {
        return description;
    }

    public void setAuthor(String description) {
        this.description = description;
    }
}</pre><p>The following assertions are true.</p><pre class="programlisting">BeanDescriptor bookDescriptor = validator.getConstraintsForClass(Book.class);

assert ! bookDescriptor.hasConstraints();

assert bookDescriptor.isBeanConstrained();

assert bookDescriptor.getConstraintDescriptors().size() == 0 //no bean-level constraint

//more specifically "author" and "title"
assert bookDescriptor.getConstrainedProperties().size() == 2;

//not a property
assert bookDescriptor.getConstraintsForProperty("doesNotExist") == null; 

//property with no constraint
assert bookDescriptor.getConstraintsForProperty("description") == null; 

ElementDescriptor propertyDescriptor = bookDescriptor.getConstraintsForProperty("title");
assert propertyDescriptor.getConstraintDescriptors().size() == 2
assert "title".equals( propertyDescriptor.getPropertyName() );

//assuming the implementation returns the @NotEmpty constraint first
ConstraintDescriptor&lt;?&gt; constraintDescriptor = propertyDescriptor.getConstraintDescriptors()
                                                              .iterator().next();
assert constraintDescriptor.getAnnotation().getAnnotationType().equals( NotEmpty.class );
assert constraintDescriptor.getGroups().size() == 2; //FirstLevelCheck and Default
assert constraintDescriptor.getComposingConstraints().size() == 2;
assert constraintDescriptor.isReportAsSingleViolation() == true

//@NotEmpty cannot be null
boolean notNullPresence = false;
for ( ConstraintDescriptor&lt;?&gt; composingDescriptor : constraintDescriptor.getComposingConstraints() ) {
    if ( composingDescriptor.getAnnotation().getAnnotationType().equals( NotNull.class ) ) {
        notNullPresence = true;
    }
}
assert notNullPresence; 

//assuming the implementation returns the Size constraint second
constraintDescriptor = propertyDescriptor.getConstraintDescriptors().iterator().next().next();
assert constraintDescriptor.getAnnotation().getAnnotationType().equals( Size.class );
assert constraintDescriptor.getAttributes().get("max") == 30; 
assert constraintDescriptor.getGroups().size() == 1;

propertyDescriptor = bookDescriptor.getConstraintsForProperty("author");
assert propertyDescriptor.getConstraintDescriptors().size() == 1
assert propertyDescriptor.isCascaded()</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="builtinconstraints"></a>Chapter&nbsp;7.&nbsp;Built-in Constraint definitions</h2></div></div><div></div></div><p>The specification defines a small set of built-in constraints. Their
  usage is encouraged both in regular constraint declarations and as composing
  constraints. Using this set of constraints will enhance portability of your
  constraints across constraint-consuming frameworks relying on the metadata
  API (such as client side validation frameworks or database schema generation
  frameworks).</p><p>Built-in annotations are annotated with an empty
  <tt class="classname">@Constraint</tt> annotation to avoid any dependency
  between the specification API and a specific implementation. Each Bean
  Validation provider must recognize built-in constraint annotations as valid
  constraint definitions and provide compliant constraint implementations for
  each. The built-in constraint validation implementation is having a lower
  priority than an XML mapping definition. In other words
  <tt class="classname">ConstraintValidator</tt> implementations for built-in
  constraints can be overridden by using the XML mapping (see <a href="#xml-mapping-constraintdefinition" title="8.1.2.&nbsp;Overriding constraint definitions in XML">Section&nbsp;8.1.2, &#8220;Overriding constraint definitions in XML&#8221;</a>).</p><p>All built-in constraints are in the
  <tt class="classname">javax.validation.constraints</tt> package. Here is the
  list of constraints and their declaration.</p><div class="example"><a name="d0e7885"></a><p class="title"><b>Example&nbsp;7.1.&nbsp;@Null constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be {@code null}.
 * Accepts any type.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface Null {
    String message() default "{javax.validation.constraints.Null.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * Defines several {@code @Null} annotations on the same element
     *
     * @author Emmanuel Bernard
     * @see javax.validation.constraints.Null
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Null[] value();
    }
}</pre></div><div class="example"><a name="d0e7890"></a><p class="title"><b>Example&nbsp;7.2.&nbsp;@NotNull constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must not be {@code null}.
 * Accepts any type.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface NotNull {
    String message() default "{javax.validation.constraints.NotNull.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * Defines several {@code @NotNull} annotations on the same element
     *
     * @author Emmanuel Bernard
     * @see javax.validation.constraints.NotNull
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        NotNull[] value();
    }
}</pre></div><div class="example"><a name="d0e7895"></a><p class="title"><b>Example&nbsp;7.3.&nbsp;@AssertTrue constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be true.
 * Supported types are {@code boolean} and {@code Boolean}
 * &lt;p/&gt;
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface AssertTrue {
    String message() default "{javax.validation.constraints.AssertTrue.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * Defines several {@code @AssertTrue} annotations on the same element
     *
     * @author Emmanuel Bernard
     * @see AssertTrue
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        AssertTrue[] value();
    }
}</pre></div><div class="example"><a name="d0e7900"></a><p class="title"><b>Example&nbsp;7.4.&nbsp;@AssertFalse constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be false.
 * Supported types are {@code boolean} and {@code Boolean}
 * &lt;p/&gt;
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface AssertFalse {
    String message() default "{javax.validation.constraints.AssertFalse.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * Defines several {@code @AssertFalse} annotations on the same element
     *
     * @author Emmanuel Bernard
     * @see javax.validation.constraints.AssertFalse
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        AssertFalse[] value();
    }
}</pre></div><div class="example"><a name="d0e7905"></a><p class="title"><b>Example&nbsp;7.5.&nbsp;@Min constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a number whose value must be higher or
 * equal to the specified minimum.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;{@code BigDecimal}&lt;/li&gt;
 * &lt;li&gt;{@code BigInteger}&lt;/li&gt;
 * &lt;li&gt;{@code byte}, {@code short}, {@code int}, {@code long}, and their respective wrappers&lt;/li&gt;
 * &lt;/ul&gt;
 * Note that {@code double} and {@code float} are not supported due to rounding errors
 * (some providers might provide some approximative support)
 * &lt;p/&gt;
 * {@code null} elements are considered valid
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface Min {
    String message() default "{javax.validation.constraints.Min.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * @return value the element must be higher or equal to
     */
    long value();

    /**
     * Defines several {@code @Min} annotations on the same element
     *
     * @author Emmanuel Bernard
     * @see Min
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Min[] value();
    }
}</pre></div><div class="example"><a name="d0e7910"></a><p class="title"><b>Example&nbsp;7.6.&nbsp;@Max constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a number whose value must be lower or
 * equal to the specified maximum.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;{@code BigDecimal}&lt;/li&gt;
 * &lt;li&gt;{@code BigInteger}&lt;/li&gt;
 * &lt;li&gt;{@code byte}, {@code short}, {@code int}, {@code long}, and their respective wrappers&lt;/li&gt;
 * &lt;/ul&gt;
 * Note that {@code double} and {@code float} are not supported due to rounding errors
 * (some providers might provide some approximative support)
 * &lt;p/&gt;
 * {@code null} elements are considered valid
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface Max {
    String message() default "{javax.validation.constraints.Max.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * @return value the element must be lower or equal to
     */
    long value();

    /**
     * Defines several {@code @Max} annotations on the same element
     *
     * @author Emmanuel Bernard
     * @see Max
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Max[] value();
    }
}</pre></div><div class="changed"><div class="example"><a name="d0e7915"></a><p class="title"><b>Example&nbsp;7.7.&nbsp;@DecimalMin constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a number whose value must be higher or
 * equal to the specified minimum.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;{@code BigDecimal}&lt;/li&gt;
 * &lt;li&gt;{@code BigInteger}&lt;/li&gt;
 * &lt;li&gt;{@code CharSequence}&lt;/li&gt;
 * &lt;li&gt;{@code byte}, {@code short}, {@code int}, {@code long}, and their respective wrappers&lt;/li&gt;
 * &lt;/ul&gt;
 * Note that {@code double} and {@code float} are not supported due to rounding errors
 * (some providers might provide some approximative support)
 * &lt;p/&gt;
 * {@code null} elements are considered valid
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface DecimalMin {
    String message() default "{javax.validation.constraints.DecimalMin.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * The {@code String} representation of the min value according to the
     * {@code BigDecimal} string representation
     *
     * @return value the element must be higher or equal to
     */
    String value();

    /**
     * Defines several {@code @DecimalMin} annotations on the same element
     *
     * @author Emmanuel Bernard
     * @see DecimalMin
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        DecimalMin[] value();
    }
}</pre></div></div><div class="changed"><div class="example"><a name="d0e7920"></a><p class="title"><b>Example&nbsp;7.8.&nbsp;@DecimalMax constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a number whose value must be lower or
 * equal to the specified maximum.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;{@code BigDecimal}&lt;/li&gt;
 * &lt;li&gt;{@code BigInteger}&lt;/li&gt;
 * &lt;li&gt;{@code CharSequence}&lt;/li&gt;
 * &lt;li&gt;{@code byte}, {@code short}, {@code int}, {@code long}, and their respective wrappers&lt;/li&gt;
 * &lt;/ul&gt;
 * Note that {@code double} and {@code float} are not supported due to rounding errors
 * (some providers might provide some approximative support)
 * &lt;p/&gt;
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface DecimalMax {
    String message() default "{javax.validation.constraints.DecimalMax.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * The {@code String} representation of the max value according to the
     * {@code BigDecimal} string representation
     *
     * @return value the element must be lower or equal to
     */
    String value();

    /**
     * Defines several {@code @DecimalMax} annotations on the same element
     *
     * @author Emmanuel Bernard
     * @see DecimalMax
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        DecimalMax[] value();
    }
}</pre></div></div><div class="changed"><div class="example"><a name="d0e7925"></a><p class="title"><b>Example&nbsp;7.9.&nbsp;@Size constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element size must be between the specified boundaries (included).
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;{@code CharSequence} (length of character sequence is evaluated)&lt;/li&gt;
 * &lt;li&gt;{@code Collection} (collection size is evaluated)&lt;/li&gt;
 * &lt;li&gt;{@code Map} (map size is evaluated)&lt;/li&gt;
 * &lt;li&gt;Array (array length is evaluated)&lt;/li&gt;
 * &lt;p/&gt;
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface Size {
    String message() default "{javax.validation.constraints.Size.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * @return size the element must be higher or equal to
     */
    int min() default 0;

    /**
     * @return size the element must be lower or equal to
     */
    int max() default Integer.MAX_VALUE;

    /**
     * Defines several {@code @Size} annotations on the same element
     *
     * @author Emmanuel Bernard
     * @see Size
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Size[] value();
    }
}</pre></div></div><div class="changed"><div class="example"><a name="d0e7930"></a><p class="title"><b>Example&nbsp;7.10.&nbsp;@Digits constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a number within accepted range
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;{@code BigDecimal}&lt;/li&gt;
 * &lt;li&gt;{@code BigInteger}&lt;/li&gt;
 * &lt;li&gt;{@code CharSequence}&lt;/li&gt;
 * &lt;li&gt;{@code byte}, {@code short}, {@code int}, {@code long}, and their respective wrapper types&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * {@code null} elements are considered valid
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface Digits {
    String message() default "{javax.validation.constraints.Digits.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * @return maximum number of integral digits accepted for this number.
     */
    int integer();

    /**
     * @return maximum number of fractional digits accepted for this number.
     */
    int fraction();

    /**
     * Defines several {@code @Digits} annotations on the same element
     *
     * @author Emmanuel Bernard
     * @see Digits
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Digits[] value();
    }
}</pre></div></div><div class="example"><a name="d0e7935"></a><p class="title"><b>Example&nbsp;7.11.&nbsp;@Past constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a date in the past.
 * Now is defined as the current time according to the virtual machine
 * The calendar used if the compared type is of type {@code Calendar}
 * is the calendar based on the current timezone and the current locale.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;{@code java.util.Date}&lt;/li&gt;
 * &lt;li&gt;{@code java.util.Calendar}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface Past {
    String message() default "{javax.validation.constraints.Past.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * Defines several {@code @Past} annotations on the same element
     *
     * @author Emmanuel Bernard
     * @see Past
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Past[] value();
    }
}</pre></div><div class="example"><a name="d0e7940"></a><p class="title"><b>Example&nbsp;7.12.&nbsp;@Future constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a date in the future.
 * Now is defined as the current time according to the virtual machine
 * The calendar used if the compared type is of type {@code Calendar}
 * is the calendar based on the current timezone and the current locale.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;{@code java.util.Date}&lt;/li&gt;
 * &lt;li&gt;{@code java.util.Calendar}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface Future {
    String message() default "{javax.validation.constraints.Future.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * Defines several {@code @Future} annotations on the same element
     *
     * @author Emmanuel Bernard
     * @see Future
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Future[] value();
    }
}</pre></div><div class="changed"><div class="example"><a name="d0e7945"></a><p class="title"><b>Example&nbsp;7.13.&nbsp;@Pattern constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated {@code CharSequence} must match the specified regular expression.
 * The regular expression follows the Java regular expression conventions
 * see {@link java.util.regex.Pattern}.
 * &lt;p/&gt;
 * Accepts {@code CharSequence}. {@code null} elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface Pattern {
    /**
     * @return The regular expression to match.
     */
    String regexp();

    /**
     * @return Array of {@code Flag}s considered when resolving the regular expression.
     */
    Flag[] flags() default { };

    /**
     * @return The error message template.
     */
    String message() default "{javax.validation.constraints.Pattern.message}";

    /**
     * @return The groups the constraint belongs to.
     */
    Class&lt;?&gt;[] groups() default { };

    /**
     * @return The payload associated to the constraint
     */
    Class&lt;? extends Payload&gt;[] payload() default { };

    /**
     * Possible Regexp flags
     */
    public static enum Flag {

        /**
         * Enables Unix lines mode
         *
         * @see java.util.regex.Pattern#UNIX_LINES
         */
        UNIX_LINES( java.util.regex.Pattern.UNIX_LINES ),

        /**
         * Enables case-insensitive matching
         *
         * @see java.util.regex.Pattern#CASE_INSENSITIVE
         */
        CASE_INSENSITIVE( java.util.regex.Pattern.CASE_INSENSITIVE ),

        /**
         * Permits whitespace and comments in pattern
         *
         * @see java.util.regex.Pattern#COMMENTS
         */
        COMMENTS( java.util.regex.Pattern.COMMENTS ),

        /**
         * Enables multiline mode
         *
         * @see java.util.regex.Pattern#MULTILINE
         */
        MULTILINE( java.util.regex.Pattern.MULTILINE ),

        /**
         * Enables dotall mode
         *
         * @see java.util.regex.Pattern#DOTALL
         */
        DOTALL( java.util.regex.Pattern.DOTALL ),

        /**
         * Enables Unicode-aware case folding
         *
         * @see java.util.regex.Pattern#UNICODE_CASE
         */
        UNICODE_CASE( java.util.regex.Pattern.UNICODE_CASE ),

        /**
         * Enables canonical equivalence
         *
         * @see java.util.regex.Pattern#CANON_EQ
         */
        CANON_EQ( java.util.regex.Pattern.CANON_EQ );

        //JDK flag value
        private final int value;

        private Flag(int value) {
            this.value = value;
        }

        /**
         * @return flag value as defined in {@link java.util.regex.Pattern}
         */
        public int getValue() {
            return value;
        }
    }

    /**
     * Defines several {@code @Pattern} annotations on the same element
     *
     * @author Emmanuel Bernard
     * @see Pattern
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Pattern[] value();
    }
}</pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="xml"></a>Chapter&nbsp;8.&nbsp;XML deployment descriptor</h2></div></div><div></div></div><p>Two kind<span class="added"><span>s</span></span> of XML descriptors are
  used by Bean Validation. The first one describes the Bean Validation
  configuration provided as <tt class="filename">META-INF/validation.xml</tt>. The
  second one describes constraints declarations and closely matches the
  annotations declaration approach.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-mapping"></a>8.1.&nbsp;Constraint definition and declaration</h2></div></div><div></div></div><p>Bean Validation lets you declare constraints via XML rather than
    annotations. You can either ignore constraints declared via annotations or
    consider XML as adding additional constraints on top of annotation
    constraints. While it is not possible to define a new constraint via XML,
    you can redefine the list of <tt class="classname">ConstraintValidator</tt>
    classes associated to a given constraint definition.</p><p>There is no distinction between an annotation based constraint
    declaration and an XML based constraint declaration: they are considered
    equivalent and should be treated as such by the Bean Validation provider.
    The rest of the specification only refers to annotations as validation
    metadata: it should be read as annotation or their XML descriptor
    equivalent.</p><p>Specifically when exploring metadata, the Bean Validation provider
    must ensure that an annotation instance corresponding to the XML
    declaration is provided via
    <tt class="classname">ConstraintDescriptor.getAnnnotation()</tt>. The
    annotation elements as well as
    <tt class="methodname">ConstraintValidator.getAttributes()</tt> must reflect
    the values described in the XML declaration (see <a href="#xml-mapping-typeconversion" title="8.1.3.&nbsp;Converting the string representation of a value">Section&nbsp;8.1.3, &#8220;Converting the string representation of a value&#8221;</a>). Likewise,
    <tt class="methodname">ConstraintDescriptor.getConstraintValidatorClasses()</tt>
    must reflect XML based constraint definition overriding (see <a href="#xml-mapping-constraintdefinition" title="8.1.2.&nbsp;Overriding constraint definitions in XML">Section&nbsp;8.1.2, &#8220;Overriding constraint definitions in XML&#8221;</a>).</p><p>A given class must not be described more than once amongst all the
    XML mapping descriptors. A given field or getter must not be described
    more than once on a given class description. A given constraint definition
    must not be overridden more than once amongst all the XML mapping
    descriptors. If any of these rule is violated in a given validation
    deployment, a <tt class="classname">ValidationException</tt> is raised during
    the creation of the <tt class="classname">ValidatorFactory</tt>.</p><p>The schema is provided in <a href="#xml-mapping-xsd" title="8.1.4.&nbsp;XML Schema">Section&nbsp;8.1.4, &#8220;XML Schema&#8221;</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7998"></a>8.1.1.&nbsp;Constraint declaration in XML</h3></div></div><div></div></div><p>If <tt class="literal">default-package</tt> is set, all unqualified
      class names (including annotations) are considered part of the package
      described by <tt class="literal">default-package</tt>.</p><p>A given JavaBean is described by the <tt class="classname">bean</tt>
      element. The name of the class is mandatory. By default, all constraint
      declarations expressed via annotation are ignored for classes described
      in XML. You can force Bean Validation to consider both annotations and
      XML constraint declarations by using
      <tt class="code">ignore-annotation="false"</tt> on
      <tt class="literal">bean</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <tt class="literal">ignore-annotation</tt> setting is not
        inherited from nor by the class hierarchy. In other words, it only
        applies to the current bean only.</p></div><p>If the name of the class does refer to a class not present in in
      the classpath, a <tt class="classname">ValidationException</tt> is
      raised.</p><div class="changed"><div class="example"><a name="d0e8031"></a><p class="title"><b>Example&nbsp;8.1.&nbsp;Example of bean XML declaration</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.1.xsd"
        version="1.1"&gt;

    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;

    &lt;bean class="Customer" ignore-annotations="false"&gt;
        [...]
    &lt;/bean&gt;
    &lt;bean class="com.acme.common.model.Address"&gt;
        [...]
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8036"></a>8.1.1.1.&nbsp;Class-level overriding</h4></div></div><div></div></div><p>Class level annotations are described via the
        <tt class="literal">class</tt> element. If
        <tt class="literal">ignore-annotations</tt> is declared, Bean Validation
        must honor the explicit value for this element. If not declared, the
        default value defined in the encapsulating <tt class="classname">bean</tt>
        element is considered.</p><p>When <tt class="literal">ignore-annotations</tt> is true, class-level
        Bean Validation annotations are ignored for this class (including the
        <tt class="classname">@GroupSequence</tt>). When
        <tt class="literal">ignore-annotations</tt> is false:</p><div class="itemizedlist"><ul type="disc"><li><p>Constraints declared in XML and constraints declared in
            annotations are added and form the list of class-level declared
            constraints.</p></li><li><p><tt class="classname">@GroupSequence</tt> is considered unless
            <tt class="literal">group-sequence</tt> element is explicitly
            used.</p></li></ul></div><div class="changed"><div class="example"><a name="d0e8073"></a><p class="title"><b>Example&nbsp;8.2.&nbsp;Example of class-level declaration</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.1.xsd"
        version="1.1"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;
        &lt;class ignore-annotations="true"&gt;
            [...]
        &lt;/class&gt;
    &lt;/bean&gt;
    &lt;bean class="com.acme.common.model.Address"&gt;
        &lt;class&gt;
            [...]
        &lt;/class&gt;
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8078"></a>8.1.1.2.&nbsp;Field-level overriding</h4></div></div><div></div></div><p>Field level annotations are described via the
        <tt class="literal">field</tt> element. The <tt class="literal">name</tt>
        attribute correspond to the name of the field considered. If
        <tt class="literal">ignore-annotations</tt> is declared, Bean Validation
        must honor the explicit value for this element. If not declared, the
        default value defined in the encapsulating <tt class="classname">bean</tt>
        element is considered.</p><p>When <tt class="literal">ignore-annotations</tt> is true, field-level
        Bean Validation annotations on the targeted field are ignored
        (including the <tt class="classname">@Valid</tt>). When
        <tt class="literal">ignore-annotations</tt> is false:</p><div class="itemizedlist"><ul type="disc"><li><p>Constraints declared in XML and constraints declared in
            annotations are added and form the list of field-level declared
            constraints.</p></li><li><p><tt class="classname">@Valid</tt> is considered unless the
            <tt class="literal">valid</tt> element is explicitly used. Note that the
            only way to disable cascading on a field marked as
            <tt class="classname">@Valid</tt> is to use
            <tt class="code">ignore-annotations=true</tt>.</p></li></ul></div><p>If the name of the field does not correspond to a field in the
        given bean a <tt class="classname">ValidationException</tt> is
        raised.</p><div class="changed"><div class="example"><a name="d0e8129"></a><p class="title"><b>Example&nbsp;8.3.&nbsp;Field-level declaration</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.1.xsd"
        version="1.1"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;
        &lt;field name="firstName"&gt;
            [...]
        &lt;/field&gt;
        &lt;field name="orders"&gt;
            &lt;valid/&gt;
            [...]
        &lt;/field&gt;
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8134"></a>8.1.1.3.&nbsp;Property-level overriding</h4></div></div><div></div></div><p>Property-level annotations are described via the
        <tt class="literal">getter</tt> element. The <tt class="literal">name</tt>
        attribute correspond to the name of the property considered as defined
        in <a href="#constraintdeclarationvalidationprocess-requirements-property" title="4.1.2.&nbsp;Field and property validation">Section&nbsp;4.1.2, &#8220;Field and property validation&#8221;</a>
        (for example a getter <tt class="code">String getAge()</tt> would have
        <tt class="code">&lt;getter name="age"/&gt;</tt> as a corresponding
        descriptor). If <tt class="literal">ignore-annotations</tt> is declared,
        Bean Validation must honor the explicit value for this element. If not
        declared, the default value defined in the encapsulating
        <tt class="classname">bean</tt> element is considered.</p><p>When <tt class="literal">ignore-annotations</tt> is true,
        property-level Bean Validation annotations on the targeted property
        are ignored (including the <tt class="classname">@Valid</tt>). When
        <tt class="literal">ignore-annotations</tt> is false:</p><div class="itemizedlist"><ul type="disc"><li><p>Constraints declared in XML and constraints declared in
            annotations are added and form the list of property-level declared
            constraints.</p></li><li><p><tt class="classname">@Valid</tt> is considered unless the
            <tt class="literal">valid</tt> element is explicitly used. Note that the
            only way to disable cascading on a property marked as
            <tt class="classname">@Valid</tt> is to use
            <tt class="code">ignore-annotations=true</tt>.</p></li></ul></div><p>If the name of the property does not correspond to a property in
        the given bean a <tt class="classname">ValidationException</tt> is
        raised.</p><div class="changed"><div class="example"><a name="d0e8193"></a><p class="title"><b>Example&nbsp;8.4.&nbsp;Property-level declaration</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.1.xsd"
        version="1.1"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;
        &lt;getter name="firstName"&gt;
            [...]
        &lt;/getter&gt;
        &lt;getter name="orders"&gt;
            &lt;valid/&gt;
            [...]
        &lt;/getter&gt;
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div></div></div><div class="added"><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml-mapping-constraintdeclarationinxml-methodleveloverriding"></a>8.1.1.4.&nbsp;Method-level overriding</h4></div></div><div></div></div><p><i><span class="remark">TODO</span></i></p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8204"></a>8.1.1.5.&nbsp;Constraint declaration</h4></div></div><div></div></div><p>A new constraint declaration is represented by the
        <tt class="literal">constraint</tt> element. The
        <tt class="literal">annotation</tt> attribute is the class name of the
        annotation representing the constraint. Message, groups and payload
        are defined respectively by the <tt class="literal">message</tt>,
        <tt class="literal">groups</tt> and <tt class="literal">payload</tt>
        elements.</p><p>Other custom elements of an annotation are represented by
        <tt class="literal">element</tt>. The <tt class="literal">name</tt> attribute is
        mandatory and represents the name of the element in the constraint
        declaration. &#8220;<span class="quote">message</span>&#8221;, &#8220;<span class="quote">groups</span>&#8221; and
        &#8220;<span class="quote">payload</span>&#8221; are not permitted names, use the
        <tt class="literal">message</tt>, <tt class="literal">groups</tt> or
        <tt class="literal">payload</tt> elements instead. Otherwise a
        <tt class="classname">ValidationException</tt> is raised.</p><p>If the element represents a primitive type, a class or an enum,
        the string representation of its value is placed in the element
        itself. See <a href="#xml-mapping-typeconversion" title="8.1.3.&nbsp;Converting the string representation of a value">Section&nbsp;8.1.3, &#8220;Converting the string representation of a value&#8221;</a> for a
        detailed explanation of the conversion rules from string to the
        type.</p><p>If the element represents a primitive type array, a class array
        or an enum array, the string representation of each value is placed in
        a <tt class="literal">value</tt> element placed under the element
        itself.</p><p>If the element represents an annotation, the
        <tt class="literal">annotation</tt> element is used to represent the
        annotation and placed under <tt class="literal">element</tt>. An
        <tt class="literal">annotation</tt> element contains
        <tt class="literal">element</tt> elements.</p><p>If the element represents an array of annotations, one or more
        <tt class="literal">annotation</tt> elements are placed under
        <tt class="literal">element</tt>.</p><p>Elements with default values in the annotation definition do not
        have to be represented in XML: the default value will be used in this
        case. If an XML constraint declaration is missing mandatory elements,
        or if it contains elements not part of the constraint definition, a
        <tt class="classname">ValidationException</tt> is raised.</p><div class="changed"><div class="example"><a name="d0e8289"></a><p class="title"><b>Example&nbsp;8.5.&nbsp;Constraint declaration</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.1.xsd"
        version="1.1"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;

        &lt;field name="firstName"&gt;


            &lt;!-- @LooksLike(patterns={
                      @Pattern(value="myRegExp", flag=PatternFlag.INSENSITIVE),
                      @Pattern(value="my2ndRegExp")}
                  )
             --&gt;
            &lt;constraint annotation="com.acme.app.constraint.LooksLike"&gt;
                &lt;element name="patterns"&gt;
                    &lt;annotation&gt;
                        &lt;element name="value"&gt;myRegExp&lt;/element&gt;
                        &lt;element name="flag"&gt;
                            &lt;value&gt;INSENSITIVE&lt;/value&gt;
                        &lt;/element&gt;
                    &lt;/annotation&gt;
                    &lt;annotation&gt;
                        &lt;element name="value"&gt;my2ndRegExp&lt;/element&gt;
                    &lt;/annotation&gt;
                &lt;/element&gt;
            &lt;/constraint&gt;


        &lt;/field&gt;
        &lt;field name="orders"&gt;
            &lt;valid/&gt;


            &lt;!-- @DiscreteSize(value={ 0, 20 } )
             --&gt;
            &lt;constraint annotation="com.acme.app.constraint.DiscreteSize"&gt;
                &lt;element name="value"&gt;
                    &lt;value&gt;0&lt;/value&gt;
                    &lt;value&gt;20&lt;/value&gt;
                &lt;/element&gt;
            &lt;/constraint&gt;


        &lt;/field&gt;

        &lt;getter name="orders"&gt;
            &lt;valid/&gt;


            &lt;!-- @Size(message="Size is limited",
                       groups={Default.class, LightValidation.class},
                       max=30
                 )
            --&gt;
            &lt;constraint annotation="javax.validation.constraints.Size"&gt;
                &lt;message&gt;Size is limited&lt;/message&gt;
                &lt;groups&gt;
                    &lt;value&gt;com.acme.app.model.LightValidation&lt;/value&gt;
                    &lt;value&gt;javax.persistence.Default&lt;/value&gt;
                &lt;/groups&gt;
                &lt;payload&gt;
                    &lt;value&gt;com.acme.app.model.WARN&lt;/value&gt;
                &lt;/payload&gt;
                &lt;element name="max"&gt;30&lt;/element&gt;
            &lt;/constraint&gt;


        &lt;/getter&gt;
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml-mapping-constraintdefinition"></a>8.1.2.&nbsp;Overriding constraint definitions in XML</h3></div></div><div></div></div><p>A constraint definition (i.e. the annotation representing a
      constraint), cannot be fully expressed in XML but the list of
      <tt class="classname">ConstraintValidator</tt> associated to a given
      constraint can be altered.</p><p>A constraint definition is represented by a
      <tt class="literal">constraint-definition</tt> element. The
      <tt class="literal">annotation</tt> attribute represents the constraint
      annotation being altered. The <tt class="literal">validated-by</tt> elements
      represent the (ordered) list of
      <tt class="classname">ConstraintValidator</tt> implementations associated to
      the constraint.</p><p>If <tt class="literal">include-existing-validator</tt> is set to false,
      <tt class="classname">ConstraintValidator</tt> defined on the constraint
      annotation are ignored. If set to true, the list of
      <tt class="classname">ConstraintValidator</tt>s described in XML are
      concatenated to the list of <tt class="classname">ConstraintValidator</tt>
      described on the annotation to form a new array of
      <tt class="classname">ConstraintValidator</tt> evaluated. Annotation based
      <tt class="classname">ConstraintValidator</tt> come before XML based
      <tt class="classname">ConstraintValidatot</tt> in the array. The new list is
      returned by
      <tt class="methodname">ConstraintDescriptor.getConstraintValidatorClasses()</tt>.</p><div class="changed"><div class="example"><a name="d0e8342"></a><p class="title"><b>Example&nbsp;8.6.&nbsp;Overriding constraint definitions</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.1.xsd"
        version="1.1"&gt;
   &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
   &lt;bean class="com.acme.common.model.Address"&gt;
       [...]
    &lt;/bean&gt;

    &lt;constraint-definition annotation="javax.validation.constraints.Size"&gt;
        &lt;validated-by include-existing-validators="true"&gt;
            &lt;value&gt;com.acme.app.constraint.SizeValidatorForDictionary&lt;/value&gt;
        &lt;/validated-by&gt;
    &lt;/constraint-definition&gt;
    &lt;constraint-definition annotation="AcmeOrderNumber"&gt;
        [...]
    &lt;/constraint-definition&gt;
&lt;/constraint-mappings&gt;</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml-mapping-typeconversion"></a>8.1.3.&nbsp;Converting the string representation of a value</h3></div></div><div></div></div><p>Primitive types, <tt class="classname">Class</tt> and
      <tt class="classname">Enum</tt> are represented as strings in the XML
      descriptor. Elements of an array are represented by the
      <tt class="literal">value</tt> element.</p><p><tt class="classname">byte</tt> are represented according to the rules
      defined in <tt class="methodname">Byte.parseByte(String)</tt>.</p><p><tt class="classname">short</tt> are represented according to the
      rules defined in
      <tt class="methodname">Short.parseShort(String)</tt>.</p><p><tt class="classname">int</tt> are represented according to the rules
      defined in <tt class="methodname">Integer.parseInt(String)</tt>.</p><p><tt class="classname">long</tt> are represented according to the rules
      defined in <tt class="methodname">Long.parseLong(String)</tt>.</p><p><tt class="classname">float</tt> are represented according to the
      rules defined in
      <tt class="methodname">Float.parseFloat(String)</tt>.</p><p><tt class="classname">double</tt> are represented according to the
      rules defined in
      <tt class="methodname">Double.parseDouble(String)</tt>.</p><p><tt class="classname">boolean</tt> are represented according to the
      rules defined in
      <tt class="methodname">Boolean.parseBoolean(String)</tt>.</p><p><tt class="classname">char</tt> are represented according to the
      following rules:</p><div class="itemizedlist"><ul type="disc"><li><p>the string must be of one character long</p></li><li><p>the character extracted from the string is the returned
          <tt class="classname">char</tt></p></li></ul></div><p>A <tt class="classname">Class</tt> is represented by the fully
      qualified class name of the class. Note that if the raw string is
      unqualified, default package is taken into account.</p><p>An enum is represented by its <tt class="code">enum.name()</tt>
      value.</p><p>If any of the string representation does not match its type
      counterpart, a <tt class="classname">ValidationException</tt> is
      raised.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml-mapping-xsd"></a>8.1.4.&nbsp;XML Schema</h3></div></div><div></div></div><p>This section contains the XML schema used for constraint mapping
      <span class="added"><span>descriptors</span></span>.</p><div class="added"><p>From Bean Validation revision 1.1 onwards,
      mapping authors must specify the used version of the schema within the
      <tt class="literal">version</tt> attribute of the
      <tt class="literal">constraint-mappings</tt> element. Implementations
      supporting Bean Validation 1.1 must properly parse mapping descriptors
      of Bean Validation 1.0 and 1.1. If the <tt class="literal">version</tt>
      attribute attribute is not given, schema version 1.0 is to be assumed by
      the Bean Validation Provider.</p></div><div class="added"><p>In case an unknown version is given (e.g. if
      a mapping descriptor adhering to a future schema version is parsed by a
      Bean Validation 1.1 provider) a
      <tt class="classname">ValidationException</tt> is raised.</p></div><div class="changed"><div class="example"><a name="d0e8462"></a><p class="title"><b>Example&nbsp;8.7.&nbsp;XML schema for constraint mapping descriptors</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema attributeFormDefault="unqualified"
           elementFormDefault="qualified"
           targetNamespace="http://jboss.org/xml/ns/javax/validation/mapping"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"
           version="1.1"&gt;

    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;&lt;![CDATA[
            This is the XML Schema for Bean Validation constraint mapping files.

            Bean Validation constraint mapping files must indicate the Bean Validation
            XML schema by using the constraint mapping namespace:

            http://jboss.org/xml/ns/javax/validation/mapping

            and indicate the version of the schema by using the version attribute
            as shown below:

            &lt;constraint-mappings
                xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="
                    http://jboss.org/xml/ns/javax/validation/mapping
                    validation-mapping-1.1.xsd"
                version="1.1"&gt;
                ...
            &lt;/constraint-mappings&gt;
        ]]&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;

    &lt;xs:element name="constraint-mappings" type="map:constraint-mappingsType" /&gt;

    &lt;xs:complexType name="payloadType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="groupsType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="groupSequenceType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="constraint-mappingsType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="default-package" minOccurs="0"/&gt;
            &lt;xs:element type="map:beanType"
                        name="bean"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
            &lt;xs:element type="map:constraint-definitionType"
                        name="constraint-definition"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="version" type="map:versionType" fixed="1.1" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:simpleType name="versionType"&gt;
        &lt;xs:restriction base="xs:token"&gt;
            &lt;xs:pattern value="[0-9]+(\.[0-9]+)*" /&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
    &lt;xs:complexType name="validated-byType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:boolean" name="include-existing-validators" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="constraintType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="message" minOccurs="0"/&gt;
            &lt;xs:element type="map:groupsType"
                        name="groups"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
            &lt;xs:element type="map:payloadType"
                        name="payload"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;            
            &lt;xs:element type="map:elementType"
                        name="element"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="annotation" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="elementType" mixed="true"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
            &lt;xs:element type="map:annotationType"
                        name="annotation"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="name" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="classType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:groupSequenceType" 
                        name="group-sequence" 
                        minOccurs="0" 
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
            &lt;xs:element type="map:constraintType"
                        name="constraint"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="beanType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:classType"
                        name="class"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"&gt;
            &lt;/xs:element&gt;
            &lt;xs:element type="map:fieldType"
                        name="field"
                        minOccurs="0"
                        maxOccurs="unbounded"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
            &lt;xs:element type="map:getterType"
                        name="getter"
                        minOccurs="0"
                        maxOccurs="unbounded"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="class" use="required"/&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="annotationType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:elementType"
                        name="element"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="getterType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="valid" minOccurs="0" fixed=""/&gt;
            &lt;xs:element type="map:constraintType"
                        name="constraint"
                        minOccurs="0"
                        maxOccurs="unbounded"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="name" use="required"/&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="constraint-definitionType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:validated-byType"
                        name="validated-by"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="annotation" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="fieldType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="valid" minOccurs="0" fixed=""/&gt;
            &lt;xs:element type="map:constraintType"
                        name="constraint"
                        minOccurs="0"
                        maxOccurs="unbounded"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="name" use="required"/&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;</pre></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-config-xsd"></a>8.2.&nbsp;Configuration schema</h2></div></div><div></div></div><p>XML Configuration is set in
    <tt class="filename">META-INF/validation.xml</tt>. The file is optional. The
    XML schema followed by the configuration file is as followed.</p><div class="changed"><div class="example"><a name="d0e8475"></a><p class="title"><b>Example&nbsp;8.8.&nbsp;XML configuration XSD</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema attributeFormDefault="unqualified"
           elementFormDefault="qualified"
           targetNamespace="http://jboss.org/xml/ns/javax/validation/configuration"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:config="http://jboss.org/xml/ns/javax/validation/configuration"
           version="1.1"&gt;

    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;&lt;![CDATA[
            This is the XML Schema for the Bean Validation configuration file.
            The configuration file must be named "META-INF/validation.xml".

            Bean Validation configuration files must indicate the Bean Validation
            XML schema by using the validation namespace:

            http://jboss.org/xml/ns/javax/validation/configuration

            and indicate the version of the schema by using the version attribute
            as shown below:

            &lt;validation-config
                xmlns="http://jboss.org/xml/ns/javax/validation/configuration"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="
                    http://jboss.org/xml/ns/javax/validation/configuration
                    validation-configuration-1.1.xsd"
                version="1.1"&gt;
                ...
            &lt;/validation-config&gt;
        ]]&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;

    &lt;xs:element name="validation-config" type="config:validation-configType"/&gt;
    &lt;xs:complexType name="validation-configType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="default-provider" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="message-interpolator" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="traversable-resolver" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="constraint-validator-factory" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="parameter-name-provider" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="constraint-mapping" maxOccurs="unbounded" minOccurs="0"/&gt;
            &lt;xs:element type="config:propertyType" name="property" maxOccurs="unbounded" minOccurs="0" xmlns:config="http://jboss.org/xml/ns/javax/validation/configuration"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="version" type="config:versionType" fixed="1.1" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="propertyType"&gt;
        &lt;xs:simpleContent&gt;
            &lt;xs:extension base="xs:string"&gt;
                &lt;xs:attribute name="name" use="required" type="xs:string"/&gt;
            &lt;/xs:extension&gt;
        &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:simpleType name="versionType"&gt;
        &lt;xs:restriction base="xs:token"&gt;
            &lt;xs:pattern value="[0-9]+(\.[0-9]+)*" /&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
&lt;/xs:schema&gt;</pre></div></div><div class="added"><p>From Bean Validation revision 1.1 onwards, the
    used version of the schema must be specified within the
    <tt class="literal">version</tt> attribute of the
    <tt class="literal">validation-config</tt> element. Implementations supporting
    Bean Validation 1.1 must properly parse configuration descriptors of Bean
    Validation 1.0 and 1.1. If the <tt class="literal">version</tt> attribute
    attribute is not given, schema version 1.0 is to be assumed by the Bean
    Validation Provider.</p></div><div class="added"><p>In case an unknown version is given a
    <tt class="classname">ValidationException</tt> is raised.</p></div><p>See <a href="#xml-config" title="5.5.6.&nbsp;XML Configuration: META-INF/validation.xml">Section&nbsp;5.5.6, &#8220;XML Configuration: META-INF/validation.xml&#8221;</a> for more information on XML based
    configuration.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="exception"></a>Chapter&nbsp;9.&nbsp;Exception model</h2></div></div><div></div></div><p>Illegal arguments passed to the Bean Validation APIs generally lead to
  a <tt class="classname">IllegalArgumentException</tt> (see the JavaDoc for
  specific details). Other exceptions raised by Bean Validation are or inherit
  from the runtime exception
  <tt class="classname">javax.validation.ValidationException</tt>. Exception cases
  are described in their respective sections but include (non exhaustive
  list):</p><div class="itemizedlist"><ul type="disc"><li><p>invalid constraint definitions (missing mandatory elements,
      illegal composition cycle, illegal attribute overriding, etc)</p></li><li><p>invalid constraint declarations
      (<tt class="classname">ConstraintValidator</tt> implementation matching
      failure, etc)</p></li><li><p>invalid group definition (circularity)</p></li><li><p>invalid <tt class="classname">Default</tt> group redefinition for
      classes (missing class group etc)</p></li><li><p>error when retrieving, initializing, executing
      <tt class="classname">ConstraintValidator</tt>s</p></li><li><p>error when parsing the XML configuration or mappings</p></li><li><p>multiple XML configuration files found</p></li><li><p>missing expected provider or no default provider found</p></li><li><p>missing no-arg constructor on extension implementations described
      in XML configuration files</p></li><li><p>same entity described more than once across the XML mapping
      files</p></li><li><p>same property or field described more than once for a given entity
      in the XML mapping files</p></li><li><p>class, field or getter declared in XML mapping files but not
      found</p></li><li><p>illegal XML constraint definition</p></li><li><p>illegal XML constraint declaration</p></li><li><p>exception raised either at initialization time or execution time
      by any of the extension interfaces</p></li></ul></div><p>Each of these error cases lead to a
  <tt class="classname">ValidationException</tt> or a subclass of
  <tt class="classname">ValidationException</tt> (see following
  subsections).</p><p>Every (runtime) exception raised either at initialization time or
  execution time by any of the extension interfaces
  (<tt class="classname">ConstraintValidator</tt>,
  <tt class="classname">ConstraintValidatorFactory</tt>,
  <tt class="classname">MessageInterpolator</tt>,
  <tt class="classname">TraversableResolver</tt>,
  <tt class="classname">ValidationProviderResolver</tt>) is wrapped in a
  <tt class="classname">ValidationException</tt>.</p><p>If a constraint definition or constraint declaration is invalid for a
  given class, the metadata API should raise the according exception.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8596"></a>9.1.&nbsp;Error report:
    <tt class="classname">ConstraintViolationException</tt></h2></div></div><div></div></div><p>Some frameworks or applications need to convey the result of a
    validation by raising an exception if the validation returns constraint
    violations.</p><p>Bean Validation provides a reference exception for such cases.
    Frameworks and applications are encouraged to use
    <tt class="classname">ConstraintViolationException</tt> as opposed to a custom
    exception to increase consistency of the Java platform. The exception can
    be raised directly or wrapped into the framework or application specific
    parent exception.</p><pre class="programlisting">/**
 * Reports the result of constraint violations
 *                                                    `
 * @author Emmanuel Bernard
 */
public class ConstraintViolationException extends ValidationException {
    private final Set&lt;ConstraintViolation&lt;?&gt;&gt; constraintViolations;

    /**
     * Creates a constraint violation report
     *
     * @param message error message
     * @param constraintViolations &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;ConstraintViolation&lt;/code&gt;
     */
    public ConstraintViolationException(String message,
                                        Set&lt;ConstraintViolation&lt;?&gt;&gt; constraintViolations) {
        super( message );
        this.constraintViolations = constraintViolations;
    }

    /**
     * Creates a constraint violation report
     *
     * @param constraintViolations &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;ConstraintViolation&lt;/code&gt;
     */
    public ConstraintViolationException(Set&lt;ConstraintViolation&lt;?&gt;&gt; constraintViolations) {
        super();
        this.constraintViolations = constraintViolations;
    }

    /**
     * Set of constraint violations reported during a validation
     *
     * @return &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;ConstraintViolation&lt;/code&gt;
     */
    public Set&lt;ConstraintViolation&lt;?&gt;&gt; getConstraintViolations() {
        return constraintViolations;
    }
}</pre><p>The <tt class="classname">ConstraintViolationException</tt> carries a
    <tt class="classname">Set</tt> of
    <tt class="classname">ConstraintViolation</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Bean Validation never raises this exception itself. Other
      frameworks like Java Persistence 2 do.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If this exception is meant to be send remotely,
      <tt class="classname">ConstraintViolation</tt> objects should be
      <tt class="classname">Serializable</tt> as defined an explained in <a href="#validationapi-constraintviolation" title="5.2.&nbsp;ConstraintViolation">Section&nbsp;5.2, &#8220;ConstraintViolation&#8221;</a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8635"></a>9.2.&nbsp;Constraint definition:
    <tt class="classname">ConstraintDefinitionException</tt></h2></div></div><div></div></div><p>If a constraint definition does not respect the Bean Validation
    rules or is inconsistent, a
    <tt class="classname">ConstraintDefinitionException</tt> is raised.
    <tt class="classname">ConstraintDefinitionException</tt> is a subclass of
    <tt class="classname">ValidationException</tt>.</p><p>This exception can be raised during validation or when the metadata
    model for the class hosting this constraint is requested.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>These exception cases can be determined at compile time by a tool
      such as an annotation processor.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8656"></a>9.3.&nbsp;Constraint declaration:
    <tt class="classname">ConstraintDeclarationException</tt> and
    <tt class="classname">UnexpectedTypeException</tt></h2></div></div><div></div></div><p>When a constraint declaration is illegal,
    <tt class="classname">ConstraintDeclarationException</tt> is raised.</p><p><tt class="classname">ConstraintDeclarationException</tt> is a subclass
    of <tt class="classname">ValidationException</tt>.</p><p>When the return type of a property cannot be processed for a given
    constraint, an <tt class="classname">UnexpectedTypeException</tt> is raised.
    This problem typically arise when either no
    <tt class="classname">ConstraintValidator</tt> or too many
    <tt class="classname">ConstraintValidator</tt>s match the return type (see
    <a href="#typevalidatorresolution" title="4.6.4.&nbsp;ConstraintValidator resolution algorithm">Section&nbsp;4.6.4, &#8220;ConstraintValidator resolution algorithm&#8221;</a>).</p><p><tt class="classname">UnexpectedTypeException</tt> is a subclass of
    <tt class="classname">ConstraintDeclarationException</tt>.</p><p>This exception can be raised during validation or when the metadata
    model for the class hosting this constraint is requested.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>These exception cases can be determined at compile time by a tool
      such as an annotation processor.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8701"></a>9.4.&nbsp;Group definition:
    <tt class="classname">GroupDefinitionException</tt></h2></div></div><div></div></div><p>When a group definition is illegal,
    <tt class="classname">GroupDefinitionException</tt> is raised. This typically
    arises when a cyclic group dependency is discovered, an illegal attribute
    overriding is defined etc.</p><p><tt class="classname">GroupDefinitionException</tt> is a subclass of
    <tt class="classname">ValidationException</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>These exception cases can be determined at compile time by a tool
      such as an annotation processor.</p></div></div></div><div class="added"><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="integration"></a>Chapter&nbsp;10.&nbsp;Integration</h2></div></div><div></div></div><div class="added"><p>In this chapter integration points between Bean
  Validation and other technologies are discussed. Generally speaking,
  containers and frameworks controlling the life cycle of objects (such as
  Java EE, dependency injection frameworks or component frameworks)
  should:</p></div><div class="added"><div class="itemizedlist"><ul type="disc"><li><p>build and bootstrap the <tt class="classname">ValidatorFactory</tt>
      instance for an application.</p></li><li><p>provide access to the <tt class="classname">ValidatorFactory</tt>
      instance as well as <tt class="classname">Validator</tt> instances in their
      default configuration using the paradigm of the container: for example,
      such instances would be injectable in other objects via a dependency
      injection framework.</p></li><li><p>configure <tt class="classname">ValidatorFactory</tt> with a custom
      <tt class="classname">ConstraintValidatorFactory</tt> instance that returns
      managed <tt class="classname">ConstraintValidator</tt> instances, unless a
      custom <tt class="classname">ConstraintValidatorFactory</tt> is requested by
      the user. The scope of <tt class="classname">ConstraintValidator</tt>
      instances is still fully controlled by the Bean Validation provider as
      described in <a href="#constraintsdefinitionimplementation-constraintfactory" title="3.5.&nbsp;The ConstraintValidatorFactory">Section&nbsp;3.5, &#8220;The ConstraintValidatorFactory&#8221;</a>, but
      as managed beans they can receive expected services like injection of
      other objects.</p></li><li><p>configure <tt class="classname">ValidatorFactory</tt> with managed
      instances of <tt class="classname">ConstraintValidatorFactory</tt>,
      <tt class="classname">MessageInterpolator</tt>,
      <tt class="classname">ParameterNameProvider</tt> and
      <tt class="classname">TraversableResolver</tt>, if such instances are
      defined in the XML deployment descriptor. Services provided by the
      container (like dependency injection) should thus be available to these
      instances.</p></li></ul></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>In this context a default <tt class="classname">ValidatorFactory</tt>
      is a factory configure like the factory returned by
      <tt class="classname">Validation.buildDefaultValidatorFactory</tt> (see also
      <a href="#boostrapping-validation" title="5.5.5.&nbsp;Validation">Section&nbsp;5.5.5, &#8220;Validation&#8221;</a>) except for the enhancements
      described above. A default <tt class="classname">Validator</tt> instance is
      a <tt class="classname">Validator</tt> instance retrieved via
      <tt class="methodname">getValidator</tt> from the default
      <tt class="classname">ValidatorFactory</tt>.</p></div><div class="added"><p>A user is free to explicitly use the bootstrap
  API to customize the <tt class="classname">ValidatorFactory</tt> as
  needed.</p></div><div class="added"><p>Method interception frameworks (such as AOP or
  interceptor frameworks) should also enable interception of constrained
  method following the steps defined in <a href="#validationapi-triggeringmethodvalidation" title="5.4.&nbsp;Triggering method validation">Section&nbsp;5.4, &#8220;Triggering method validation&#8221;</a>. Method validation
  should be implicit for any method or constructor annotated with
  constraints.</p></div><div class="added"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="integration-javaee"></a>10.1.&nbsp;Java EE</h2></div></div><div></div></div><p>Java EE must obey the rules defined above and make the following
    instances available under JNDI:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">ValidatorFactory</tt> under
          <tt class="constant">java:comp/ValidatorFactory</tt></p></li><li><p><tt class="classname">Validator</tt> under
          <tt class="constant">java:comp/Validator</tt></p></li></ul></div><p>Instead of looking the instances up via JNDI, the user can request
    them to be injected via the <tt class="classname">Resource</tt>
    annotation:</p><pre class="programlisting">@Resource ValidatorFactory validatorFactory;
@Resource Validator validator;</pre></div></div><div class="added"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8841"></a>10.2.&nbsp;Context and Dependency Injection (CDI)
    integration</h2></div></div><div></div></div><p>There are several integrations points between Bean Validation and
    CDI. These are discussed in the following sections.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8846"></a>10.2.1.&nbsp;<tt class="classname">ValidatorFactory</tt> and
      <tt class="classname">Validator</tt></h3></div></div><div></div></div><p>Similar to the Java EE integration via
      <tt class="classname">@Resource</tt> (see <a href="#integration-javaee" title="10.1.&nbsp;Java EE">Section&nbsp;10.1, &#8220;Java EE&#8221;</a>), a CDI container must allow the
      injection of the default <tt class="classname">ValidatorFactory</tt> and
      <tt class="classname">Validator</tt> via
      <tt class="classname">@Inject</tt>:</p><pre class="programlisting">@Inject ValidatorFactory;
@Inject Validator;
</pre><p>These default instances must be injectable via the
      <tt class="classname">@Default</tt> qualifier even if there are multiple
      Bean Validation providers available.</p><p>Every Bean Validation provider should provide a CDI Extension (or
      alternative solution provided it fulfills the requirements) in order to
      make its implementation available for the container. The following rules
      apply:</p><div class="itemizedlist"><ul type="disc"><li><p>At registration, the extension verifies the existence of a
            built-in bean with bean type
            <tt class="classname">javax.validation.ValidatorFactory</tt> and a
            built-in bean with bean type
            <tt class="classname">javax.validation.Validator</tt>, allowing
            injection of the default <tt class="classname">ValidatorFactory</tt>
            and a <tt class="classname">Validator</tt>. Both built-in beans must
            have the qualifier <tt class="classname">@Default</tt>. These beans
            are passivation capable dependencies, as defined in the CDI
            specification.</p><div class="itemizedlist"><ul type="circle"><li><p>If there are no default
                  <tt class="classname">ValidatorFactory</tt> and
                  <tt class="classname">Validator</tt> beans, it is the
                  responsibility of the extension to register them. The
                  extension creates and registers a default
                  <tt class="classname">ValidatorFactory</tt> respective
                  <tt class="classname">Validator</tt> bean using the
                  bootstrapping API as discussed in the introduction of this
                  chapter.</p></li><li><p>If the default <tt class="classname">ValidatorFactory</tt>
                  and <tt class="classname">Validator</tt> instances are already
                  registered no action needs to be taken.</p></li></ul></div></li><li><p>On top of the default
            <tt class="classname">ValidatorFactory</tt> and
            <tt class="classname">Validator</tt> beans, the Bean Validation
            provider can register an additional
            <tt class="classname">ValidatorFactory</tt> and its respective
            <tt class="classname">Validator</tt> bean provided they are registered
            with a custom qualifier, for example <tt class="classname">@ACME</tt>,
            to prevent an ambiguous dependency due to multiple beans being
            eligible for injection to the injection point. Using the product
            name or brand for the qualifier is considered good
            practice.</p><pre class="programlisting">@Inject @ACME ValidatorFactory;
@Inject @ACME Validator;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>These rules ensure that in any CDI container (Java SE or
                EE environment), a default injectable
                <tt class="classname">ValidatorFactory</tt> and
                <tt class="classname">Validator</tt> bean are made available by
                adding the Bean Validation provider's CDI extension and its
                dependencies.</p></div></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8950"></a>10.2.2.&nbsp;<tt class="classname">ConstraintValidatorFactory</tt>,
      <tt class="classname">MessageInterpolator</tt>,
      <tt class="classname">ParameterNameProvider</tt> and
      <tt class="classname">TraversableResolver</tt></h3></div></div><div></div></div><p>If the CDI Extension of the Bean Validation provider is creating
      the <tt class="classname">ValidatorFactory</tt> and a custom
      <tt class="classname">ConstraintValidatorFactory</tt>,
      <tt class="classname">MessageInterpolator</tt>,
      <tt class="classname">ParameterNameProvider</tt> or
      <tt class="classname">TraversableResolver</tt> class is defined in the XML
      deployment descriptor (see <a href="#xml-config" title="5.5.6.&nbsp;XML Configuration: META-INF/validation.xml">Section&nbsp;5.5.6, &#8220;XML Configuration: META-INF/validation.xml&#8221;</a>), the
      <tt class="classname">ValidatorFactory</tt> must be configured with managed
      instances of the requested classes. Services provided by the container
      (like dependency injection) should thus be available to this
      instance.</p><p>If no custom <tt class="classname">ConstraintValidatorFactory</tt> is
      requested by the user, the <tt class="classname">ValidatorFactory</tt> must
      be configured with a custom
      <tt class="classname">ConstraintValidatorFactory</tt> instance that returns
      managed <tt class="classname">ConstraintValidator</tt> instances. The
      factory</p><div class="itemizedlist"><ul type="disc"><li><p>creates non-contextual
            <tt class="classname">ConstraintValidator</tt> instances for each
            <tt class="methodname">ConstraintValidatorFactory.getInstance</tt>
            call. To inject dependencies into the
            <tt class="classname">ConstraintValidator</tt> instance, the CDI
            <tt class="classname">InjectionTarget</tt> API should be used. Before
            returning the instance the following calls should be made
            <tt class="classname">InjectionTarget.produce()</tt>,
            <tt class="classname">InjectionTarget.inject()</tt> and
            <tt class="classname">InjectionTarget.postConstruct()</tt>.</p></li><li><p>calls <tt class="classname">InjectionTarget.preDestroy()</tt>
            and <tt class="classname">InjectionTarget.dispose()</tt> upon
            <tt class="classname">ConstraintValidatorFactory.releaseInstance</tt>
            (see also <a href="#constraintsdefinitionimplementation-constraintfactory" title="3.5.&nbsp;The ConstraintValidatorFactory">Section&nbsp;3.5, &#8220;The ConstraintValidatorFactory&#8221;</a>
            for more information about the life cycle of a
            <tt class="classname">ConstraintValidator</tt>).</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9041"></a>10.2.3.&nbsp;Method validation</h3></div></div><div></div></div><p>A Bean Validation provider also provides an CDI interceptor for
      method validation. This interceptor implements the steps specified in
      <a href="#validationapi-triggeringmethodvalidation" title="5.4.&nbsp;Triggering method validation">Section&nbsp;5.4, &#8220;Triggering method validation&#8221;</a>.</p><p>Ordinarily CDI requires that intercepted methods are annotated
      with a so called interceptor binding annotation. To make method
      validation implicit by just adding the Bean Validation constraints to a
      constructor or method, the interceptor biding annotation needs to be
      added programmatically to any method requiring validation.
      <tt class="classname">javax.validation.spi.MethodValidated</tt> is to be
      used as binding annotation. All this is transparent to the user.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>It is recommended to only add the interceptor for constrained
          methods. <a href="#validationapi-triggeringmethodvalidation" title="5.4.&nbsp;Triggering method validation">Section&nbsp;5.4, &#8220;Triggering method validation&#8221;</a>
          gives examples how the metadata API can be used to determine whether
          or not a method is constrained.</p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>A CDI extension can observe the
          <tt class="classname">ProcessAnnotatedType</tt> event in order to add
          the interceptor binding annotation.</p></div></div></div></div><div class="added"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9064"></a>10.3.&nbsp;Java Persistence 2.0 integration</h2></div></div><div></div></div><p>Integration with Java Persistence is described in the Java
    Persistence 2 specification (JSR-317). Persistence frameworks are
    encouraged to mimic the integration work done with Java Persistence (see
    also <a href="https://hibernate.onjira.com/browse/BVAL-318" target="_top">BVAL-318</a>).</p></div></div><div class="added"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9072"></a>10.4.&nbsp;Java Server Faces 2.0 integration</h2></div></div><div></div></div><p>Integration with Java Server Faces is described in the Java Server
    Faces 2 specification (JSR-314). Presentation frameworks are encouraged to
    study the integration work done with JSF 2 (see also <a href="https://hibernate.onjira.com/browse/BVAL-319" target="_top">BVAL-319</a>).</p></div></div><div class="added"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9080"></a>10.5.&nbsp;JAX-RS 2 integration</h2></div></div><div></div></div><p>See <a href="https://hibernate.onjira.com/browse/BVAL-323" target="_top">BVAL-323</a>.</p></div></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="terminology"></a>Appendix&nbsp;A.&nbsp;Terminology</h2></div></div><div></div></div><p>This appendix aims at giving an overview on the different key terms
  used through this specification. They are not to be considered formal
  definitions. Formal definitions are to be inferred from the core
  specification.</p><div class="table"><a name="d0e9093"></a><p class="title"><b>Table&nbsp;A.1.&nbsp;terminology</b></p><table summary="terminology" border="1"><colgroup><col><col></colgroup><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody><tr><td>Constraint</td><td>A restriction on a bean instance, the value of a field or the
          value of a JavaBean property</td></tr><tr><td>Constraint declaration</td><td>Assignment of a constraint to a target (bean, field,
          property) for a specific class. Typically by declaring an annotation
          on the target but can also be done through a XML deployment
          descriptor</td></tr><tr><td>Validation routine</td><td><p>Sequence of operations executed by the Bean Validation
          provider to validate a given object graph</p></td></tr><tr><td>Constraint definition</td><td>Defines a type of constraint, its attributes and the actual
          constraint validation implementations. Done through annotations. The
          list of constraint validation implementations can be provided via
          XML</td></tr><tr><td>group</td><td>Constraints can belong to one or more group or context.
          Useful to apply a subset of the constraints for a given use case. By
          default, the <tt class="literal">Default</tt> group is used.</td></tr><tr><td>group sequence</td><td>Define a group ordering in the validation process. If a given
          group in the sequence contains one or more failure, the following
          groups in the sequence must be ignored.</td></tr><tr><td>Constraint validation</td><td>Constraint logic algorithm used to determine whether a given
          value passes a constraint or not.</td></tr><tr><td>Constraint validation implementation</td><td>Class implementing the constraint logic and used to determine
          whether a given value pass a constraint or not.</td></tr><tr><td>Bean validation provider</td><td>Product implementing this specification</td></tr><tr><td>Message interpolator</td><td>Algorithm used to build the end user message associated to a
          constraint failure. Typically useful for i18n</td></tr><tr><td>Constraint metadata API</td><td>API exposing the constraints applied to a given bean type.
          Also considered one of the integration points with other JSR or
          frameworks.</td></tr><tr><td>Bootstrap API</td><td>Bootstrapping part of the Bean Validation API producing a
          <tt class="classname">ValidatorFactory</tt>.</td></tr><tr><td>javax.validation.ConstraintValidator</td><td>Interface implemented by a constraint validation
          implementation</td></tr><tr><td>Composing constraint</td><td>Constraint declared on another constraint definition. When
          the main constraint is validated, the composing constraints are
          validated too.</td></tr><tr><td>javax.validation.Validator</td><td>Main API. Holds contracts to validate object graphs</td></tr><tr><td>javax.validation.ConstraintViolation</td><td>Interface describing a given constraint failure on a given
          bean</td></tr></tbody></table></div><p></p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="standard-resolver-messages"></a>Appendix&nbsp;B.&nbsp;Standard ResourceBundle messages</h2></div></div><div></div></div><p>The properties listed below are resolved by the default message
  interpolator.</p><pre class="programlisting">javax.validation.constraints.Null.message=must be null
javax.validation.constraints.NotNull.message=must not be null
javax.validation.constraints.AssertTrue.message=must be true
javax.validation.constraints.AssertFalse.message=must be false
javax.validation.constraints.Min.message=must be greater than or equal to {value}
javax.validation.constraints.Max.message=must be less than or equal to {value}
javax.validation.constraints.Size.message=size must be between {min} and {max}
javax.validation.constraints.Digits.message= \
    numeric value out of bounds (&lt;{integer} digits&gt;.&lt;{fraction} digits&gt; expected)
javax.validation.constraints.Past.message=must be a past date
javax.validation.constraints.Future.message=must be a future date
javax.validation.constraints.Pattern.message=must match the following regular expression: {regexp}</pre></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-jpa"></a>Appendix&nbsp;C.&nbsp;Java Persistence 2.0 and schema generation</h2></div></div><div></div></div><p>While not specified by this specification or the Java Persistence 2.0
  specification, Persistence Providers are encouraged to make use of Bean
  Validation constraint metadata when generating DDL schemas. The proposal is
  as followed.</p><pre class="programlisting">Ideas explored and not standardized

Java Persistence consumes Bean Validation (BV) metadata to enhance persistence property 
metadata.

A Persistence provider must use the BV metadata of a given list of groups. 
The default group evaluated is Default (default BV group). Groups evaluated 
can be overridden by a property. 
This property contains the comma separated groups (fully qualified class name).

For each entity, apply the following algorithm. 
For each persistent property in a given entity: 
 - extract the list of BV constraints (including the composing constraints) 
 - determine the subset of applicable constraints 
    (i.e. constraints understood by the persistence provider)
 - apply these constraints on the persistent property metadata 
 - if the property type is an embeddable object or a collection 
of embeddable objects, apply the algorithm on the embeddable object properties

The list of constraints that must be understood by persistence providers are
as followed:
 - @NotNull should be considered equivalent to @Column(nullable=false) / 
     @JoinColumn(nullable=false)
 - @Size.max should be considered equivalent to @Column.length 
     for String properties 
 - @Digits (which contains integer and fraction) should be considered 
     equivalent to @Column.precision = integer+fraction, 
     @Column.scale = fraction for decimal columns

The BV annotation metadata should have priority over JPA metadata 
(JPA has no sensible "unset" values on their annotations).

Question: should we add @Unique that would map to @Column(unique=true)? 
@Unique cannot be tested at the Java level reliably but could generate
a database unique constraint generation. @Unique is not part 
of the BV spec today.

Persistence Provider should optionally recognize and try to apply the 
following constraints as well:
 - @Min / @Max on numeric columns (TODO String too?)
 - @Future / @Past on temporal columns
 - @Size for collections and array (not sure it is feasible).

Persistence Providers can also apply non standard constraints to their metadata model. 
For example, provider ACME might recognize and understand @com.acme.validation.Email 
and apply it to the database model.

While most high level constraints will not be recognize, the BV built-in constraints 
will be the common language spoken by Persistence Providers. Any high level constraint 
can be composed of more modular constraints (constraint composition).

* additional proposal
In case of a constraint violation report detected and generated by the database 
(not null, etc), the Java persistence provider catches this report and translates 
it into a BV error report. From the perspective of the application, constraint 
errors are viewed through a unified layer. BV must provide some API to create a 
constraint violation error (constraintDescriptor.createConstraintViolation(...)).

While this proposal has a lot of value-add, I wonder how difficult it can be to 
implement this in persistence providers.

Provide a way to disable BV metadata use by a persistence provider (property based).</pre><p>This is not an endorsement of the Java Persistence expert group or the
  Bean Validation expert group. Such approach may nor may not be standardized
  in the future. Such integration should not be considered portable.</p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="changelog"></a>Appendix&nbsp;D.&nbsp;Changelog</h2></div></div><div></div></div><div class="changed"><div class="example"><a name="d0e9212"></a><p class="title"><b>Example&nbsp;D.1.&nbsp;Changelog</b></p><pre class="programlisting">1.1.0.Beta1 (public review draft 1) (2010-10-19)
------------------------------------------------

** Sub-task
    * [BVAL-232] - Support cross-parameter constraints
    * [BVAL-274] - Extend the meta-data API with required convenience methods for method validation
    * [BVAL-290] - Mark new method with @since annotation
    * [BVAL-300] - Clarify behavior of constructor validation in class hierachies 
    * [BVAL-308] - Settle on approach for constraint refinement in sub-types
    * [BVAL-309] - Specify logic to be implemented by method validation interceptors
    * [BVAL-310] - Move methods related to method validation to delegate interface
    * [BVAL-317] - Rename 'method-level validation' with 'method validation'


** Bug
    * [BVAL-296] - Example using ConstraintValidatorContext is incorrect
    * [BVAL-298] - DefaultValidationProviderResolver should check context and current class loader for service file
    * [BVAL-304] - Add OSGi headers in the reference implementation
    * [BVAL-306] - Clarify interceptor order in method validation triggering



** Improvement
    * [BVAL-208] - Support groups translation during cascaded validations 
    * [BVAL-226] - Make clear whether the static or the runtime type should be considered when creating property paths in case of cascaded validations
    * [BVAL-230] - Add support for validating CharSequence types instead of just Strings
    * [BVAL-259] - Evaluation of composed constraints should stops on first validation error in case of @ReportAsSingleViolation
    * [BVAL-281] - Improve message when building a ValidatorFactory but no provider is available in the classpath
    * [BVAL-292] - Clarify the behavior of ConfigurationSource methods when no configuration file is present
    * [BVAL-299] - Add note on required Java version

** New Feature
    * [BVAL-295] - Should validation-configuration and validation-mapping xsds define a version attribute


** Task
    * [BVAL-280] - Decide whether DefaultValidationProviderResolver should not throw an exception when a specified provider cannot be loaded
    * [BVAL-307] - Decide how CDI and Bean Validation is integrated


1.1.0.Alpha1 (early draft 1) (2012-03-13)
-----------------------------------------

** Sub-task
    * [BVAL-242] - Extend the meta-data API to represent method-level constraints
    * [BVAL-243] - Provide a means for specifying method parameter names
    * [BVAL-244] - Extend Validator API with methods for method validation
    * [BVAL-245] - Define how method constraints are declared at parameters and return values


** Bug
    * [BVAL-194] - Invalid license info
    * [BVAL-196] - Missing &lt;/code&gt; element in Javadocs for ConstraintValidatorContext.ConstraintViolationBuilder.NodeContextBuilder
    * [BVAL-212] - Wrong closing &lt;/code&gt; element in javadocs of BeanDescriptor
    * [BVAL-236] - Fails to load META-INF/services provider configuration files on non-ASCII platforms 


** Improvement
    * [BVAL-201] - Fix typo in spec, chapter 4.4.3
    * [BVAL-270] - Specify that Bean Validation 1.1 providers must support deployment descriptors version 1.0

** New Feature
    * [BVAL-238] - Support for container injection in ConstraintValidator
    * [BVAL-241] - Support for method validation
    * [BVAL-258] - Clean introduction section to reflect Bean Validation 1.1
    * [BVAL-263] - Add a close() method to ValidatorFactory
    * [BVAL-265] - Expose settings defined in XML in the Configuration API (for ConstraintValidatorFactory, MessageInterpolator etc)


** Task
    * [BVAL-206] - Update pom to use the new distributationManagement information
    * [BVAL-228] - Prepare specification document and Git repository for public eyes
    * [BVAL-279] - Update POM file for Bean Validation API to use latest Git repo urls and generally be ready for a release


1.0.0 final (2009-10-12)
------------------------

** Bug
    * [BVAL-181] - Fix some namespace issues in validation-configuration-1.0.xsd


** Improvement
    * [BVAL-182] - Add getDefaultTraversableResolver and getDefaultConstraintValidatorFactory to Configuration
    * [BVAL-183] - Add getTraversableResolver and getConstraintValidatorFactory to ValidatorFactory
    * [BVAL-184] - Replace Red Hat Middleware LLC to Red Hat, Inc. and/or its affiliates
    * [BVAL-186] - Clarify method names on the constraint violation builder DSL of ConstraintValidatorContext
    * [BVAL-187] - Imply that ConstraintViolation is serializable if entities are serializable

** New Feature
    * [BVAL-185] - Allow overriding of ConstraintValidatorFactory when creating a Validator
    * [BVAL-190] - Add methods to filter ConstraintDescriptor per groups, target and scope


** Task
    * [BVAL-132] - Define behaviour for BeanDescriptor.getConstraintsForProperty(null)



1.0.CR5 (2009-08-27)
--------------------

** Bug
    * [BVAL-173] - Fix typo getUnorderdConstraintDescriptorsMatchingGroups =&gt; getUnorderedConstraintDescriptorsMatchingGroups
    * [BVAL-177] - Payload of composed constraints are ignored, the main constraint payload is propagated
    * [BVAL-178] - Add payload to the XML schema
    * [BVAL-180] - ConstraintDescriptor.getPayload() should return Set&lt;Class&lt;? extends Payload&gt;&gt; not Set&lt;Class&lt;Payload&gt;&gt;


** Improvement
    * [BVAL-174] - clearer default message for assertTrue and assertFalse
    * [BVAL-179] - Rename ConstraintPayload to Payload



1.0.CR4 Unpublished release
---------------------------



1.0.CR3 Proposed Final Draft 2 (2009-07-08)
-------------------------------------------

** Bug
    * [BVAL-144] - validation-configuration.xsd property element does not extend basic string type preventing Oxygen to be happy
    * [BVAL-159] - Fix example 3.8 on object graph validation 


** Improvement
    * [BVAL-143] - Describe path with an object model
    * [BVAL-147] - Support for unbounded wildcards in ConstraintValidator
    * [BVAL-148] - Built-in constraints annotations now annotated with @Constraint(validatedBy={})
    * [BVAL-151] - TraversableResolver#isTraversable can receive null traversableObject when valudateValue is called
    * [BVAL-152] - TraversableResolver should differentiate reachability and cascadability
    * [BVAL-153] - Generify ConstraintValidatorException
    * [BVAL-154] - Iterable is a superclass of all collection, clarify it's interaction with @Valid
    * [BVAL-155] - ignore-annotation is not inherited hierarchically: make that explicit
    * [BVAL-156] - Pattern.Flag takes the JDK flag int at construction time
    * [BVAL-157] - Add [] to non-indexed iterable path 
    * [BVAL-158] - Clarify that @Valid is orthogonal to the idea of group
    * [BVAL-160] - rename message template key as [f.q.c.n of the constraint].message
    * [BVAL-162] - Move metadata classes to the metadata package (BeanDescriptor, ElementDescriptor, PropertyDescriptor, ConstraintDescriptor)
    * [BVAL-164] - Validation.byProvider now accept the provider implementation class
    * [BVAL-166] - IllegalArgumentException raised on BeanDescriptor.getConstraintsForProperty and Validator.getConstraintsForClass
    * [BVAL-167] - Recommend f.q.c.n.message for resource bundle keys and migrate examples
    * [BVAL-169] - Rename ElementDescriptor.getType to getElementClass
    * [BVAL-170] - Let built-in annotations to support ElementType.PARAMETER and ElementType.CONSTRUCTOR

** New Feature
    * [BVAL-149] - Provide access to the ValidationProviderResolver via BootstrapState
    * [BVAL-150] - Add ConstraintViolation.getRootBeanClass
    * [BVAL-161] - Add unwrap methods to ValidatorFactory and Validator
    * [BVAL-163] - Add support for constraint payload
    * [BVAL-168] - Return the list of matching ConstraintDescriptor for a given set of groups
    * [BVAL-172] - Provide ConstraintDescriptor#getPayload



1.0.CR2 Unpublished release
---------------------------



1.0.CR1 Proposed Final Draft (2009-03-16)
-----------------------------------------


** Bug
    * [BVAL-118] - ConstraintDescriptor.getGroups() returns Default if no group is declared on the constraint
    * [BVAL-125] - @Size.min default value should be 0


** Improvement
    * [BVAL-32] - Describe what is happening when a composition is not consistent
    * [BVAL-50] - Be consistent in the spec, use @author or not
    * [BVAL-54] - Specify that constraints on non getter methods are ignored (if BVAL-36 is not accepted)
    * [BVAL-72] - Validating an object multiple times if in a different branch of the graph
    * [BVAL-86] - Default TraversableResolver is JPA aware
    * [BVAL-88] - Improvement on MessageInterpolator
    * [BVAL-91] - Rename Constraint related classes to improve readability
    * [BVAL-95] - @Size should support Map
    * [BVAL-96] - Support byte in @Min/@Max
    * [BVAL-106] - Constraintdescriptor.getConstraintValidatorClasses() should return a List, not an array
    * [BVAL-114] - Relax property names in ConstraintValidatorContext
    * [BVAL-120] - Rename ConstraintViolation getRawMessage=&gt;getMessageTemplate, getInterpolatedMessage=&gt;getMessage
    * [BVAL-122] - Rename @GroupSequence.sequence to @GroupSequence.value
    * [BVAL-126] - Define group sequence logic more formally and eliminate corner cases
    * [BVAL-129] - Clarify ConstraintValidatorContext propertyPath generation
    * [BVAL-130] - Make ConstraintDescriptor generic: ConstraintDescriptor&lt;T extends Annotation&gt;
    * [BVAL-131] - Provide object graph navigation determinism
    * [BVAL-134] - @Valid accepts objects implementing Iterable 
    * [BVAL-135] - Remove DefaultValidationProviderResolver from the public API
    * [BVAL-136] - Add Context object for MessageInterpolator
    * [BVAL-137] - prefix for message template key is constraint. instead of validator.
    * [BVAL-138] - Rename OverridesParameter to OverridesAttribute
    * [BVAL-139] - Remove @OverridesParameters and use the inner class mode (OverridesAttribute.LIst)
    * [BVAL-140] - BeanDescriptor.getConstrainedProperties() returns Set&lt;PropertyDescriptor&gt;
    * [BVAL-141] - Rename ConstraintDescriptor.getParameters() to getAttributes()

** New Feature
    * [BVAL-52] - Define the exception hierarchy and rules
    * [BVAL-55] - Exception policy
    * [BVAL-65] - Additional built-in constraints
    * [BVAL-98] - Type-safe ConstraintValidator
    * [BVAL-100] - Support XML mapping overriding
    * [BVAL-102] - Support META-INF/validation.xml
    * [BVAL-119] - Introduce @Pattern for regexp
    * [BVAL-121] - Define built-in constraints plural forms
    * [BVAL-123] - Add ConstraintViolationException
    * [BVAL-124] - Introduce backslash as escaping character
    * [BVAL-142] - @Min/@max no longer accept float/double and introduce @DecimalMin/@DecimalMax


** Task
    * [BVAL-24] - What should be done when multiple META-INF/validation.xml are found?
    * [BVAL-117] - Specify behaviour of ConstraintValidator.initalize in the case of inconsistent values in constraint parameters
    * [BVAL-127] - Remove ConstraintViolation.getGroups()
    * [BVAL-128] - Clarify invalid cases for validateProperty / validateValue on proeprtyName being empty or null
    * [BVAL-133] - Remove JPA and JSF integration proposals




1.0.Beta2 Public Draft (2008-12-15)
-----------------------------------


** Bug
    * [BVAL-6] - Wrong example in validation methods section
    * [BVAL-17] - Validator&lt;A&gt;.validate(b) where b:B and B extends A should validate B. Metadata APIs are specific to A
    * [BVAL-42] - Names of message keys in spec inconsistent
    * [BVAL-45] - Typo at ConstraintDescriptor.getContstraintClass()


** Improvement
    * [BVAL-29] - Types should be determined at runtime
    * [BVAL-33] - Should ConstraintDescriptor.getConstraintImplementation() replaced by .getConstraintImplementationClass()?
    * [BVAL-40] - Rename InvalidConstraint to ConstraintViolation
    * [BVAL-48] - Add a way to access the default message resolver
    * [BVAL-49] - Mark metadata classes as immutable
    * [BVAL-59] - Rethink the group sequence inheritance rules
    * [BVAL-60] - ConstraintViolation points to the corresponding ConstraintDescriptor
    * [BVAL-68] - Specify that static methods and fields are not validated
    * [BVAL-73] - Rename ConstraintViolation.getBeanClass() to CV. getRootClass() or simply remove it
    * [BVAL-78] - Forbid a Validation implementation to modify the state of the object being validated

** New Feature
    * [BVAL-30] - Define validation Context to be passed to constraint implementation calls
    * [BVAL-36] - Validation of method parameters and returned values
    * [BVAL-67] - Allow MessageResolver to be Localizable
    * [BVAL-71] - Should we have group aggregation?
    * [BVAL-76] - Expose the raw message to ConstraintViolation
    * [BVAL-79] - Groups are now Type based rather than String based
    * [BVAL-81] - Provide a TraversableResolver contract


** Task
    * [BVAL-1] - Remove references to 'beancheck' in the spec
    * [BVAL-3] - Replace array return types with Sets
    * [BVAL-4] - Return value for @NotEmpty for null values
    * [BVAL-5] - Change order of exmaple classes in Book/Author example
    * [BVAL-7] - Use of example in ConstraintFactory section (2.4)
    * [BVAL-8] - StandardConstraint description (2.5)
    * [BVAL-23] - Make Validator&lt;T&gt; thread-safe</pre></div></div></div></div></body></html>