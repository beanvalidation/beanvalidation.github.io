<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>JSR 303: Bean Validation</title><link rel="stylesheet" href="css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>JSR 303: Bean Validation</h1></div><div><div class="authorgroup"><h3 class="corpauthor">Bean Validation Expert Group</h3><div class="author"><h3 class="author"><span class="firstname">Emmanuel</span> <span class="surname">Bernard</span></h3><div class="affiliation"><span class="orgname">Red Hat, Inc.<br></span></div></div><div class="author"><h3 class="author"><span class="firstname">Steve</span> <span class="surname">Peterson</span></h3></div></div></div><div><p class="releaseinfo">1.0 final</p></div><div><p class="copyright">Copyright &copy; 2007-2009 Red Hat, Inc</p></div><div><p class="pubdate">2009-10-12</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#d0e32">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e37">1.1. Expert group</a></span></dt><dt><span class="section"><a href="#d0e112">1.2. Specification goals</a></span></dt><dt><span class="section"><a href="#d0e121">1.3. How this document is organized</a></span></dt><dt><span class="section"><a href="#d0e154">1.4. How to comment</a></span></dt></dl></dd><dt><span class="chapter"><a href="#constraintsdefinitionimplementation">2. Constraint Definition</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintdefinition">2.1. Constraint annotation</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintdefinition-properties">2.1.1. Constraint definition properties</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintdefinition-parameters-message">2.1.1.1. message</a></span></dt><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintdefinition-groups">2.1.1.2. groups</a></span></dt><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintdefinition-payload">2.1.1.3. payload</a></span></dt><dt><span class="section"><a href="#d0e358">2.1.1.4. Constraint specific parameter</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e366">2.1.2. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#constraintsdefinitionimplementation-multipleconstraints">2.2. Applying multiple constraints of the same type</a></span></dt><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintcomposition">2.3. Constraint composition</a></span></dt><dt><span class="section"><a href="#constraintsdefinitionimplementation-validationimplementation">2.4. Constraint validation implementation</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintsdefinitionimplementation-validationimplementation-example">2.4.1. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#constraintsdefinitionimplementation-constraintfactory">2.5. The ConstraintValidatorFactory</a></span></dt></dl></dd><dt><span class="chapter"><a href="#constraintdeclarationvalidationprocess">3. Constraint declaration and validation process</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-requirements">3.1. Requirements on classes to be validated</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-requirements-object">3.1.1. Object validation</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-requirements-property">3.1.2. Field and property validation</a></span></dt><dt><span class="section"><a href="#d0e991">3.1.3. Graph validation</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1077">3.2. Constraint declaration</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-inheritance">3.3. Inheritance (interface and superclass)</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence">3.4. Group and group sequence</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence-groupinheritance">3.4.1. Group inheritance</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence-groupsequence">3.4.2. Group sequence</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup">3.4.3. Redefining the Default group for a class</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence-implicitgrouping">3.4.4. Implicit grouping</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-groupsequence-formaldefinition">3.4.5. Formal group definitions</a></span></dt></dl></dd><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-validationroutine">3.5. Validation routine</a></span></dt><dd><dl><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation">3.5.1. Object graph validation</a></span></dt><dt><span class="section"><a href="#constraintdeclarationvalidationprocess-validationroutine-traversable">3.5.2. Traversable property</a></span></dt><dt><span class="section"><a href="#typevalidatorresolution">3.5.3. ConstraintValidator resolution algorithm</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2749">3.6. Examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#validationapi">4. Validation APIs</a></span></dt><dd><dl><dt><span class="section"><a href="#validationapi-validatorapi">4.1. Validator API</a></span></dt><dd><dl><dt><span class="section"><a href="#validationapi-validatorapi-validationmethods">4.1.1. Validation methods</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3153">4.1.1.1. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#validationapi-validatorapi-groups">4.1.2. groups</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3241">4.1.2.1. Examples</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="#validationapi-constraintviolation">4.2. ConstraintViolation</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3779">4.2.1. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#validationapi-message">4.3. Message interpolation</a></span></dt><dd><dl><dt><span class="section"><a href="#default-messageresolver">4.3.1. Default message interpolation</a></span></dt><dd><dl><dt><span class="section"><a href="#default-resolution-algorithm">4.3.1.1. Default message interpolation algorithm</a></span></dt></dl></dd><dt><span class="section"><a href="#custom-message-resolution">4.3.2. Custom message interpolation</a></span></dt><dt><span class="section"><a href="#validationapi-message-examples">4.3.3. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#bootstrapping">4.4. Bootstrapping</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4236">4.4.1. Examples</a></span></dt><dt><span class="section"><a href="#d0e4310">4.4.2. ValidatorFactory</a></span></dt><dt><span class="section"><a href="#d0e4480">4.4.3. Configuration</a></span></dt><dt><span class="section"><a href="#d0e4781">4.4.4. ValidationProvider and ValidationProviderResolver</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4791">4.4.4.1. ValidationProviderResolver</a></span></dt><dt><span class="section"><a href="#id-bootstrap-validationprovider">4.4.4.2. ValidationProvider</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4985">4.4.5. Validation</a></span></dt><dt><span class="section"><a href="#xml-config">4.4.6. XML Configuration: META-INF/validation.xml</a></span></dt><dt><span class="section"><a href="#d0e5252">4.4.7. Usage</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#constraintmetadata">5. Constraint metadata request APIs</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5290">5.1. Validator</a></span></dt><dt><span class="section"><a href="#constraintmetadata-elementdescriptor">5.2. ElementDescriptor</a></span></dt><dt><span class="section"><a href="#d0e5439">5.3. BeanDescriptor</a></span></dt><dt><span class="section"><a href="#d0e5485">5.4. PropertyDescriptor</a></span></dt><dt><span class="section"><a href="#constraintmetadata-constraintdescriptor">5.5. ConstraintDescriptor</a></span></dt><dt><span class="section"><a href="#d0e5583">5.6. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e5601">6. Built-in Constraint definitions</a></span></dt><dt><span class="chapter"><a href="#xml">7. XML deployment descriptor</a></span></dt><dd><dl><dt><span class="section"><a href="#xml-mapping">7.1. Constraint definition and declaration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5731">7.1.1. Constraint declaration in XML</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5769">7.1.1.1. Class-level overriding</a></span></dt><dt><span class="section"><a href="#d0e5811">7.1.1.2. Field-level overriding</a></span></dt><dt><span class="section"><a href="#d0e5867">7.1.1.3. Property-level overriding</a></span></dt><dt><span class="section"><a href="#d0e5931">7.1.1.4. Constraint declaration</a></span></dt></dl></dd><dt><span class="section"><a href="#xml-mapping-constraintdefinition">7.1.2. Overriding constraint definitions in XML</a></span></dt><dt><span class="section"><a href="#xml-mapping-typeconversion">7.1.3. Converting the string representation of a value</a></span></dt><dt><span class="section"><a href="#xml-mapping-xsd">7.1.4. XML Schema</a></span></dt></dl></dd><dt><span class="section"><a href="#xml-config-xsd">7.2. Configuration schema</a></span></dt></dl></dd><dt><span class="chapter"><a href="#exception">8. Exception model</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6282">8.1. Error report:
      ConstraintViolationException</a></span></dt><dt><span class="section"><a href="#d0e6321">8.2. Constraint definition:
      ConstraintDefinitionException</a></span></dt><dt><span class="section"><a href="#d0e6342">8.3. Constraint declaration:
      ConstraintDeclarationException and
      UnexpectedTypeException</a></span></dt><dt><span class="section"><a href="#d0e6387">8.4. Group definition:
      GroupDefinitionException</a></span></dt></dl></dd><dt><span class="appendix"><a href="#terminology">A. Terminology</a></span></dt><dt><span class="appendix"><a href="#standard-resolver-messages">B. Standard ResourceBundle messages</a></span></dt><dt><span class="appendix"><a href="#appendix-methodlevelvalidation">C. Proposal for method-level validation</a></span></dt><dt><span class="appendix"><a href="#appendix-jpa">D. Java Persistence 2.0 integration</a></span></dt><dt><span class="appendix"><a href="#appendix-jsf">E. Java Server Faces 2.0 integration</a></span></dt><dt><span class="appendix"><a href="#appendix-ee">F. Proposal for Java EE integration</a></span></dt><dt><span class="appendix"><a href="#changelog">G. Changelog</a></span></dt></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e32"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div><div></div></div><p>This document is the specification of the Java API for JavaBean
    validation in Java EE and Java SE. The technical objective of this work is
    to provide a class level constraint declaration and validation facility
    for the Java application developer, as well as a constraint metadata
    repository and query API.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e37"></a>1.1.&nbsp;Expert group</h2></div></div><div></div></div><p>This work is being conducted as part of JSR 303 under the Java
      Community Process Program. This specification is the result of the
      collaborative work of the members of the JSR 303 Expert Group. These
      include the following present and former expert group members in
      alphabetical order:</p><div class="itemizedlist"><ul type="disc"><li><p>Geert Bevin</p></li><li><p>Emmanuel Bernard (Red Hat, Inc.) - Specification Lead</p></li><li><p>Uri Boness</p></li><li><p>Erik Brakkee (Ericsson AB)</p></li><li><p>Ed Burns (Sun Microsystems, Inc.)</p></li><li><p>Jason Carreira</p></li><li><p>Robert Clevenger (Oracle - retired)</p></li><li><p>Linda DeMichiel (Sun Microsystems, Inc.)</p></li><li><p>Tim Fennel</p></li><li><p>Bharath Ganesh (Pramati Technologies)</p></li><li><p>Romain Guy (Google Inc.)</p></li><li><p>Robert Harrop</p></li><li><p>Jacob J. Hookom</p></li><li><p>Bob Lee (Google Inc.)</p></li><li><p>Craig R. McClanahan (Sun Microsystems, Inc.)</p></li><li><p>Niall K. Pemberton</p></li><li><p>Steve Peterson</p></li><li><p>Dhanji R. Prasanna (Google Inc., formerly individual)</p></li><li><p>Gerhard Petracek</p></li><li><p>Matt Raible</p></li><li><p>Michael Nascimento Santos</p></li><li><p>Sebastian Thomschke</p></li><li><p>Jon Wetherbee (Oracle)</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e112"></a>1.2.&nbsp;Specification goals</h2></div></div><div></div></div><p>Validating data is a common task that occurs throughout an
      application, from the presentation layer to the persistence layer. Often
      the same validation logic is implemented in each layer, proving to be
      time consuming and error-prone. To avoid duplication of these
      validations in each layer, developers often bundle validation logic
      directly into the domain model, cluttering domain classes with
      validation code that is, in fact, metadata about the class
      itself.</p><p>This JSR defines a metadata model and API for JavaBean validation.
      The default metadata source is annotations, with the ability to override
      and extend the meta-data through the use of XML validation
      descriptors.</p><p>The validation API developed by this JSR is not intended for use
      in any one tier or programming model. It is specifically not tied to
      either the web tier or the persistence tier, and is available for both
      server-side application programming, as well as rich client Swing
      application developers. This API is seen as a general extension to the
      JavaBeans object model, and as such is expected to be used as a core
      component in other specifications. Ease of use and flexibility have
      influenced the design of this specification.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e121"></a>1.3.&nbsp;How this document is organized</h2></div></div><div></div></div><p>This document describes each aspect of the bean validation
      specification in a separate chapter. One should remember that the
      specification is a consistent whole.</p><p><a href="#constraintsdefinitionimplementation" title="Chapter&nbsp;2.&nbsp;Constraint Definition">Chapter&nbsp;2, <i>Constraint Definition</i></a> describes
      how constraints are defined.</p><p><a href="#constraintdeclarationvalidationprocess" title="Chapter&nbsp;3.&nbsp;Constraint declaration and validation process">Chapter&nbsp;3, <i>Constraint declaration and validation process</i></a>
      describes how a JavaBean class is decorated with annotations to describe
      constraints.</p><p><a href="#validationapi" title="Chapter&nbsp;4.&nbsp;Validation APIs">Chapter&nbsp;4, <i>Validation APIs</i></a> describes how to programmatically
      validate a JavaBean.</p><p><a href="#constraintmetadata" title="Chapter&nbsp;5.&nbsp;Constraint metadata request APIs">Chapter&nbsp;5, <i>Constraint metadata request APIs</i></a> describes how the metadata
      query API works.</p><p>In <a href="#terminology" title="Appendix&nbsp;A.&nbsp;Terminology">Appendix&nbsp;A, <i>Terminology</i></a>, key concepts are summarized.
      Some reviewers have found that reading the terminology section first
      helps to better understand the specification.</p><p>JPA, JSF and EE integration are present at <a href="#appendix-jpa" title="Appendix&nbsp;D.&nbsp;Java Persistence 2.0 integration">Appendix&nbsp;D, <i>Java Persistence 2.0 integration</i></a>, <a href="#appendix-jsf" title="Appendix&nbsp;E.&nbsp;Java Server Faces 2.0 integration">Appendix&nbsp;E, <i>Java Server Faces 2.0 integration</i></a> and <a href="#appendix-ee" title="Appendix&nbsp;F.&nbsp;Proposal for Java EE integration">Appendix&nbsp;F, <i>Proposal for Java EE integration</i></a> for archive purposes, one should refer to the
      respective specifications for the up-to-date integration rules.</p><p>The changelog can be found at <a href="#changelog" title="Appendix&nbsp;G.&nbsp;Changelog">Appendix&nbsp;G, <i>Changelog</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e154"></a>1.4.&nbsp;How to comment</h2></div></div><div></div></div><p>The expert group is eager to receive feedback from readers. Feel
      free to contact us or use jsr-303-comments@jcp.org.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="constraintsdefinitionimplementation"></a>Chapter&nbsp;2.&nbsp;Constraint Definition</h2></div></div><div></div></div><p>Constraints are defined by the combination of a constraint
    annotation and a list of constraint validation implementations. The
    constraint annotation is applied on types, methods, fields or other
    constraint annotations in case of composition.</p><p>Unless stated otherwise the default package name for the Bean
    Validation APIs is <tt class="classname">javax.validation</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintsdefinitionimplementation-constraintdefinition"></a>2.1.&nbsp;Constraint annotation</h2></div></div><div></div></div><p>A constraint on a JavaBean is expressed through one or more
      annotations. An annotation is considered a constraint definition if its
      retention policy contains <tt class="literal">RUNTIME</tt> and if the
      annotation itself is annotated with
      <tt class="literal">javax.validation.Constraint</tt>.</p><pre class="programlisting">/**
 * Link between a constraint annotation and its constraint validation implementations.
 * &lt;p/&gt;
 * A given constraint annotation should be annotated by a &lt;code&gt;@Constraint&lt;/code&gt;
 * annotation which refers to its list of constraint validation implementations.
 *
 * @author Emmanuel Bernard
 * @author Gavin King
 * @author Hardy Ferentschik
 */
@Documented
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface Constraint {
    /**
     * &lt;code&gt;ConstraintValidator&lt;/code&gt; classes must reference distinct target types.
     * If two &lt;code&gt;ConstraintValidator&lt;/code&gt; refer to the same type,
     * an exception will occur.
     *
     * @return array of ConstraintValidator classes implementing the constraint
     */
    public Class&lt;? extends ConstraintValidator&lt;?, ?&gt;&gt;[] validatedBy();
}</pre><p>Constraint annotations can target any of the following
      <tt class="classname">ElementType</tt>s:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">FIELD</tt> for constrained attributes</p></li><li><p><tt class="literal">METHOD</tt> for constrained getters</p></li><li><p><tt class="literal">TYPE</tt> for constrained beans</p></li><li><p><tt class="literal">ANNOTATION_TYPE</tt> for constraints composing
          other constraints</p></li></ul></div><p>While other <tt class="classname">ElementType</tt>s are not forbidden,
      the provider does not have to recognize and process constraints placed
      on such types. Built-in types do support <tt class="literal">PARAMETER</tt>
      and <tt class="literal">CONSTRUCTOR</tt> to allow Bean Validation provider
      specific extensions. It is considered good practice to follow the same
      approach for custom annotations.</p><p>Since a given constraint definition applies to one or more
      specific Java types, the JavaDoc for the constraint annotation should
      clearly state which types are supported. Applying a constraint
      annotation to an incompatible type will raise an
      <tt class="classname">UnexpectedTypeException</tt>. Care should be taken on
      defining the list of <tt class="classname">ConstraintValidator</tt>s. The
      type resolution algorithm (see <a href="#typevalidatorresolution" title="3.5.3.&nbsp;ConstraintValidator resolution algorithm">Section&nbsp;3.5.3, &#8220;ConstraintValidator resolution algorithm&#8221;</a>) could lead to exceptions if the
      <tt class="classname">ConstraintValidator</tt> list leads to
      ambiguities.</p><p>If a constraint definition is not valid, a
      <tt class="classname">ConstraintDefinitionException</tt> is raised either at
      validation time or when the metadata is requested. Invalid constraint
      definitions causes are multiple but include missing or illegal
      <tt class="methodname">message</tt> or <tt class="methodname">groups</tt>
      elements (see <a href="#constraintsdefinitionimplementation-constraintdefinition-properties" title="2.1.1.&nbsp;Constraint definition properties">Section&nbsp;2.1.1, &#8220;Constraint definition properties&#8221;</a>).</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintsdefinitionimplementation-constraintdefinition-properties"></a>2.1.1.&nbsp;Constraint definition properties</h3></div></div><div></div></div><p>A constraint definition may have attributes that are specified
        at the time the constraint is applied to a JavaBean. The properties
        are mapped as annotation elements. The annotation element names
        <tt class="literal">message</tt>, <tt class="literal">groups</tt> and
        <tt class="literal">payload</tt> are considered reserved names; annotation
        elements starting with <tt class="literal">valid</tt> are not allowed; a
        constraint may use any other element name for its attributes.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="constraintsdefinitionimplementation-constraintdefinition-parameters-message"></a>2.1.1.1.&nbsp;message</h4></div></div><div></div></div><p>Every constraint annotation must define a
          <tt class="literal">message</tt> element of type
          <tt class="literal">String</tt>.</p><pre class="programlisting">String message() default "{com.acme.constraint.MyConstraint.message}";</pre><p>The <tt class="methodname">message</tt> element value is used to
          create the error message. See <a href="#validationapi-message" title="4.3.&nbsp;Message interpolation">Section&nbsp;4.3, &#8220;Message interpolation&#8221;</a> for a detailed explanation. It is
          recommended to default <tt class="literal">message</tt> values to resource
          bundle keys to enable internationalization. It is also recommended
          to use the following convention: the resource bundle key should be
          the fully qualified class name of the constraint annotation
          concatenated to <tt class="literal">.message</tt> as shown in the previous
          program listing.</p><p>Built-in Bean Validation constraints follow this
          convention.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="constraintsdefinitionimplementation-constraintdefinition-groups"></a>2.1.1.2.&nbsp;groups</h4></div></div><div></div></div><p>Every constraint annotation must define a
          <tt class="literal">groups</tt> element that specifies the processing
          groups with which the constraint declaration is associated.</p><pre class="programlisting">    Class&lt;?&gt;[] groups() default {};</pre><p>The default value must be an empty array.</p><p>If no group is specified when declaring the constraint on an
          element, the <tt class="literal">Default</tt> group is considered
          declared.</p><p>See <a href="#validationapi-validatorapi-groups" title="4.1.2.&nbsp;groups">Section&nbsp;4.1.2, &#8220;groups&#8221;</a> for
          more information.</p><p>Groups are typically used to control the order in which
          constraints are evaluated, or to perform validation of the partial
          state of a JavaBean.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="constraintsdefinitionimplementation-constraintdefinition-payload"></a>2.1.1.3.&nbsp;payload</h4></div></div><div></div></div><p>Constraint annotations must define a
          <tt class="literal">payload</tt> element that specifies the payload with
          which the the constraint declaration is associated.</p><pre class="programlisting">    Class&lt;? extends Payload&gt;[] payload() default {};</pre><p>The default value must be an empty array.</p><p>Each attachable payload extends
          <tt class="classname">Payload</tt>.</p><pre class="programlisting">/**
 * Payload type that can be attached to a given
 * constraint declaration.
 * Payloads are typically used to carry on metadata information
 * consumed by a validation client.
 *
 * Use of payloads is not considered portable.
 *
 * @author Emmanuel Bernard
 * @author Gerhard Petracek
 */
public interface Payload {
}</pre><p>Payloads are typically used by validation clients to associate
          some metadata information with a given constraint declaration.
          Payloads are typically non-portable. Describing payloads as
          interface extensions as opposed to a string-based approach allows an
          easier and more type-safe approach.</p><p>One use case for payload shown in <a href="#example-payload" title="Example&nbsp;2.1.&nbsp;Use of payload to associate severity to a&#xA;            constraint">Example&nbsp;2.1, &#8220;Use of payload to associate severity to a
            constraint&#8221;</a> is to associate a severity to a
          constraint. This severity can be exploited by a presentation
          framework to adjust how a constraint failure is displayed.</p><div class="example"><a name="example-payload"></a><p class="title"><b>Example&nbsp;2.1.&nbsp;Use of payload to associate severity to a
            constraint</b></p><pre class="programlisting">package com.acme.severity;

public class Severity {
    public static class Info implements Payload {};
    public static class Error implements Payload {};
}

public class Address {
    @NotNull(message="would be nice if we had one", payload=Severity.Info.class)
    public String getZipCode() {...}

    @NotNull(message="the city is mandatory", payload=Severity.Error.class) 
    String getCity() {...}
}</pre></div><p>The <tt class="literal">payload</tt> information can be retrieved
          from error reports via the
          <tt class="classname">ConstraintDescriptor</tt> either accessed through
          the <tt class="classname">ConstraintViolation</tt> objects (see <a href="#validationapi-constraintviolation" title="4.2.&nbsp;ConstraintViolation">Section&nbsp;4.2, &#8220;ConstraintViolation&#8221;</a>) or through the
          metadata API (see <a href="#constraintmetadata-constraintdescriptor" title="5.5.&nbsp;ConstraintDescriptor">Section&nbsp;5.5, &#8220;ConstraintDescriptor&#8221;</a>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e358"></a>2.1.1.4.&nbsp;Constraint specific parameter</h4></div></div><div></div></div><p>The constraint annotation definitions may define additional
          elements to parameterize the constraint. For example, a constraint
          that validates the length of a string can use an annotation element
          named <tt class="literal">length</tt> to specify the maximum length at the
          time the constraint is declared.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e366"></a>2.1.2.&nbsp;Examples</h3></div></div><div></div></div><div class="example"><a name="example-definition-notnull"></a><p class="title"><b>Example&nbsp;2.2.&nbsp;Simple constraint definition</b></p><pre class="programlisting">package com.acme.constraint;

/**
 * Mark a String as representing a well formed order number
 */
@Documented
@Constraint(validatedBy = OrderNumberValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface OrderNumber {
    String message() default "{com.acme.constraint.OrderNumber.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</pre></div><p><a href="#example-definition-notnull" title="Example&nbsp;2.2.&nbsp;Simple constraint definition">Example&nbsp;2.2, &#8220;Simple constraint definition&#8221;</a> marks a String as
        a well-formed order number. The constraint Validator is implemented by
        <tt class="classname">OrderNumberValidator</tt>.</p><div class="example"><a name="example-definition-length"></a><p class="title"><b>Example&nbsp;2.3.&nbsp;Constraint definition with default parameter</b></p><pre class="programlisting">package com.acme.constraint;

/**
 * A frequency in Hz as audible to human ear.
 * Adjustable to the age of the person.
 * Accept Numbers.
 */
@Documented
@Constraint(validatedBy = AudibleValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface Audible {
    Age age() default Age.YOUNG;
    String message() default "{com.acme.constraint.Audible.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    public enum Age {
        YOUNG,
        WONDERING
        OLD
    }
}</pre></div><p><a href="#example-definition-length" title="Example&nbsp;2.3.&nbsp;Constraint definition with default parameter">Example&nbsp;2.3, &#8220;Constraint definition with default parameter&#8221;</a> ensures that a
        given frequency is within the scope of human ears. The constraint
        definition includes an optional parameter that may be specified when
        the constraint is applied.</p><div class="example"><a name="example-definition-mandatory"></a><p class="title"><b>Example&nbsp;2.4.&nbsp;Constraint definition with mandatory parameter</b></p><pre class="programlisting">package com.acme.constraint;

/**
 * Defines the list of values accepted
 * Accepts int or Integer objects
 */
@Documented
@Constraint(validatedBy = DiscreteListOfIntegerValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface Acceptable {
    int[] value();
    String message() default "{com.acme.constraint.Acceptable.message}";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</pre></div><p><a href="#example-definition-mandatory" title="Example&nbsp;2.4.&nbsp;Constraint definition with mandatory parameter">Example&nbsp;2.4, &#8220;Constraint definition with mandatory parameter&#8221;</a> defines a list
        of acceptable values expressed as an array: the
        <tt class="methodname">value</tt> property must be specified when the
        constraint is applied.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintsdefinitionimplementation-multipleconstraints"></a>2.2.&nbsp;Applying multiple constraints of the same type</h2></div></div><div></div></div><p>It is often useful to declare the same constraint more than once
      to the same target, with different properties. A common example is the
      <tt class="literal">@Pattern</tt> constraint, which validates that its target
      matches a specified regular expression. Other constraints have this
      requirement as well. The same constraint type can belong to different
      groups and have specific error messages depending on the targeted
      group.</p><p>To support this requirement, the bean validation provider treats
      regular annotations (annotations not annotated by
      <tt class="classname">@Constraint</tt>) whose <tt class="literal">value</tt>
      element has a return type of an array of constraint annotations in a
      special way. Each element in the <tt class="literal">value</tt> array are
      processed by the Bean Validation implementation as regular constraint
      annotations. This means that each constraint specified in the
      <tt class="literal">value</tt> element is applied to the target. The
      annotation must have retention <tt class="literal">RUNTIME</tt> and can be
      applied on a type, field, property or another annotation. It is
      recommended to use the same set of targets as the initial
      constraint.</p><p>Note to constraint designers: each constraint annotation should be
      coupled with its corresponding multi-valued annotation. The
      specification recommends, though does not mandate, the definition of an
      inner annotation named <tt class="classname">List</tt>.</p><div class="example"><a name="d0e429"></a><p class="title"><b>Example&nbsp;2.5.&nbsp;Multi-valued constraint definition</b></p><pre class="programlisting">/**
 * Validate a zipcode for a given country 
 * The only supported type is String
 */
@Documented
@Constraint(validatedBy = ZipCodeValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface ZipCode {

    String countryCode();

    String message() default "{com.acme.constraint.ZipCode.message}";

    Class&lt;?&gt;[] groups() default {};

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * Defines several @ZipCode annotations on the same element
     * @see (@link ZipCode}
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        ZipCode[] value();
    }    
}</pre></div><div class="example"><a name="d0e434"></a><p class="title"><b>Example&nbsp;2.6.&nbsp;Multi-valued constraint declaration</b></p><pre class="programlisting">public class Address {
    @ZipCode.List( {
            @ZipCode(countryCode="fr", groups=Default.class
                     message = "zip code is not valid"),
            @ZipCode(countryCode="fr", groups=SuperUser.class
                     message = "zip code invalid. Requires overriding before saving.")
            } )
    private String zipcode;
}</pre></div><p>In this example, both constraints apply to the
      <tt class="methodname">zipcode</tt> field but with different groups and
      with different error messages.</p><p>Using two different multi-constraint annotations for the same
      underlying constraint type on the same target (i.e. class or property)
      is not considered portable and is discouraged.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintsdefinitionimplementation-constraintcomposition"></a>2.3.&nbsp;Constraint composition</h2></div></div><div></div></div><p>This specification allows you to compose constraints to create
      higher level constraints.</p><p>Constraint composition is useful in several ways:</p><div class="itemizedlist"><ul type="disc"><li><p>Avoid duplication and facilitate reuse of more primitive
          constraints.</p></li><li><p>Expose primitive constraints as part of a composed constraint
          in the metadata API and enhance tool awareness.</p></li></ul></div><p>Composition is done by annotating a constraint annotation with the
      composing constraint annotations.</p><div class="example"><a name="d0e462"></a><p class="title"><b>Example&nbsp;2.7.&nbsp;Composition is done by annotating the composed
        constraint</b></p><pre class="programlisting">@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ANNOTATION_TYPE, METHOD, FIELD, CONSTRUCTOR, PARAMETER})
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</pre></div><p>Annotating an element with <tt class="classname">@FrenchZipcode</tt>
      (the composed annotation) is equivalent to annotating it with
      <tt class="classname">@Pattern(regexp="[0-9]*")</tt>,
      <tt class="classname">@Size(min=5, max=5)</tt> (the composing annotations)
      and <tt class="classname">@FrenchZipcode</tt>. More formally, each
      constraint annotation hosted on a constraint annotation is applied to
      the target element and this is done recursively. Note that the main
      annotation and its constraint validation implementation is also applied.
      By default, each failing constraint generates an error report. Groups
      from the main constraint annotation are inherited by the composing
      annotations. Any <tt class="methodname">groups</tt> definition on a
      composing annotation is ignored. Likewise, payload from the main
      constraint annotation is inherited by the composing annotations. Any
      <tt class="methodname">payload</tt> definition on a composing annotation is
      ignored.</p><p>The property type upon which composed constraint is placed must be
      compatible with all constraints (composing and composed). A constraint
      designer should ensure that such a type exists and list in the JavaDoc
      all the compatible types.</p><p>It is possible to ensure that composing annotations do not raise
      individual error reports. In this scenario, if one or more composing
      annotations are invalid, the main constraint is automatically considered
      invalid and the corresponding error report is generated. To mark a
      constraint as raising a single constraint error report if either the
      composed or one of the composing constraints fail, use the
      <tt class="classname">@ReportAsSingleViolation</tt> annotation.</p><div class="example"><a name="d0e494"></a><p class="title"><b>Example&nbsp;2.8.&nbsp;If any of the composing constraints fail, the error report
        corresponding to @FrenchZipcode is raised and none other.</b></p><pre class="programlisting">@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@ReportAsSingleViolation
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</pre></div><p>The definition of <tt class="classname">@ReportAsSingleViolation</tt>
      is as follows.</p><pre class="programlisting">/**
 * A constraint annotation hosting this annotation
 * will return the composed annotation error report if any of the composing annotations
 * fail. The error reports of each individual composing constraint is ignored.
 *
 * @author Emmanuel Bernard
 */
@Target({ ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface ReportAsSingleViolation {
}</pre><p>More specifically, if a composed constraint is marked as
      <tt class="classname">@ReportAsSingleViolation</tt>, and if any of its
      composing constraint reports one or more violations, all reports from
      composing constraints are ignored and the error report corresponding to
      the composed constraint is generated.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If a composing constraint fails and if the composed constraint
        is marked as <tt class="classname">@ReportAsSingleViolation</tt>, the Bean
        Validation provider is free to not process the other composing
        constraints for this composed constraint.</p></div><p>Composing annotations can define the value of
      <tt class="literal">message</tt> and custom attributes (excluding
      <tt class="methodname">groups</tt> and <tt class="methodname">payload</tt>)
      but these are fixed in the composed constraint definition.</p><div class="example"><a name="d0e528"></a><p class="title"><b>Example&nbsp;2.9.&nbsp;Composing annotations can use attributes. They are fixed for a
        given main annotation. All @FrenchZipcode constraints have a @Size
        restricted to 5.</b></p><pre class="programlisting">@Pattern(regexp="[0-9]*")
@Size(min=5, max=5)
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</pre></div><p>It is possible to override attributes and messages defined on a
      composing annotation. An attribute from the main annotation is used to
      override one or more attributes of the composing annotations. Such an
      attribute is annotated with the
      <tt class="classname">@OverridesAttribute</tt> annotation or its multivalued
      equivalent <tt class="classname">@OverridesAttribute.List</tt>.</p><div class="example"><a name="example-composing-overridden"></a><p class="title"><b>Example&nbsp;2.10.&nbsp;Attributes from composing annotations can be overridden by
        attributes from the composed annotation.</b></p><pre class="programlisting">@Pattern(regexp="[0-9]*")
@Size
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @OverridesAttribute.List( {
        @OverridesAttribute(constraint=Size.class, name="min"),
        @OverridesAttribute(constraint=Size.class, name="max") } )
    int size() default 5;

    @OverridesAttribute(constraint=Size.class, name="message")
    String sizeMessage() default "{com.acme.constraint.FrenchZipcode.zipcode.size}";

    @OverridesAttribute(constraint=Pattern.class, name="message")
    String numberMessage() default "{com.acme.constraint.FrenchZipcode.number.size}";

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</pre></div><p>The value of the composed constraint attribute annotated with
      <tt class="classname">@OverridesAttribute</tt>
      (<tt class="methodname">@FrenchZipcode.sizeMessage</tt>) is applied to the
      composing constraint attribute named after
      <tt class="methodname">OverridesAttribute.name</tt> and hosted on the
      composing constraint of type
      <tt class="methodname">OverridesAttribute.constraint</tt>
      (<tt class="methodname">@Size.message</tt>). Similarly,
      <tt class="classname">@FrenchZipcode.numberMessage</tt> value is mapped to
      <tt class="classname">@Pattern.message</tt>.</p><p>If left undefined, the default value for
      <tt class="methodname">@OverridesAttribute.name</tt> is the name of the
      composed constraint attribute hosting the
      <tt class="classname">@OverridesAttribute</tt> annotation.</p><p>The types of the overridden and overriding attributes must be
      identical.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A composing constraint can itself be a composed constraint. In
        this case, attribute values are overridden recursively according to
        the described rules. Note however, that a forwarding rule (as defined
        by <tt class="classname">@OverridesAttribute</tt>) is only applied to the
        direct composing constraints.</p></div><p>Using <a href="#example-composing-overridden" title="Example&nbsp;2.10.&nbsp;Attributes from composing annotations can be overridden by&#xA;        attributes from the composed annotation.">Example&nbsp;2.10, &#8220;Attributes from composing annotations can be overridden by
        attributes from the composed annotation.&#8221;</a>,</p><pre class="programlisting">@FrenchZipcode(size=9, sizeMessage="Zipcode should be of size {max}")</pre><p>is equivalent to</p><pre class="programlisting">@FrenchZipcode</pre><p>if <tt class="classname">@FrenchZipcode</tt> is defined as</p><pre class="programlisting">@Pattern(regexp="[0-9]*")
@Size(min=9, max=9, message="Zipcode should be of size {max}")
@Constraint(validatedBy = FrenchZipcodeValidator.class)
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface FrenchZipcode {
    String message() default "Wrong zipcode";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        FrenchZipcode[] value();
    }
}</pre><p>If a constraint is used more than once as a composing constraint,
      the multi value constraints model as described in <a href="#constraintsdefinitionimplementation-multipleconstraints" title="2.2.&nbsp;Applying multiple constraints of the same type">Section&nbsp;2.2, &#8220;Applying multiple constraints of the same type&#8221;</a> is
      used. To select a specific composing constraint,
      <tt class="methodname">OverridesAttribute.constraintIndex</tt> is used. It
      represents the constraint index in the <tt class="methodname">value</tt>
      array. If <tt class="literal">index</tt> is undefined, the single constraint
      declaration is targeted.</p><div class="example"><a name="d0e615"></a><p class="title"><b>Example&nbsp;2.11.&nbsp;Use of constraintIndex in @OverridesAttribute</b></p><pre class="programlisting">@Pattern.List( {
    @Pattern(regexp="[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}"), //email
    @Pattern(regexp=".*?emmanuel.*?") //emmanuel
} )
@Constraint(validatedBy={})
@Documented
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface EmmanuelsEmail {
    String message() default "Not emmanuel's email";

    @OverridesAttribute(constraint=Pattern.class, name="message", constraintIndex=0)
    String emailMessage() default "Not an email";

    @OverridesAttribute(constraint=Pattern.class, name="message", constraintIndex=1)
    String emmanuelMessage() default "Not Emmanuel";

    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        EmmanuelsEmail[] value();
    }
}</pre></div><p><tt class="classname">@OverridesAttribute</tt> definition is as
      follows:</p><pre class="programlisting">/**
 * Mark an attribute as overriding the attribute of a composing constraint.
 * Both attributes must share the same type.
 *
 * @author Emmanuel Bernard
 */
@Retention(RUNTIME)
@Target({ METHOD })
public @interface OverridesAttribute {
    /**
     * @return Constraint type the attribute is overriding
     */
    Class&lt;? extends Annotation&gt; constraint();

    /**
     * Name of the Constraint attribute overridden.
     * Defaults to the name of the attribute hosting &lt;code&gt;@OverridesAttribute&lt;/code&gt;.
     *
     * @return name of constraint attribute overridden.
     */
    String name();

    /**
     * The index of the targeted constraint declaration when using
     * multiple constraints of the same type.
     * The index represents the index of the constraint in the value() array.
     *
     * By default, no index is defined and the single constraint declaration
     * is targeted
     *
     * @return constraint declaration index if multivalued annotation is used
     */
    int constraintIndex() default -1;

    /**
     * Defines several @OverridesAttribute annotations on the same element
     * @see javax.validation.OverridesAttribute
     */
    @Documented
    @Target({ METHOD })
    @Retention(RUNTIME)
    public @interface List {
        OverridesAttribute[] value();
    }
}</pre><p>The following elements uniquely identify an overridden constraint
      attribute:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">OverridesAttribute.constraint</tt></p></li><li><p><tt class="methodname">OverridesAttribute.name</tt></p></li><li><p><tt class="methodname">OverridesAttribute.constraintIndex</tt></p></li></ul></div><p>If the composition is invalid (infinitely recursive composition,
      wrong attribute overriding, a single attribute mapped to more than one
      source attribute etc), a
      <tt class="classname">ConstraintDefinitionException</tt> is raised either at
      validation time or when the metadata is requested.</p><p>Constraint designers are encouraged to make use of composition
      (recursively or not) based on the built-in constraints defined by the
      specification. The composing constraints are exposed through the Bean
      Validation metadata API (<a href="#constraintmetadata-constraintdescriptor" title="5.5.&nbsp;ConstraintDescriptor">Section&nbsp;5.5, &#8220;ConstraintDescriptor&#8221;</a>). This metadata is
      particularly useful for third-party metadata consumers like persistence
      frameworks generating database schemas (such as Java Persistence) or
      presentation frameworks.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintsdefinitionimplementation-validationimplementation"></a>2.4.&nbsp;Constraint validation implementation</h2></div></div><div></div></div><p>A constraint validation implementation performs the validation of
      a given constraint annotation for a given type. The implementation
      classes are specified by the <tt class="literal">validatedBy</tt> element of
      the <tt class="classname">@Constraint</tt> annotation that decorates the
      constraint definition. The constraint validation implementation
      implements the <tt class="classname">ConstraintValidator</tt>
      interface.</p><pre class="programlisting">/**
 * Defines the logic to validate a given constraint A
 * for a given object type T.
 * Implementations must comply to the following restriction:
 * &lt;ul&gt;
 * &lt;li&gt;T must resolve to a non parameterized type&lt;/li&gt;
 * &lt;li&gt;or generic parameters of T must be unbounded
 * wildcard types&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidator&lt;A extends Annotation, T&gt; {
    /**
     * Initialize the validator in preparation for isValid calls.
     * The constraint annotation for a given constraint declaration
     * is passed.
     * &lt;p/&gt;
     * This method is guaranteed to be called before any use of this instance for
     * validation.
     *
     * @param constraintAnnotation annotation instance for a given constraint declaration
     */
    void initialize(A constraintAnnotation);

    /**
     * Implement the validation logic.
     * The state of &lt;code&gt;value&lt;/code&gt; must not be altered.
     *
     * This method can be accessed concurrently, thread-safety must be ensured
     * by the implementation.
     *
     * @param value object to validate
     * @param context context in which the constraint is evaluated
     *
     * @return false if &lt;code&gt;value&lt;/code&gt; does not pass the constraint
     */
    boolean isValid(T value, ConstraintValidatorContext context);
}</pre><p>Some restrictions apply on the generic type
      <tt class="classname">T</tt> (used in the <tt class="methodname">isValid</tt>
      method). <tt class="classname">T</tt> must</p><div class="itemizedlist"><ul type="disc"><li><p>resolve to a non parameterized type (i.e. because the type is
          not using generics or because the raw type is used instead of the
          generic version)</p></li><li><p>or generic parameters of <tt class="classname">T</tt> must be
          unbounded wildcard types (i.e. <tt class="literal">&lt;?&gt;</tt>)</p></li></ul></div><p><a href="#example-constraintsdefinitionimplementation-validationimplementation-validdef" title="Example&nbsp;2.12.&nbsp;Valid ConstraintValidator definitions">Example&nbsp;2.12, &#8220;Valid ConstraintValidator definitions&#8221;</a>
      shows some examples of valid definitions.</p><div class="example"><a name="example-constraintsdefinitionimplementation-validationimplementation-validdef"></a><p class="title"><b>Example&nbsp;2.12.&nbsp;Valid ConstraintValidator definitions</b></p><pre class="programlisting">//String is not making use of generics
public class SizeValidatorForString implements&lt;Size, String&gt; {...}

//Collection uses generics but the raw type is used
public class SizeValidatorForCollection implements&lt;Size, Collection&gt; {...}

//Collection uses generics and unbounded windcard type
public class SizeValidatorForCollection implements&lt;Size, Collection&lt;?&gt;&gt; {...}</pre></div><p>And some invalid definitions in <a href="#example-constraintsdefinitionimplementation-validationimplementation-invaliddef" title="Example&nbsp;2.13.&nbsp;Invalid ConstraintValidator definitions">Example&nbsp;2.13, &#8220;Invalid ConstraintValidator definitions&#8221;</a>.</p><div class="example"><a name="example-constraintsdefinitionimplementation-validationimplementation-invaliddef"></a><p class="title"><b>Example&nbsp;2.13.&nbsp;Invalid ConstraintValidator definitions</b></p><pre class="programlisting">//parameterized type
public class SizeValidatorForString implements&lt;Size, Collection&lt;String&gt;&gt; {...}

//parameterized type using bounded wildcard
public class SizeValidatorForCollection implements&lt;Size, Collection&lt;? extends Address&gt;&gt; {...}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This restriction is not a theoretical limitation and a future
        version of the specification will likely allow it.</p></div><p>The life cycle of a constraint validation implementation instance
      is undefined. Compliant implementations are allowed to cache
      <tt class="classname">ConstraintValidator</tt> instances retrieved from the
      <tt class="classname">ConstraintValidatorFactory</tt>.</p><p>The <tt class="methodname">initialize</tt> method is called by the
      Bean validation provider prior to any use of the constraint
      implementation.</p><p>The <tt class="methodname">isValid</tt> method is evaluated by the
      Bean Validation provider each time a given value is validated. It
      returns <tt class="literal">false</tt> if the value is not valid,
      <tt class="literal">true</tt> otherwise. <tt class="literal">isValid</tt>
      implementations must be thread-safe.</p><p>If the property is of an unanticipated type, an
      <tt class="literal">UnexpectedTypeException</tt> is raised.
      <tt class="classname">ConstraintValidator</tt> implementations raise this
      exception themselves if they receive an unsupported type. However,
      constraint designers are encouraged to make use of specialized
      <tt class="classname">ConstraintValidator</tt> implementations and delegate
      the type resolution to the Bean Validation provider (see the type
      matching algorithm described in <a href="#typevalidatorresolution" title="3.5.3.&nbsp;ConstraintValidator resolution algorithm">Section&nbsp;3.5.3, &#8220;ConstraintValidator resolution algorithm&#8221;</a>).</p><p>If an exception occurs either in the
      <tt class="classname">initialize</tt> or <tt class="classname">isValid</tt>
      method, the runtime exception is wrapped into a
      <tt class="classname">ValidationException</tt> by the Bean Validation
      engine.</p><p>The constraint validation implementation is not allowed to change
      the state of the value passed to
      <tt class="methodname">isValid</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>While not mandatory, it is considered a good practice to split
        the core constraint validation from the not null constraint validation
        (for example, an <tt class="classname">@Email</tt> constraint will return
        true on a null object, i.e. will not take care of the
        <tt class="classname">@NotNull</tt> validation)</p><p><tt class="code">null</tt> can have multiple meanings but is commonly
        used to express that a value does not make sense, is not available or
        is simply unknown. Those constraints on the value are orthogonal in
        most cases to other constraints. For example a String, if present,
        must be an email but can be null. Separating both concerns is a good
        practice.</p></div><p>The <tt class="classname">ConstraintValidatorContext</tt> object
      passed to the <tt class="methodname">isValid</tt> method carries
      information and operations available in the context the constraint is
      validated to.</p><pre class="programlisting">/**
 * Provide contextual data and operation when applying a given constraint validator.
 *
 * At least one &lt;code&gt;ConstraintViolation&lt;/code&gt; must be defined (either the default one,
 * of if the default &lt;code&gt;ConstraintViolation&lt;/code&gt; is disabled, a custom one).
 *
 * @author Emmanuel Bernard
 */
public interface ConstraintValidatorContext {
    /**
     * Disable the default &lt;code&gt;ConstraintViolation&lt;/code&gt; object generation (which
     * is using the message template declared on the constraint).
     * Useful to set a different violation message or generate a &lt;code&gt;ConstraintViolation&lt;/Code&gt;
     * based on a different property.
     */
    void disableDefaultConstraintViolation();

    /**
     * @return the current uninterpolated default message.
     */
    String getDefaultConstraintMessageTemplate();

    /**
     * Return an constraint violation builder building an violation report
     * allowing to optionally associate it to a sub path.
     * The violation message will be interpolated.
     * &lt;p/&gt;
     * To create the &lt;code&gt;ConstraintViolation&lt;/code&gt;, one must call either one of
     * the #addConstraintViolation() methods available in one of the
     * interfaces of the fluent API.
     * If another method is called after #addConstraintViolation() on
     * &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; or any of its associated nested interfaces
     * an &lt;code&gt;IllegalStateException&lt;/code&gt; is raised.
     * &lt;p/&gt;
     * If &lt;code&gt;isValid&lt;code&gt; returns &lt;code&gt;false&lt;/code&gt;, a &lt;code&gt;ConstraintViolation&lt;/code&gt;
     * object will be built per ConstraintViolation report including the default one (unless
     * {@link #disableDefaultConstraintViolation()} has been called).
     * &lt;p/&gt;
     * &lt;code&gt;ConstraintViolation&lt;/code&gt; objects generated from such a call
     * contain the same contextual information (root bean, path and so on) unless
     * the path has been overriden.
     * &lt;p/&gt;
     * To create a different &lt;code&gt;ConstraintViolation&lt;/code&gt;, a new constraint violation builder
     * has to be retrieved from &lt;code&gt;ConstraintValidatorContext&lt;/code&gt;
     *
     * Here are a few usage examples:
     * &lt;pre&gt;
     * {@code
     * // create new violation report with the default path the constraint is located on
     * context.buildConstraintViolationWithTemplate( "way too long" )
     *             .addConstraintViolation();
     *
     * // create new violation report in the "street" subnode of the default path
     * //the constraint is located on
     * context.buildConstraintViolationWithTemplate( "way too long" )
     *              .addNode( "street" )
     *              .addConstraintViolation();
     *
     * //create new violation report in the "addresses["home"].city.name" subnode
     * //of the default path the constraint is located on
     * context.buildConstraintViolationWithTemplate( "this detail is wrong" )
     *              .addNode( "addresses" )
     *              .addNode( "country" )
     *                  .inIterable().atKey( "home" )
     *              .addNode( "name" )
     *              .addConstraintViolation();
     * }
     * &lt;/pre&gt;
     *
     * @param messageTemplate new uninterpolated constraint message.
     * @return Returns an constraint violation builder
     */
    ConstraintViolationBuilder buildConstraintViolationWithTemplate(String messageTemplate);

    /**
     * &lt;code&gt;ConstraintViolation&lt;/code&gt; builder allowing to optionally associate
     * the violation report to a sub path.
     *
     * To create the &lt;code&gt;ConstraintViolation&lt;/code&gt;, one must call either one of
     * the #addConstraintViolation() methods available in one of the
     * interfaces of the fluent API.
     * If another method is called after #addConstraintViolation() on
     * &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; or any of its associated objects
     * an &lt;code&gt;IllegalStateException&lt;/code&gt; is raised.
     * 
     */
    interface ConstraintViolationBuilder {
        /**
         * Add a node to the path the &lt;code&gt;ConstraintViolation&lt;/code&gt; will be associated to.
         *
         * &lt;code&gt;name&lt;/code&gt; describes a single property. In particular,
         * dot (.) is not allowed.
         *
         * @param name property name
         * @return a builder representing node &lt;code&gt;name&lt;/code&gt;
         */
        NodeBuilderDefinedContext addNode(String name);

        /**
         * Add the new &lt;code&gt;ConstraintViolation&lt;/code&gt; to be generated if the
         * constraint validator marks the value as invalid.
         * Methods of this &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; instance and its nested
         * objects return &lt;code&gt;IllegalStateException&lt;/code&gt; from now on.
         *
         * @return the &lt;code&gt;ConstraintValidatorContext&lt;/code&gt; instance the
         *           &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; comes from
         */
        ConstraintValidatorContext addConstraintViolation();

        /**
         * Represent a node whose context is known
         * (ie index, key and isInIterable)
         */
        interface NodeBuilderDefinedContext {

            /**
             * Add a node to the path the &lt;code&gt;ConstraintViolation&lt;/code&gt; will be associated to.
             *
             * &lt;code&gt;name&lt;/code&gt; describes a single property. In particular,
             * dot (.) are not allowed.
             *
             * @param name property &lt;code&gt;name&lt;/code&gt;
             * @return a builder representing this node
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Add the new &lt;code&gt;ConstraintViolation&lt;/code&gt; to be generated if the
             * constraint validator marks the value as invalid.
             * Methods of the &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; instance this object
             * comes from and the constraint violation builder nested
             * objects return &lt;code&gt;IllegalStateException&lt;/code&gt; after this call.
             *
             * @return &lt;code&gt;ConstraintValidatorContext&lt;/code&gt; instance the
             *           &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represent a node whose context is
         * configurable (ie index, key and isInIterable)
         */
        interface NodeBuilderCustomizableContext {

            /**
             * Mark the node as being in an &lt;code&gt;Iterable&lt;/code&gt; or a &lt;code&gt;Map&lt;/code&gt;
             * 
             * @return a builder representing iterable details
             */
            NodeContextBuilder inIterable();

            /**
             * Add a node to the path the &lt;code&gt;ConstraintViolation&lt;/code&gt; will be associated to.
             *
             * &lt;code&gt;name&lt;/code&gt; describes a single property. In particular,
             * dot (.) are not allowed.
             *
             * @param name property &lt;code&gt;name&lt;/code&gt;
             * @return a builder representing this node
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Add the new &lt;code&gt;ConstraintViolation&lt;/code&gt; to be generated if the
             * constraint validator mark the value as invalid.
             * Methods of the &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; instance this object
             * comes from and the constraint violation builder nested
             * objects return &lt;code&gt;IllegalStateException&lt;/code&gt; after this call.
             *
             * @return &lt;code&gt;ConstraintValidatorContext&lt;/code&gt; instance the
             *           &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }

        /**
         * Represent refinement choices for a node which is
         * in an &lt;code&gt;Iterator&lt;code&gt; or &lt;code&gt;Map&lt;/code&gt;.
         * If the iterator is an indexed collection or a map,
         * the index or the key should be set.
         */
        interface NodeContextBuilder {
            
            /**
             * Define the key the object is into the &lt;code&gt;Map&lt;/code&gt;
             *
             * @param key map key
             * @return a builder representing the current node
             */
            NodeBuilderDefinedContext atKey(Object key);

            /**
             * Define the index the object is into the &lt;code&gt;List&lt;/code&gt; or array
             *
             * @param index index
             * @return a builder representing the current node
             */
            NodeBuilderDefinedContext atIndex(Integer index);

            /**
             * Add a node to the path the &lt;code&gt;ConstraintViolation&lt;/code&gt; will be associated to.
             *
             * &lt;code&gt;name&lt;/code&gt; describes a single property. In particular,
             * dot (.) are not allowed.
             *
             * @param name property &lt;code&gt;name&lt;/code&gt;
             * @return a builder representing this node
             */
            NodeBuilderCustomizableContext addNode(String name);

            /**
             * Add the new &lt;code&gt;ConstraintViolation&lt;/code&gt; to be generated if the
             * constraint validator mark the value as invalid.
             * Methods of the &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; instance this object
             * comes from and the constraint violation builder nested
             * objects return &lt;code&gt;IllegalStateException&lt;/code&gt; after this call.
             *
             * @return &lt;code&gt;ConstraintValidatorContext&lt;/code&gt; instance the
             *           &lt;code&gt;ConstraintViolationBuilder&lt;/code&gt; comes from
             */
            ConstraintValidatorContext addConstraintViolation();
        }
    }
}</pre><p>The <tt class="classname">ConstraintValidatorContext</tt> interface
      allows redefinition of the default constraint message generated when a
      constraint is not valid. By default, each invalid constraint leads to
      the generation of one error object represented by a
      <tt class="classname">ConstraintViolation</tt> object. This object is built
      from the default constraint message template as defined by the
      constraint declaration and the context in which the constraint
      declaration is placed (bean, property, attribute).</p><p>The <tt class="classname">ConstraintValidatorContext</tt> methods let
      the constraint implementation disable the default
      <tt class="classname">ConstraintViolation</tt> generation and create one or
      more custom ones. The non-interpolated message passed as a parameter is
      used to build the <tt class="classname">ConstraintViolation</tt> message
      (the message interpolation operation is applied to it).</p><p>By default, the <tt class="classname">Path</tt> exposed on the
      <tt class="classname">ConstraintViolation</tt> represents the path to the
      bean or property hosting the constraint (see <a href="#validationapi-constraintviolation" title="4.2.&nbsp;ConstraintViolation">Section&nbsp;4.2, &#8220;ConstraintViolation&#8221;</a> for more information).
      You can point it to a subpath of this default path by using the
      constraint violation builder fluent API.</p><p><a href="#example-constraintsdefinitionimplementation-validationimplementation-errorbuilder" title="Example&nbsp;2.14.&nbsp;Using the fluent API to build custom constraint&#xA;        violations">Example&nbsp;2.14, &#8220;Using the fluent API to build custom constraint
        violations&#8221;</a>
      shows a few examples.</p><div class="example"><a name="example-constraintsdefinitionimplementation-validationimplementation-errorbuilder"></a><p class="title"><b>Example&nbsp;2.14.&nbsp;Using the fluent API to build custom constraint
        violations</b></p><pre class="programlisting">//default path
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addConstraintViolation();

//default path + "street"
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addNode( "street" )
            .addConstraintViolation();

//default path + "addresses["home"].country.name"
context.buildConstraintViolationWithTemplate( "this detail is wrong" )
            .addNode( "addresses" )
            .addNode( "country" )
                .inIterable().atKey( "home" )
            .addNode( "name" )
            .addConstraintViolation();</pre></div><p>If <tt class="methodname">disableDefaultConstraintViolation</tt> is
      called, no custom error is added (using the error builder) and if the
      constraint is not valid, a <tt class="classname">ValidationException</tt> is
      raised.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintsdefinitionimplementation-validationimplementation-example"></a>2.4.1.&nbsp;Example</h3></div></div><div></div></div><div class="example"><a name="d0e838"></a><p class="title"><b>Example&nbsp;2.15.&nbsp;ConstraintValidator implementation</b></p><pre class="programlisting">/**
 * Check that a text is within the authorized syntax
 */
public class SyntaxValidator implements ConstraintValidator&lt;Syntax, String&gt; {
    private Set&lt;Format&gt; allowedFormats;

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Syntax constraint) {
        allowedFormats = new HashSet( Arrays.asList( constraint.value() ) );
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null ) return true;

        return allowedFormats.size() == 0 
            || (! Collections.disjoint( guessFormat(value), allowedFormats ) );
    }

    Set&lt;Format&gt; guessFormats(String text) { ... }
}</pre></div><p>This <tt class="classname">ConstraintValidator</tt> checks that a
        text is within the accepted syntax. It also demonstrates an
        interesting best practice: return <tt class="literal">true</tt> on a null
        parameter</p><p>The next example shows how to use
        <tt class="classname">ConstraintValidatorContext</tt>.</p><div class="example"><a name="d0e856"></a><p class="title"><b>Example&nbsp;2.16.&nbsp;Use of ConstraintValidatorContext</b></p><pre class="programlisting">/**
 * Check that a text is within the authorized syntax
 * Error messages are using either key:
 *  - com.acme.constraint.Syntax.unknown if no particular syntax is detected
 *  - com.acme.constraint.Syntax.unauthorized if the syntax is not allowed
 */
public class FineGrainedSyntaxValidator implements ConstraintValidator&lt;Syntax, String&gt; {
    private Set&lt;Format&gt; allowedFormats;

    /**
     * Configure the constraint validator based on the elements
     * specified at the time it was defined.
     * @param constraint the constraint definition
     */
    public void initialize(Syntax constraint) {
        allowedFormats = new HashSet( Arrays.asList( constraint.value() ) );
    }

    /**
     * Validate a specified value.
     * returns false if the specified value does not conform to the definition
     */
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if ( value == null ) return true;
        Set&lt;Format&gt; guessedFormats = guessFormat(value);

        context.disableDefaultConstraintViolation();
        if ( guessedFormats.size() == 0 ) {
            String unknown = "{com.acme.constraint.Syntax.unknown}";
            context.buildConstraintViolationWithTemplate(unknown)
                       .addConstraintViolation();
        }
        else {
            String unauthorized = "{com.acme.constraint.Syntax.unauthorized}";
            context.buildConstraintViolationWithTemplate(unauthorized)
                       .addConstraintViolation();
        }

        return allowedFormats.size() == 0 
            || (! Collections.disjoint( guessFormat(value), allowedFormats ) ));
    }

    Set&lt;Format&gt; guessFormats(String text) { ... }
}</pre></div><p>The default error message is disabled and replaced by a specific
        error message depending on the type of constraint violation detected.
        In this case, only one error report is returned at a given time but a
        constraint validation implementation can return several error
        reports.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintsdefinitionimplementation-constraintfactory"></a>2.5.&nbsp;The ConstraintValidatorFactory</h2></div></div><div></div></div><p>Constraint validation implementation instances are created by a
      <tt class="classname">ConstraintValidatorFactory</tt>.</p><pre class="programlisting">/**
 * Instantiate a &lt;code&gt;ConstraintValidator&lt;/code&gt; instance based off its class.
 * The &lt;code&gt;ConstraintValidatorFactory&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; responsible
 * for calling {@link ConstraintValidator#initialize(java.lang.annotation.Annotation)}.
 *
 * @author Dhanji R. Prasanna
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintValidatorFactory {

    /**
     * @param key The class of the constraint validator to instantiate.
     *
     * @return A constraint validator instance of the specified class.
     */
    &lt;T extends ConstraintValidator&lt;?,?&gt;&gt; T getInstance(Class&lt;T&gt; key);
}</pre><p>The default <tt class="classname">ConstraintValidatorFactory</tt>
      provided by the Bean Validation provider implementation uses the public
      no-arg constructor of the <tt class="classname">ConstraintValidator</tt>
      class. A custom <tt class="classname">ConstraintValidatorFactory</tt> can be
      provided; for example it may benefit from dependency injection control
      in constraint implementations. Any constraint implementation relying on
      <tt class="classname">ConstraintValidatorFactory</tt> behaviors specific to
      an implementation (dependency injection, no no-arg constructor and so
      on) are not considered portable, hence great care should be given before
      walking that path.</p><p><tt class="classname">ConstraintValidatorFactory</tt> should not cache
      instances as the state of each instance can be altered in the
      <tt class="methodname">initialize</tt> method.</p><p>If an exception occurs in the factory while retrieving the
      <tt class="classname">ConstraintValidator</tt> instance, the runtime
      exception is wrapped in a <tt class="classname">ValidationException</tt>. If
      the instance returned by the factory is null, a
      <tt class="classname">ValidationException</tt> is raised.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="constraintdeclarationvalidationprocess"></a>Chapter&nbsp;3.&nbsp;Constraint declaration and validation process</h2></div></div><div></div></div><p>The Bean Validation specification defines a framework for declaring
    constraints on JavaBean classes, fields and properties.</p><p>Constraints are declared on types and evaluated against instances or
    graphs of instances.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintdeclarationvalidationprocess-requirements"></a>3.1.&nbsp;Requirements on classes to be validated</h2></div></div><div></div></div><p>Objects that are to be validated must fulfill the following
      requirements:</p><div class="itemizedlist"><ul type="disc"><li><p>Properties to be validated must follow the method signature
          conventions for JavaBeans read properties, as defined by the
          JavaBeans specification.</p></li><li><p>Static fields and static methods are excluded from
          validation.</p></li><li><p>Constraints can be applied to interfaces and
          superclasses.</p></li></ul></div><p>The target of an annotation definition can be a field, property,
      or type, provided that:</p><div class="itemizedlist"><ul type="disc"><li><p>the constraint definition supports the specified target
          (<tt class="classname">java.lang.annotation.Target</tt>)</p></li><li><p>the one of the <tt class="classname">ConstraintValidator</tt>s
          declared on the constraint supports the declared type of the target
          (see <a href="#typevalidatorresolution" title="3.5.3.&nbsp;ConstraintValidator resolution algorithm">Section&nbsp;3.5.3, &#8220;ConstraintValidator resolution algorithm&#8221;</a>).</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-requirements-object"></a>3.1.1.&nbsp;Object validation</h3></div></div><div></div></div><p>Constraint declarations can be applied to a class or an
        interface. Applying a constraint to a class or interface expresses a
        validation over the state of the class or the class implementing the
        interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-requirements-property"></a>3.1.2.&nbsp;Field and property validation</h3></div></div><div></div></div><p>Constraint declarations can be applied on both fields and
        properties for the same object type. The same constraint should
        however not be duplicated between a field and its associated property
        (the constraint validation would be applied twice). It is recommended
        for objects holding constraint declarations to adhere to a single
        state access strategy (either annotated fields or properties).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Java Persistence and Bean Validation</h3><p>For maximum portability, persistent properties hosting Bean
          Validation constraints should use the same access strategy used in
          Java Persistence. In other words, place your Bean Validation
          constraint annotations on the same element (field or getter) as your
          Java Persistence annotations.</p></div><p>When a field is annotated with a constraint declaration, field
        access strategy is used to access the state validated by such
        constraint.</p><p>When a property is annotated with a constraint declaration,
        property access strategy is used to access the state validated by such
        constraint.</p><p>When using field access strategy, the bean validation provider
        accesses the instance variable directly. When using the property
        access strategy, the bean validation provider accesses the state via
        the property accessor method. It is required that the class follows
        the method signature conventions for JavaBeans read properties (as
        defined by the JavaBeans <tt class="classname">Introspector</tt> class)
        for constrained properties when constrained properties are used. In
        this case, for every constraint property of type
        <tt class="classname">T</tt>, there is a getter method,
        <tt class="methodname">get&lt;Property-name&gt;</tt>. For
        <tt class="code">boolean</tt> properties,
        <tt class="methodname">is&lt;Property-name&gt;</tt> is an alternative
        name for the getter method. Specifically, if
        <tt class="methodname">getX</tt> is the name of the getter method, where
        <tt class="classname">X</tt> is a string, the name of the persistent
        property is defined by the result of
        <tt class="code">java.beans.Introspector.decapitalize(X)</tt>.</p><p>The fields or methods visibility are not constrained.
        Constraints on non getter methods are not supported.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e991"></a>3.1.3.&nbsp;Graph validation</h3></div></div><div></div></div><p>In addition to supporting instance validation, validation of
        graphs of object is also supported. The result of a graph validation
        is returned as a unified set of constraint violations.</p><p>Consider the situation where bean <tt class="classname">X</tt>
        contains a field of type <tt class="classname">Y</tt>. By annotating field
        <tt class="classname">Y</tt> with the <tt class="classname">@Valid</tt>
        annotation, the Validator will validate <tt class="classname">Y</tt> (and
        its properties) when <tt class="classname">X</tt> is validated. The exact
        type <tt class="classname">Z</tt> of the value contained in the field
        declared of type <tt class="classname">Y</tt> (subclass, implementation)
        is determined at runtime. The constraint definitions of
        <tt class="classname">Z</tt> are used. This ensures proper polymorphic
        behavior for associations marked <tt class="classname">@Valid</tt>.</p><p>Collection-valued, array-valued and generally
        <tt class="classname">Iterable</tt> fields and properties may also be
        decorated with the <tt class="classname">@Valid</tt> annotation. This
        causes the contents of the iterator to be validated. Any object
        implementing <tt class="classname">java.lang.Iterable</tt> is supported.
        This includes specifically:</p><div class="itemizedlist"><ul type="disc"><li><p>arrays of objects</p></li><li><p><tt class="classname">java.util.Collection</tt></p></li><li><p><tt class="classname">java.util.Set</tt></p></li><li><p><tt class="classname">java.util.List</tt></p></li><li><p><tt class="classname">java.util.Map</tt> (special treatment see
            below)</p></li></ul></div><p>Each object provided by the iterator is validated. For
        <tt class="classname">Map</tt>, the value of each
        <tt class="classname">Map.Entry</tt> is validated (the key is not
        validated).</p><p>Like regular references, its type is determined at runtime and
        the constraint definitions for this particular type are used.</p><p>The <tt class="classname">@Valid</tt> annotation is applied
        recursively. A conforming implementation avoids infinite loops
        according to the rules described in <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="3.5.1.&nbsp;Object graph validation">Section&nbsp;3.5.1, &#8220;Object graph validation&#8221;</a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1077"></a>3.2.&nbsp;Constraint declaration</h2></div></div><div></div></div><p>Constraint declarations are placed on classes or interfaces
      primarily through annotations. A constraint annotation (see <a href="#constraintsdefinitionimplementation-constraintdefinition" title="2.1.&nbsp;Constraint annotation">Section&nbsp;2.1, &#8220;Constraint annotation&#8221;</a>),
      can be applied to a type, on any of the type's fields or on any of the
      JavaBeans-compliant properties.</p><p>When a constraint is defined on a class, the class instance being
      validated is passed to the <tt class="classname">ConstraintValidator</tt>.
      When a constraint is defined on a field, the value of the field is
      passed to the <tt class="classname">ConstraintValidator</tt>. When a
      constraint is defined on a getter, the result of the getter invocation
      is passed to the <tt class="classname">ConstraintValidator</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintdeclarationvalidationprocess-inheritance"></a>3.3.&nbsp;Inheritance (interface and superclass)</h2></div></div><div></div></div><p>A constraint declaration can be placed on an interface. For a
      given class, constraint declarations held on superclasses as well as
      interfaces are evaluated by the Bean Validation provider. Rules are
      formally described in <a href="#constraintdeclarationvalidationprocess-groupsequence-formaldefinition" title="3.4.5.&nbsp;Formal group definitions">Section&nbsp;3.4.5, &#8220;Formal group definitions&#8221;</a>.</p><p>The effect of constraint declarations is cumulative. Constraints
      declared on a superclass getter will be validated along with any
      constraints defined on an overridden version of the getter according to
      the Java Language Specification visibility rules.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintdeclarationvalidationprocess-groupsequence"></a>3.4.&nbsp;Group and group sequence</h2></div></div><div></div></div><p>A group defines a subset of constraints. Instead of validating all
      constraints for a given object graph, only a subset is validated. This
      subset is defined by the the group or groups targeted. Each constraint
      declaration defines the list of groups it belongs to. If no group is
      explicitly declared, a constraint belongs to the
      <tt class="classname">Default</tt> group.</p><p>Groups are represented by interfaces.</p><div class="example"><a name="d0e1114"></a><p class="title"><b>Example&nbsp;3.1.&nbsp;Definition of groups</b></p><pre class="programlisting">/**
 * Validation group verifing that a user is billable
 */
public interface Billable {}

/**
 * customer can buy without any harrassing checking process
 */
public interface BuyInOneClick {
}</pre></div><p>A constraint can belong to one or more groups.</p><div class="example"><a name="example-assigngrouptoconstraints"></a><p class="title"><b>Example&nbsp;3.2.&nbsp;Assign groups to constraints</b></p><pre class="programlisting">/**
 * User representation
 */
public class User {
    @NotNull
    private String firstname;

    @NotNull(groups = Default.class)
    private String lastname;

    @NotNull(groups = {Billable.class, BuyInOneClick.class})
    private CreditCard defaultCreditCard;
}</pre></div><p>During the validation call, one or more groups are validated. All
      the constraints belonging to this set of group is evaluated on the
      object graph. In <a href="#example-assigngrouptoconstraints" title="Example&nbsp;3.2.&nbsp;Assign groups to constraints">Example&nbsp;3.2, &#8220;Assign groups to constraints&#8221;</a>,
      <tt class="classname">@NotNull</tt> is checked on
      <tt class="literal">defaultCreditCard</tt> when either the
      <tt class="classname">Billable</tt> or <tt class="classname">BuyInOneClick</tt>
      group is validated. <tt class="classname">@NotNull</tt> on
      <tt class="literal">firstname</tt> and <tt class="literal">lastname</tt> are
      validated when the <tt class="classname">Default</tt> group is validated.
      Reminder: constraints held on superclasses and interfaces are
      considered.</p><p><tt class="classname">Default</tt> is a group predefined by the
      specification</p><pre class="programlisting">package javax.validation.groups;

/**
 * Default Bean Validation group.
 * Unless a list of group is explicitly defined:
 * &lt;ul&gt;
 *  &lt;li&gt;constraints belong to the Default group&lt;/li&gt;
 *  &lt;li&gt;validation apply on the Default group&lt;/li&gt;
 * &lt;/ul&gt;
 * Most structural constraints should belong to the default group.
 *
 * @author Emmanuel Bernard
 */
public interface Default {
}</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-groupsequence-groupinheritance"></a>3.4.1.&nbsp;Group inheritance</h3></div></div><div></div></div><p>In some situations, a group is a superset of one or more groups.
        This can be described by Bean Validation. A group may inherit one or
        more groups by using interface inheritance.</p><div class="example"><a name="d0e1165"></a><p class="title"><b>Example&nbsp;3.3.&nbsp;Groups can inherit other groups</b></p><pre class="programlisting">/**
 * Customer can buy without harrassing checking process
 */
public interface BuyInOneClick extends Default, Billable {}</pre></div><p>For a given interface <tt class="classname">Z</tt>, constraints
        marked as belonging to the group <tt class="classname">Z</tt> (i.e. where
        the annotation element <tt class="methodname">groups</tt> contains the
        interface <tt class="classname">Z</tt>) or any of the super interfaces of
        <tt class="classname">Z</tt> (inherited groups) are considered part of the
        group <tt class="classname">Z</tt>.</p><p>In the following example:</p><div class="example"><a name="d0e1192"></a><p class="title"><b>Example&nbsp;3.4.&nbsp;Use of a inherited group</b></p><pre class="programlisting">/**
 * User representation
 */
public class User {
    @NotNull
    private String firstname;

    @NotNull(groups = Default.class)
    private String lastname;

    @NotNull(groups = Billable.class)
    private CreditCard defaultCreditCard;
}</pre></div><p>validating the group <tt class="classname">BuyInOneClick</tt> will
        lead to the following constraints checking:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">@NotNull</tt> on
            <tt class="literal">firstname</tt> and
            <tt class="literal">lastname</tt></p></li><li><p><tt class="classname">@NotNull</tt> on
            <tt class="literal">defaultCreditCard</tt></p></li></ul></div><p>because <tt class="classname">Default</tt> and
        <tt class="classname">Billable</tt> are superinterfaces of
        <tt class="classname">BuyInOneClick</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-groupsequence-groupsequence"></a>3.4.2.&nbsp;Group sequence</h3></div></div><div></div></div><p>By default, constraints are evaluated in no particular order
        regardless of which groups they belong to. It is however useful in
        some situations to control the order of constraints evaluation. There
        are often scenarios where a preliminary set of constraints should be
        evaluated prior to other constraints. Here are two examples:</p><div class="itemizedlist"><ul type="disc"><li><p>The second group depends on a stable state to run properly.
            This stable state is verified by the first group.</p></li><li><p>The second group is a heavy consumer of time, CPU or memory
            and its evaluation should be avoided if possible.</p></li></ul></div><p>To implement such ordering, a group can be defined as a sequence
        of other groups. Each group in a group sequence must be processed
        sequentially in the order defined by
        <tt class="methodname">@GroupSequence.value</tt> when the group defined
        as a sequence is requested. Note that a group member of a sequence can
        itself be composed of several groups via inheritance or sequence
        definition. In this case, each composed group must respect the
        sequence order as well.</p><p>Processing a group is defined in <a href="#constraintdeclarationvalidationprocess-validationroutine" title="3.5.&nbsp;Validation routine">Section&nbsp;3.5, &#8220;Validation routine&#8221;</a>
        ; if one of the groups processed in the sequence generates one or more
        constraint violations, the groups following in the sequence must not
        be processed. This ensures that a set of constraint is evaluated only
        if another set of constraint is valid.</p><p>Groups defining a sequence and groups composing a sequence must
        not be involved in a cyclic dependency: </p><div class="itemizedlist"><ul type="disc"><li><p>either directly or indirectly</p></li><li><p>either through cascaded sequence definitions or group
            inheritance</p></li></ul></div><p>If a group containing such a circularity is evaluated, a
        <tt class="classname">GroupDefinitionException</tt> is raised.</p><p>Groups defining a sequence should not directly inherit other
        groups. In other words, the interface hosting the group sequence
        should not have any super interface.</p><p>Groups defining a sequence should not be used directly in
        constraint declarations. In other words, the interface hosting the
        group sequence should not be used in a constraint declaration.</p><p>To define a group as a sequence, the interface must be annotated
        with the <tt class="classname">@GroupSequence</tt> annotation.</p><pre class="programlisting">/**
 * Define a group sequence
 * The interface hosting &lt;code&gt;@GroupSequence&lt;/code&gt; is representing 
 * the group sequence.
 * When hosted on a class, represents the &lt;code&gt;Default&lt;/code&gt; group
 * for that class.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
@Target({ TYPE })
@Retention(RUNTIME)
public @interface GroupSequence {
    Class&lt;?&gt;[] value();
}</pre><p>Here is a usage example</p><div class="example"><a name="example-groupsequence"></a><p class="title"><b>Example&nbsp;3.5.&nbsp;Make use of group sequence</b></p><pre class="programlisting">@ZipCodeCoherenceChecker(groups = Address.HighLevelCoherence.class)
public class Address {
    @NotNull @Size(max = 50)
    private String street1;

    @NotNull @ZipCode
    private String zipcode;

    @NotNull @Size(max = 30)
    private String city;

    /**
     * check coherence on the overall object
     * Needs basic checking to be green first
     */
    public interface HighLevelCoherence {}

    /**
     * check both basic constraints and high level ones.
     * high level constraints are not checked if basic constraints fail
     */
    @GroupSequence({Default.class, HighLevelCoherence.class})
    public interface Complete {}
}</pre></div><p>In <a href="#example-groupsequence" title="Example&nbsp;3.5.&nbsp;Make use of group sequence">Example&nbsp;3.5, &#8220;Make use of group sequence&#8221;</a>, when the
        <tt class="classname">Address.Complete</tt> group is validated, all
        constraints belonging to the <tt class="classname">Default</tt> group are
        validated. If any of them fail, the validation skips the
        <tt class="classname">HighLevelCoherence</tt> group. If all
        <tt class="classname">Default</tt> constraints pass,
        <tt class="classname">HighLevelCoherence</tt> constraints are
        evaluated.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A given constraint can belong to two or more groups ordered by
          a sequence. In this case, the constraint is evaluated as part of the
          first group and ignored in the subsequent group(s). See <a href="#constraintdeclarationvalidationprocess-validationroutine" title="3.5.&nbsp;Validation routine">Section&nbsp;3.5, &#8220;Validation routine&#8221;</a>
          for more information.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup"></a>3.4.3.&nbsp;Redefining the Default group for a class</h3></div></div><div></div></div><p>In <a href="#example-groupsequence" title="Example&nbsp;3.5.&nbsp;Make use of group sequence">Example&nbsp;3.5, &#8220;Make use of group sequence&#8221;</a>, validating the
        <tt class="classname">Default</tt> group does not validate
        <tt class="classname">HighLevelCoherence</tt> constraints. To ensure a
        complete validation, a user must use the
        <tt class="classname">Complete</tt> group. This breaks some of the
        encapsulation you could expect. You can work around this by redefining
        what the <tt class="classname">Default</tt> group means for a given class.
        To redefine <tt class="classname">Default</tt> for a class, place a
        <tt class="classname">@GroupSequence</tt> annotation on the class ; this
        sequence expresses the sequence of groups that does substitute
        <tt class="classname">Default</tt> for this class.</p><div class="example"><a name="example-overridedefaultgroup"></a><p class="title"><b>Example&nbsp;3.6.&nbsp;Redefining Default group for Address</b></p><pre class="programlisting">@GroupSequence({Address.class, HighLevelCoherence.class})
@ZipCodeCoherenceChecker(groups = Address.HighLevelCoherence.class)
public class Address {
    @NotNull @Size(max = 50)
    private String street1;

    @NotNull @ZipCode
    private String zipcode;

    @NotNull @Size(max = 30)
    private String city;

    /**
     * check coherence on the overall object
     * Needs basic checking to be green first
     */
    public interface HighLevelCoherence {}
}</pre></div><p>In <a href="#example-overridedefaultgroup" title="Example&nbsp;3.6.&nbsp;Redefining Default group for Address">Example&nbsp;3.6, &#8220;Redefining Default group for Address&#8221;</a>, when an
        address object is validated for the group
        <tt class="classname">Default</tt>, all constraints belonging to the group
        <tt class="classname">Default</tt> and hosted on
        <tt class="classname">Address</tt> are evaluated. If none fails, all
        <tt class="classname">HighLevelCoherence</tt> constraints present on
        <tt class="classname">Address</tt> are evaluated. In other words, when
        validating the <tt class="classname">Default</tt> group for
        <tt class="classname">Address</tt>, the group sequence defined on the
        <tt class="classname">Address</tt> class is used.</p><p>Since sequences cannot have circular dependencies, using
        <tt class="classname">Default</tt> in the declaration of a sequence is not
        an option. Constraints hosted on a class <tt class="classname">A</tt> and
        belonging to the <tt class="classname">Default</tt> group (by default or
        explicitly) implicitly belong to the group
        <tt class="classname">A</tt>.</p><p>A sequence defined on a class <tt class="classname">A</tt> (i.e.
        redefining the <tt class="classname">Default</tt> groups for the class)
        must contain the group <tt class="classname">A</tt>. In other words, the
        default constraints hosted on a class must be part of the sequence
        definition. If a <tt class="classname">@GroupSequence</tt> redefining the
        <tt class="classname">Default</tt> group for a class
        <tt class="classname">A</tt> does not contain the group
        <tt class="classname">A</tt>, a
        <tt class="classname">GroupDefinitionException</tt> is raised when the
        class is validated or when its metadata is requested.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-groupsequence-implicitgrouping"></a>3.4.4.&nbsp;Implicit grouping</h3></div></div><div></div></div><p>It is possible to implicitly group several constraints in the
        same group without explicitly listing such a group in the constraint
        declaration. Every constraint hosted on an interface
        <tt class="classname">Z</tt> and part of the
        <tt class="classname">Default</tt> group (implicitly or explicitly)
        belongs to the group <tt class="classname">Z</tt>. This is useful to
        validate the partial state of an object based on a role represented by
        an interface.</p><div class="example"><a name="d0e1425"></a><p class="title"><b>Example&nbsp;3.7.&nbsp;Example of interface / group hosting constraints</b></p><pre class="programlisting">/**
 * Auditable object contract
 */
public interface Auditable {
    @NotNull String getCreationDate();
    @NotNull String getLastUpdate();
    @NotNull String getLastModifier();
    @NotNull String getLastReader();
}

/**
 * Represents an order in the system
 */
public class Order implements Auditable {
    private String creationDate;
    private String lastUpdate;
    private String lastModifier;
    private String lastReader;

    private String orderNumber;

    public String getCreationDate() {
        return this.creationDate;
    }

    public String getLastUpdate() {
        return this.lastUpdate;
    }

    public String getLastModifier() {
        return this.lastModifier;
    }

    public String getLastReader() {
        return this.lastReader;
    }

    @NotNull @Size(min=10, max=10)
    public String getOrderNumber() {
        return this.orderNumber;
    }
}</pre></div><p>When an <tt class="classname">Order</tt> object is validated on the
        <tt class="classname">Default</tt> group, the following constraints are
        validated: <tt class="classname">@NotNull</tt> on
        <tt class="methodname">getCreationDate</tt>,
        <tt class="methodname">getLastUpdate</tt>,
        <tt class="methodname">getLastModifier</tt>,
        <tt class="methodname">getLastReader</tt>,
        <tt class="methodname">getOrderNumber</tt> and
        <tt class="classname">@Size</tt> on
        <tt class="methodname">getOrderNumber</tt> as all belong to the
        <tt class="classname">Default</tt> group.</p><p>When an <tt class="classname">Order</tt> object is validated on the
        <tt class="classname">Auditable</tt> group, the following constraints are
        validated: <tt class="classname">@NotNull</tt> on
        <tt class="methodname">getCreationDate</tt>,
        <tt class="methodname">getLastUpdate</tt>,
        <tt class="methodname">getLastModifier</tt>,
        <tt class="methodname">getLastReader</tt>. Only the constraints present
        on <tt class="classname">Auditable</tt> (and any of its super interfaces)
        and belonging to the <tt class="classname">Default</tt> group are
        validated when the group <tt class="classname">Auditable</tt> is
        requested. It allows the caller to validate that a given object can be
        safely audited even if the object state itself is not valid.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-groupsequence-formaldefinition"></a>3.4.5.&nbsp;Formal group definitions</h3></div></div><div></div></div><p>The formal rules defining groups are as followed. <span class="emphasis"><em>Text
        in italic are comments about the rules.</em></span></p><p>For every class <tt class="classname">X</tt>:</p><div class="orderedlist"><ol type="A"><li><p>For each superclass <tt class="classname">Y</tt> of
            <tt class="classname">X</tt>, the group <tt class="classname">Y</tt>
            contains all constraints of the group <tt class="classname">Y</tt> of
            <tt class="classname">Y</tt></p><p><span class="emphasis"><em>this rule prepares formal concepts for recursive
            discovery</em></span></p></li><li><p>The group <tt class="classname">X</tt> contains the following
            constraints:</p><p><span class="emphasis"><em>group <tt class="classname">X</tt> is a group used on
            sequences redefining the default group on a class (see <a href="#constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup" title="3.4.3.&nbsp;Redefining the Default group for a class">Section&nbsp;3.4.3, &#8220;Redefining the Default group for a class&#8221;</a>)</em></span></p><div class="orderedlist"><ol type="I"><li><p>every constraint declared by the class
                <tt class="classname">X</tt> which does not declare a group or
                does declare the group <tt class="classname">Default</tt>
                explicitly.</p><p><span class="emphasis"><em>all <tt class="classname">Default</tt> constraints
                hosted on <tt class="classname">X</tt></em></span></p></li><li><p>every constraint declared by any interface implemented
                by <tt class="classname">X</tt> and not annotated
                <tt class="classname">@GroupSequence</tt> which does not
                explicitly declare a group or does declare the group
                <tt class="classname">Default</tt> explicitly.</p><p><span class="emphasis"><em>all <tt class="classname">Default</tt> constraints
                hosted on interfaces of <tt class="classname">X</tt>: constraints
                are inherited by the class hierarchy. Interfaces marked as
                <tt class="classname">@GroupSequence</tt> are
                ignored.</em></span></p></li><li><p>if <tt class="classname">X</tt> has a direct superclass
                <tt class="classname">Y</tt>, every constraint in the group
                <tt class="classname">Y</tt></p><p><span class="emphasis"><em>all <tt class="classname">Default</tt> constraints
                hosted on the superclasses of <tt class="classname">X</tt>:
                constraints are inherited by the class
                hierarchy</em></span></p></li></ol></div></li><li><p>If <tt class="classname">X</tt> has no
            <tt class="classname">@GroupSequence</tt> annotation, the group
            <tt class="classname">Default</tt> contains the following
            constraints:</p><p><span class="emphasis"><em>this rule defines which constraints are evaluated
            when validating <tt class="classname">Default</tt> on
            <tt class="classname">X</tt>.</em></span></p><div class="orderedlist"><ol type="I"><li><p>every constraint in the group
                <tt class="classname">X</tt></p></li><li><p>if <tt class="classname">X</tt> has a direct superclass
                <tt class="classname">Y</tt>, every constraint in the group
                <tt class="classname">Default</tt> of
                <tt class="classname">Y</tt></p><p><span class="emphasis"><em>this rule is necessary in case
                <tt class="classname">Y</tt> redefines the group
                <tt class="classname">Default</tt></em></span></p></li></ol></div></li><li><p>If <tt class="classname">X</tt> does have a
            <tt class="classname">@GroupSequence</tt> annotation, the group
            <tt class="classname">Default</tt> contains every constraint belonging
            to every group declared by the
            <tt class="classname">@GroupSequence</tt> annotation.</p><p><span class="emphasis"><em>this rule describes how a class can redefine the
            group <tt class="classname">Default</tt> for itself (see <a href="#constraintdeclarationvalidationprocess-groupsequence-redefiningdefaultgroup" title="3.4.3.&nbsp;Redefining the Default group for a class">Section&nbsp;3.4.3, &#8220;Redefining the Default group for a class&#8221;</a>)</em></span></p><div class="itemizedlist"><ul type="disc"><li><p>the <tt class="classname">@GroupSequence</tt> annotation
                must declare the group <tt class="classname">X</tt></p></li></ul></div></li><li><p>For every interface <tt class="classname">Z</tt>, the group
            <tt class="classname">Z</tt> contains the following
            constraints:</p><p><span class="emphasis"><em>this rule defines how non
            <tt class="classname">Default</tt> groups are
            defined</em></span></p><div class="orderedlist"><ol type="I"><li><p>every constraint declared by the interface
                <tt class="classname">Z</tt> which does not explicitly declare a
                group or does declare the group <tt class="classname">Default</tt>
                explicitly.</p><p><span class="emphasis"><em>all <tt class="classname">Default</tt> constraints
                hosted on <tt class="classname">Z</tt>: this rule formally defines
                implicit grouping per interface (see <a href="#constraintdeclarationvalidationprocess-groupsequence-implicitgrouping" title="3.4.4.&nbsp;Implicit grouping">Section&nbsp;3.4.4, &#8220;Implicit grouping&#8221;</a>)</em></span></p></li><li><p>every constraint (which does not explicitly declare a
                group) declared by any superinterface not annotated
                <tt class="classname">@GroupSequence</tt> of the interface
                <tt class="classname">Z</tt> </p><p><span class="emphasis"><em>all <tt class="classname">Default</tt> constraints
                hosted on interfaces of <tt class="classname">Z</tt>: groups can
                be inherited (see <a href="#constraintdeclarationvalidationprocess-groupsequence-groupinheritance" title="3.4.1.&nbsp;Group inheritance">Section&nbsp;3.4.1, &#8220;Group inheritance&#8221;</a>)</em></span></p></li><li><p>every constraint declared by the class
                <tt class="classname">X</tt> which explicitly declares the group
                <tt class="classname">Z</tt></p><p><span class="emphasis"><em>every constraint hosted by
                <tt class="classname">X</tt> and marked as belonging to the group
                <tt class="classname">Z</tt></em></span></p></li><li><p>every constraint declared by any interface implemented
                by <tt class="classname">X</tt> and not annotated
                <tt class="classname">@GroupSequence</tt> which explicitly
                declares the group <tt class="classname">Z</tt></p><p><span class="emphasis"><em>every constraint hosted by any interface of
                <tt class="classname">X</tt> and marked as belonging to the group
                <tt class="classname">Z</tt></em></span></p></li><li><p>if <tt class="classname">X</tt> has a direct superclass
                <tt class="classname">Y</tt>, every constraint in the group
                <tt class="classname">Z</tt> of <tt class="classname">Y</tt></p><p><span class="emphasis"><em>every constraint hosted by any superclass of
                <tt class="classname">X</tt> and marked as belonging to the group
                <tt class="classname">Z</tt></em></span></p></li></ol></div></li><li><p>For every interface <tt class="classname">Z</tt> annotated
            <tt class="classname">@GroupSequence</tt>, the group
            <tt class="classname">Z</tt> contains every constraint belonging to
            every group declared by the <tt class="classname">@GroupSequence</tt>
            annotation.</p><p><span class="emphasis"><em>defines the composition side of group sequence but
            does not define the ordering behavior of sequence (see <a href="#constraintdeclarationvalidationprocess-groupsequence-groupsequence" title="3.4.2.&nbsp;Group sequence">Section&nbsp;3.4.2, &#8220;Group sequence&#8221;</a>)</em></span></p></li></ol></div><p>When a given group <tt class="classname">G</tt> (represented by an
        interface <tt class="classname">G</tt>) is requested for the validation of
        a class <tt class="classname">X</tt>:</p><div class="itemizedlist"><ul type="disc"><li><p>constraints belonging to the group <tt class="classname">G</tt>
            are evaluated</p></li><li><p>if the interface <tt class="classname">G</tt> is not annotated
            <tt class="classname">@GroupSequence</tt>, every group represented by
            the super interface of <tt class="classname">G</tt> are requested for
            validation</p></li><li><p>if the interface <tt class="classname">G</tt> is annotated with
            <tt class="classname">@GroupSequence</tt>, every group represented by
            the interfaces declared by the
            <tt class="classname">@GroupSequence</tt> annotation are requested for
            validation</p><div class="itemizedlist"><ul type="circle"><li><p>the validation of groups declared to the
                <tt class="classname">@GroupSequence</tt> must happen in the
                sequencing order declared by
                <tt class="classname">@GroupSequence</tt>: the sequencing order is
                propagated to the groups composing the sequenced group (via
                inheritance or group sequence)</p></li><li><p>if a group validation triggers the failure of one or
                more constraints, groups following in the sequence must not be
                evaluated.</p></li></ul></div></li><li><p>if the group <tt class="classname">G</tt> represents the
            <tt class="classname">Default</tt> group of <tt class="classname">X</tt>
            overridden by <tt class="classname">@GroupSequence</tt>, operations
            are equivalent</p></li></ul></div><p>When the <tt class="classname">Default</tt> group of a given class
        <tt class="classname">X</tt> is overridden via
        <tt class="classname">@GroupSequence</tt>, its validation is as
        followed:</p><div class="itemizedlist"><ul type="disc"><li><p>every group represented by the interfaces declared by the
            <tt class="classname">@GroupSequence</tt> annotation are requested for
            validation</p><div class="itemizedlist"><ul type="circle"><li><p>the validation of groups declared to the
                <tt class="classname">@GroupSequence</tt> must happen in the
                sequencing order declared by
                <tt class="classname">@GroupSequence</tt>: the sequencing order is
                propagated to the groups composing the sequenced group (via
                inheritance or group sequence)</p></li><li><p>if a group validation triggers the failure of one or
                more constraints, groups following in the sequence must not be
                evaluated.</p></li></ul></div></li></ul></div><p>Unless defined by a <tt class="classname">@GroupSequence</tt>,
        evaluation ordering is not constrained. In particular, several groups
        can be validated in the same pass. If a group definition leads to a
        circular sequencing order between groups, a
        <tt class="classname">GroupDefinitionException</tt> is raised.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A group <tt class="classname">G</tt> sequenced (directly or
          indirectly) to be executed before itself is not considered a
          circular reference.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintdeclarationvalidationprocess-validationroutine"></a>3.5.&nbsp;Validation routine</h2></div></div><div></div></div><p>For a given group to validate, the validation routine applied on a
      given bean instance is expected to execute the following constraint
      validations in no particular order:</p><div class="itemizedlist"><ul type="disc"><li><p>for all <span class="emphasis"><em>reachable</em></span> fields, execute all
          field level validations (including the ones expressed on
          superclasses) matching the targeted group unless the given
          validation constraint has already been processed during this
          validation routine for a given navigation path (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="3.5.1.&nbsp;Object graph validation">Section&nbsp;3.5.1, &#8220;Object graph validation&#8221;</a>)
          as part of a previous group match.</p></li><li><p>for all <span class="emphasis"><em>reachable</em></span> getters, execute all
          getter level validations (including the ones expressed on interfaces
          and superclasses) matching the targeted group unless the given
          validation constraint has already been processed during this
          validation routine for a given navigation path (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="3.5.1.&nbsp;Object graph validation">Section&nbsp;3.5.1, &#8220;Object graph validation&#8221;</a>)
          as part of a previous group match.</p></li><li><p>execute all class level validations (including the ones
          expressed on interfaces and superclasses) matching the targeted
          group unless the given validation constraint has already been
          processed during this validation routine for a given navigation path
          (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="3.5.1.&nbsp;Object graph validation">Section&nbsp;3.5.1, &#8220;Object graph validation&#8221;</a>)
          as part of a previous group match.</p></li><li><p>for all <span class="emphasis"><em>reachable</em></span> and
          <span class="emphasis"><em>cascadable</em></span> associations, execute all cascading
          validations (see <a href="#constraintdeclarationvalidationprocess-validationroutine-graphvalidation" title="3.5.1.&nbsp;Object graph validation">Section&nbsp;3.5.1, &#8220;Object graph validation&#8221;</a>)
          including the ones expressed on interfaces and superclasses (see
          <a href="#constraintdeclarationvalidationprocess-groupsequence-formaldefinition" title="3.4.5.&nbsp;Formal group definitions">Section&nbsp;3.4.5, &#8220;Formal group definitions&#8221;</a>)</p></li></ul></div><p>Reachable fields, getters and associations as well as cascadable
      associations are defined in <a href="#constraintdeclarationvalidationprocess-validationroutine-traversable" title="3.5.2.&nbsp;Traversable property">Section&nbsp;3.5.2, &#8220;Traversable property&#8221;</a>.</p><p>Note that this implies that a given validation constraint will not
      be processed more than once per validation.</p><p>Unless ordered by group sequences, groups can be validated in no
      particular order. This implies that the validation routine can be run
      for several groups in the same pass.</p><p>The object validation routine is described as such. For each
      constraint declaration:</p><div class="itemizedlist"><ul type="disc"><li><p>determine for the constraint declaration, the appropriate
          <tt class="classname">ConstraintValidator</tt> to use (see <a href="#typevalidatorresolution" title="3.5.3.&nbsp;ConstraintValidator resolution algorithm">Section&nbsp;3.5.3, &#8220;ConstraintValidator resolution algorithm&#8221;</a>).</p></li><li><p>execute the <tt class="methodname">isValid</tt> operation (from
          the constraint validation implementation) on the appropriate data
          (see <a href="#constraintsdefinitionimplementation-validationimplementation" title="2.4.&nbsp;Constraint validation implementation">Section&nbsp;2.4, &#8220;Constraint validation implementation&#8221;</a>)</p></li><li><p>if <tt class="methodname">isValid</tt> returns true, continue to
          the next constraint,</p></li><li><p>if <tt class="methodname">isValid</tt> returns false, the Bean
          Validation provider populates
          <tt class="classname">ConstraintViolation</tt> object(s) according to
          the rules defined in <a href="#constraintsdefinitionimplementation-validationimplementation" title="2.4.&nbsp;Constraint validation implementation">Section&nbsp;2.4, &#8220;Constraint validation implementation&#8221;</a>
          and appends these objects to the list of constraint
          violations.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-validationroutine-graphvalidation"></a>3.5.1.&nbsp;Object graph validation</h3></div></div><div></div></div><p>The <tt class="classname">@Valid</tt> annotation on a given
        association (i.e. object reference or collection, array,
        <tt class="classname">Iterable</tt> of objects), dictates the Bean
        Validator implementation to apply recursively the Bean Validation
        routine on (each of) the associated object(s). This mechanism is
        recursive: an associated object can itself contain cascaded
        references.</p><p>Null references are ignored.</p><p>To prevent infinite loops, the Bean Validation implementation
        must ignore the cascading operation if the associated object instance
        has already been validated in the current navigation path (starting
        from the root object). See <a href="#example-oglimit" title="Example&nbsp;3.8.&nbsp;Object graph limits">Example&nbsp;3.8, &#8220;Object graph limits&#8221;</a> for an
        example. A navigation path is defined as a set of
        <tt class="classname">@Valid</tt> associations starting from the root
        object instance and reaching the associated instance. A given
        navigation path cannot contain the same instance multiple times (the
        complete validated object graph can though). See <a href="#example-oglimit" title="Example&nbsp;3.8.&nbsp;Object graph limits">Example&nbsp;3.8, &#8220;Object graph limits&#8221;</a> for an example.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This object graph navigation can lead to multiple validations
          of the same constraint and the same object instance but the set of
          constraint validation is deterministic and the algorithm prevents
          infinite loops.</p></div><div class="example"><a name="example-oglimit"></a><p class="title"><b>Example&nbsp;3.8.&nbsp;Object graph limits</b></p><pre class="programlisting">#assuming the following object graph

Order -(lines)-&gt; Orderline1
Order -(lines)-&gt; Orderline2
Orderline1 -(order)-&gt; Order
Orderline2 -(order)-&gt; Order
Order -(customer)-&gt; User
Order -(shippingAddress)-&gt; Address1
Order -(billingAddress)-&gt; Address2
Address1 -(inhabitant)-&gt; User
Address2 -(inhabitant)-&gt; User
User -(addresses)-&gt; Address1
User -(addresses)-&gt; Address2

#validation branches are as followed
Order -(lines)-&gt; Orderline1
  - order is ignored: Order is already present in the branch 

Order -(lines)-&gt; Orderline2
  - order is ignored: Order is already present in the branch

Order -(customer)-&gt; User -(addresses)-&gt; Address1
  - inhabitant is ignored: User is already present in the branch

Order -(customer)-&gt; User -(addresses)-&gt; Address2
  - inhabitant is ignored: User is already present in the branch

Order -(shippingAddress)-&gt; Address1 -(inhabitant)-&gt; User 
  - addresses to Address1 is ignored: Address1 is already present in the branch

Order -(shippingAddress)-&gt; Address1 -(inhabitant)-&gt; User -(addresses)-&gt; Address2
  - inhabitant is ignored: User is already present in the branch

Order -(billingAddress)-&gt; Address2 -(inhabitant)-&gt; User 
  - addresses to Address2 is ignored: Address2 is already present in the branch

Order -(billingAddress)-&gt; Address2 -(inhabitant)-&gt; User -(addresses)-&gt; Address1
  - inhabitant is ignored: User is already present in the branch</pre></div><p>The <tt class="classname">ConstraintViolation</tt> objects are built
        when a failing constraint on an associated object is found. They
        reflect the path to reach the object from the root validated object
        (See <a href="#validationapi-constraintviolation" title="4.2.&nbsp;ConstraintViolation">Section&nbsp;4.2, &#8220;ConstraintViolation&#8221;</a>).</p><p><tt class="classname">@Valid</tt> is an orthogonal concept to the
        notion of group. If two groups are in sequence, the first group must
        pass for all associated objects before the second group is evaluated.
        Note however that the <tt class="classname">Default</tt> group sequence
        overriding is local to the class it is defined on and is not
        propagated to the associated objects. The following example
        illustrates this:</p><div class="example"><a name="d0e2064"></a><p class="title"><b>Example&nbsp;3.9.&nbsp;Class Driver with redefined default group</b></p><pre class="programlisting">@GroupSequence({ Minimal.class, Driver.class })
public class Driver {
  @Min(value = 18, groups = Minimal.class)
  int age;

  @AssertTrue
  Boolean passedDrivingTest;

  @Valid
  Car car;

  // setter/getters
}</pre></div><div class="example"><a name="d0e2069"></a><p class="title"><b>Example&nbsp;3.10.&nbsp;Class Car with redefined default group</b></p><pre class="programlisting">@GroupSequence({ Car.class, Later.class })
public class Car {
  @NotNull
  String type;

  @AssertTruegroups = Later.class)
  Boolean roadWorthy;

  // setter/getters
}</pre></div><div class="example"><a name="d0e2074"></a><p class="title"><b>Example&nbsp;3.11.&nbsp;Defining a group sequence</b></p><pre class="programlisting">@GroupSequence({ Minimal.class, Later.class })
public interface SequencedGroups {
}</pre></div><div class="example"><a name="d0e2079"></a><p class="title"><b>Example&nbsp;3.12.&nbsp;Group sequence overriding is not propagated to associated
            objects</b></p><pre class="programlisting">Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Driver driver = new Driver();
driver.setAge(16);
Car porsche = new Car();
driver.setCar(porsche);


Set&lt;ConstraintViolation&lt;Driver&gt;&gt; violations = validator.validate( driver );

assert violations.size() == 2;

violations = validator.validate( driver, SequencedGroups.class );

assert violations.size() == 1;</pre></div><p>The default group sequence is redefined for the
        <tt class="classname">Driver</tt> as well as <tt class="classname">Car</tt>.
        When the default group is requested via
        <tt class="methodname">validator.validate( driver )</tt> the group
        <tt class="classname">Minimal</tt> gets validated in class
        <tt class="classname">Driver</tt>. The constraint will fail since the
        driver's age in the example is only 16. The constraint on
        <span class="property">passedDrivingTest</span> will not be evaluated due to
        the redefined default sequence of <tt class="classname">Driver</tt>.
        However, there is one more constraint violation, namely the
        <tt class="classname">@NotNull</tt> on <span class="property">Car.type</span>. The
        reason for this is that the group <tt class="classname">Default</tt> gets
        propagated to <tt class="classname">Car</tt> (not
        <tt class="classname">Minimal</tt>). Class <tt class="classname">Driver</tt>
        defines its own group sequence which means that <tt class="classname">only
        @NotNull</tt> on <span class="property">type</span> gets
        evaluated.</p><p>In the second call to <tt class="methodname">validate</tt> the
        group <tt class="classname">SequencedGroups</tt> is requested which
        defines a sequence of <tt class="classname">Minimal</tt> followed by
        <tt class="classname">Later</tt>. In this case there is only one
        constraint violation. Again <tt class="classname">@Min</tt> on
        <span class="property">age</span> fails, but in this case the group
        <tt class="classname">Minimal</tt> gets propagated to
        <tt class="classname">Car</tt> which does not have any constraints defined
        against this group. Constraints belonging to the group
        <tt class="classname">Later</tt> won't get validated until all constraints
        belonging to <tt class="classname">Minimal</tt> pass.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="constraintdeclarationvalidationprocess-validationroutine-traversable"></a>3.5.2.&nbsp;Traversable property</h3></div></div><div></div></div><p>In some cases, the state of some properties should not be
        accessed. For example, if a property loaded by a Java Persistence
        provider is a lazy property or a lazy association, accessing its state
        would trigger a load from the database. An undesired behavior.</p><p>Bean Validation offers a way to control which property can and
        cannot be accessed via the
        <tt class="classname">TraversableResolver.isReachable</tt>()
        contract.</p><p>Likewise, it is sometimes undesirable to cascade validation
        despite the use of <tt class="classname">@Valid</tt>. Java Persistence 2
        for example does not cascade to associated entities during flush. You
        can control this behavior by implementing
        <tt class="methodname">Traversable.isCascadable()</tt>.</p><pre class="programlisting">/**
 * Contract determining if a property can be accessed by the Bean Validation provider.
 * This contract is called for each property that is being either validated or cascaded.
 *
 * A traversable resolver implementation must be thread-safe.
 *
 * @author Emmanuel Bernard
 */
public interface TraversableResolver {
    /**
     * Determine if the Bean Validation provider is allowed to reach the property state
     *
     * @param traversableObject object hosting &lt;code&gt;traversableProperty&lt;/code&gt; or null
     *                          if &lt;code&gt;validateValue&lt;/code&gt; is called
     * @param traversableProperty the traversable property.
     * @param rootBeanType type of the root object passed to the Validator.
     * @param pathToTraversableObject path from the root object to
     *        &lt;code&gt;traversableObject&lt;/code&gt;
     *        (using the path specification defined by Bean Validator).
     * @param elementType either &lt;code&gt;FIELD&lt;/code&gt; or &lt;code&gt;METHOD&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the Bean Validation provider is allowed to
     *         reach the property state, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    boolean isReachable(Object traversableObject,
                        Path.Node traversableProperty,
                        Class&lt;?&gt; rootBeanType,
                        Path pathToTraversableObject,
                        ElementType elementType);

    /**
     * Determine if the Bean Validation provider is allowed to cascade validation on
     * the bean instance returned by the property value
     * marked as &lt;code&gt;@Valid&lt;/code&gt;.
     * Note that this method is called only if &lt;code&gt;isReachable&lt;/code&gt; returns true
     * for the same set of arguments and if the property is marked as &lt;code&gt;@Valid&lt;/code&gt;
     *
     * @param traversableObject object hosting &lt;code&gt;traversableProperty&lt;/code&gt; or null
     *                          if &lt;code&gt;validateValue&lt;/code&gt; is called
     * @param traversableProperty the traversable property.
     * @param rootBeanType type of the root object passed to the Validator.
     * @param pathToTraversableObject path from the root object to
     *        &lt;code&gt;traversableObject&lt;/code&gt;
     *        (using the path specification defined by Bean Validator).
     * @param elementType either &lt;code&gt;FIELD&lt;/code&gt; or &lt;code&gt;METHOD&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the Bean Validation provider is allowed to
     *         cascade validation, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    boolean isCascadable(Object traversableObject,
                         Path.Node traversableProperty,
                         Class&lt;?&gt; rootBeanType,
                         Path pathToTraversableObject,
                         ElementType elementType);
}</pre><p><tt class="methodname">isReachable</tt> is called for every
        property about to be accessed either for validation or for cascading.
        A property is <span class="emphasis"><em>reachable</em></span> if this method returns
        true.</p><p><tt class="methodname">isCascadable</tt> is called for every
        property about to be cascaded (i.e. marked as
        <tt class="classname">@Valid</tt>). A property is
        <span class="emphasis"><em>cascadable</em></span> if it is reachable and if the
        <tt class="methodname">isCascadable</tt> method returns true.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><tt class="methodname">isCascadable</tt> for a given property is
          only called if <tt class="methodname">isReachable</tt> returns true. In
          other words, <tt class="methodname">isReachable</tt> is always called
          before <tt class="methodname">isCascadable</tt> for a given
          property.</p></div><p><tt class="literal">traversableObject</tt> is the object instance
        being evaluated. <tt class="literal">null</tt> if the check is triggered as
        part of a <tt class="methodname">validateValue</tt> call.</p><p><tt class="literal">traversableProperty</tt> is the
        <tt class="classname">Node</tt> representing the property hosted by the
        <tt class="methodname">traversableObject</tt> being considered for
        traversal. The name of a property is defined in <a href="#constraintdeclarationvalidationprocess-requirements-property" title="3.1.2.&nbsp;Field and property validation">Section&nbsp;3.1.2, &#8220;Field and property validation&#8221;</a>.</p><p><tt class="literal">rootBeanType</tt> is the class of the root being
        validated (and passed to the <tt class="methodname">validate</tt>
        method).</p><p><tt class="literal">pathToTraversableObject</tt> is the
        <tt class="classname">Path</tt> from the
        <tt class="methodname">rootBeanType</tt> down to the
        <tt class="methodname">traversableObject</tt>. If the root object is
        <tt class="classname">traversableObject</tt>,
        <tt class="classname">pathToTraversableObject</tt> is composed of a single
        Node whose name is null. The path is described following the
        conventions described in <a href="#validationapi-constraintviolation" title="4.2.&nbsp;ConstraintViolation">Section&nbsp;4.2, &#8220;ConstraintViolation&#8221;</a>
        (<tt class="methodname">getPropertyPath</tt>).</p><p><tt class="literal">elementType</tt> is the
        <tt class="classname">java.lang.annotation.ElementType</tt> the annotation
        is placed on. It can be either <tt class="literal">FIELD</tt> or
        <tt class="literal">METHOD</tt>. Any other value is not expected.</p><p>The Bean Validation provider must not access the state of a
        property, nor validate its constraints if the property is not
        traversable. A property is traversable if
        <tt class="classname">TraversableResolver</tt> returns true for this
        property.</p><p>If an exception occurs when the
        <tt class="classname">TraversableResolver</tt> is called, the exception is
        wrapped into a <tt class="classname">ValidationException</tt>.</p><p>The following example assumes the object graph defined in <a href="#example-ognav-definitions" title="Example&nbsp;3.13.&nbsp;Definitions used in the example">Example&nbsp;3.13, &#8220;Definitions used in the example&#8221;</a> and assumes the validation
        operation is applied on an address object.</p><div class="example"><a name="example-ognav-definitions"></a><p class="title"><b>Example&nbsp;3.13.&nbsp;Definitions used in the example</b></p><pre class="programlisting">public class Country {
    @NotNull private String name;
    @Size(max=2) private String ISO2Code;
    @Size(max=3) private String ISO3Code;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getISO2Code() {
        return ISO2Code;
    }

    public void setISO2Code(String ISO2Code) {
        this.ISO2Code = ISO2Code;
    }

    public String getISO3Code() {
        return ISO3Code;
    }

    public void setISO3Code(String ISO3Code) {
        this.ISO3Code = ISO3Code;
    }
}

public class Address {
    @NotNull @Size(max=30)
    private String addressline1;
    @Size(max=30)
    private String addressline2;
    @Size(max=11)
    private String zipCode;
    @Valid
    private Country country;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }
}</pre></div><p>When the Bean Validation provider is about to check constraints
        of <tt class="literal">ISO3Code</tt>, it calls the
        <tt class="classname">TraversableResolver.isReachable()</tt> instance to
        ensure that the <tt class="literal">ISO3Code</tt> property is reachable with
        the following parameter values:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">traversableObject</tt>: country. The instance
            returned by <tt class="code">address.getCountry()</tt>.</p></li><li><p><tt class="literal">traversableProperty</tt>: a
            <tt class="classname">Node</tt> whose name is "ISO3Code". The name of
            the property of <tt class="literal">traversableObject</tt> being
            verified.</p></li><li><p><tt class="methodname">rootBeanType</tt>: Address.class. The
            type of the root object being validated.</p></li><li><p><tt class="literal">pathtoTraversableObject</tt>: a
            <tt class="classname">Path</tt> containing a single
            <tt class="classname">Node</tt> whose name is "country". The path from
            address to the country instance.</p></li><li><p><tt class="literal">elementType</tt>:
            <tt class="classname">ElementType.FIELD</tt>. The ISO3Code property is
            annotated on its field.</p></li></ul></div><p>When the Bean Validation provider is about to cascade validation
        on <tt class="literal">country</tt> (<tt class="classname">Address</tt> object),
        it calls the <tt class="classname">TraversableResolver.isReachable()</tt>
        instance to ensure that the <tt class="literal">country</tt> property is
        reachable and if this method returns true, it calls
        <tt class="classname">TraversableResolver.isCascadable()</tt> with the
        following parameter values:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">traversableObject</tt>: address. The address
            instance.</p></li><li><p><tt class="literal">traversableProperty</tt>: a
            <tt class="classname">Node</tt> whose name is "country". The name of
            the property of <tt class="literal">traversableObject</tt> being
            verified.</p></li><li><p><tt class="methodname">rootBeanType</tt>: Address.class. The
            type of the root object being validated.</p></li><li><p><tt class="literal">pathtoTraversableObject</tt>: a
            <tt class="classname">Path</tt> containing a single
            <tt class="classname">Node</tt> whose name is null.</p></li><li><p><tt class="literal">elementType</tt>:
            <tt class="classname">ElementType.FIELD</tt>. The country property is
            annotated on its field.</p></li></ul></div><div class="example"><a name="d0e2417"></a><p class="title"><b>Example&nbsp;3.14.&nbsp;Java Persistence aware TraversableResolver</b></p><pre class="programlisting">public class JPATraversableResolver implements TraversableResolver {

    public boolean isReachable(Object traversableObject, 
                               Path.Node traversableProperty, 
                               Class&lt;?&gt; rootBeanType, 
                               Path pathToTraversableObject, 
                               ElementType elementType) {
        return traversableObject == null ||
                Persistence.getPersistenceUtil().isLoaded( 
                        traversableObject, 
                        traversableProperty.getName() );
    }

    public boolean isCascadable(Object traversableObject, 
                               Path.Node traversableProperty, 
                               Class&lt;?&gt; rootBeanType, 
                               Path pathToTraversableObject, 
                               ElementType elementType) {
        return true;
    }
}</pre></div><p>The traversable resolver used by default in a Bean Validation
        behaves as followed:</p><div class="itemizedlist"><ul type="disc"><li><p>if Java Persistence is available in the runtime environment,
            a property is considered reachable if Java Persistence considers
            the property as loaded. A typical implementation will use
            <tt class="code">Persistence.getPersistenceUtil().isLoaded(Object,
            String)</tt> to implement such contract.</p></li><li><p>if Java Persistence is not available in the runtime
            environment, all properties are considered reachable.</p></li><li><p>all properties are considered cascadable.</p></li></ul></div><p>See <a href="#bootstrapping" title="4.4.&nbsp;Bootstrapping">Section&nbsp;4.4, &#8220;Bootstrapping&#8221;</a> to know how to pass a
        custom <tt class="classname">TraversableResolver</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="typevalidatorresolution"></a>3.5.3.&nbsp;ConstraintValidator resolution algorithm</h3></div></div><div></div></div><p>A constraint is associated to one or more
        <tt class="classname">ConstraintValidator</tt> implementations. Each
        <tt class="classname">ConstraintValidator&lt;A, T&gt;</tt> accepts the
        type <tt class="classname">T</tt>. The
        <tt class="classname">ConstraintValidator</tt> executed depends on the
        type hosting the constraint. For a given constraint evaluation, a
        single <tt class="classname">ConstraintValidator</tt> is
        considered.</p><p>If the constraint declaration is hosted on a class or an
        interface, the targeted type is the class or the interface. If the
        constraint is hosted on a class attribute, the type of the attribute
        is the targeted type. If the constraint is hosted on a getter, the
        return type of the getter is the targeted type. In other words, the
        resolution algorithm considers the type as defined in the method
        signature and not the runtime type of the value.</p><p>The rules written below describe formally the following
        statement: the <tt class="classname">ConstraintValidator</tt> chosen to
        validate a declared type <tt class="classname">T</tt> is the one where the
        type supported by the <tt class="classname">ConstraintValidator</tt> is a
        supertype of <tt class="classname">T</tt> and where there is no other
        <tt class="classname">ConstraintValidator</tt> whose supported type is a
        supertype of <tt class="classname">T</tt> and not a supertype of the
        chosen <tt class="classname">ConstraintValidator</tt> supported
        type.</p><p>When validating a constraint A placed on a target declaring the
        type <tt class="classname">T</tt>, the following resolution rules
        apply:</p><div class="itemizedlist"><ul type="disc"><li><p>Primitive types are considered equivalent to their
            respective primitive wrapper class. Likewise, arrays of primitive
            types are considered equivalent to arrays of their wrapper
            classes.</p></li><li><p>A <tt class="classname">ConstraintValidator&lt;A, U&gt;</tt> is
            said to be <span class="emphasis"><em>compliant</em></span> with
            <tt class="classname">T</tt> if <tt class="classname">T</tt> is a subtype
            of <tt class="classname">U</tt> (according to the<a href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.10" target="_top">
            Java Language Specification 3rd edition chapter 4.10
            Subtyping</a>). Note that <tt class="classname">T</tt> is a
            subtype of <tt class="classname">U</tt> if <tt class="classname">T</tt> =
            <tt class="classname">U</tt>.</p></li><li><p>If no <tt class="classname">ConstraintValidator</tt> compliant
            with <tt class="classname">T</tt> is found amongst the
            <tt class="classname">ConstraintValidator</tt>s listed by the
            constraint <tt class="classname">A</tt>, a
            <tt class="classname">UnexpectedTypeException</tt> is raised.</p></li><li><p>A <tt class="classname">ConstraintValidator&lt;A, U&gt;</tt>
            compliant with <tt class="classname">T</tt> is considered
            <span class="emphasis"><em>strictly more specific</em></span> than a
            <tt class="classname">ConstraintValidator&lt;A, V&gt;</tt> compliant
            with <tt class="classname">T</tt> if <tt class="classname">U</tt> is a
            strict subtype of <tt class="classname">V</tt>.
            <tt class="classname">U</tt> is a strict subtype of
            <tt class="classname">V</tt> if <tt class="classname">U</tt> is a subtype
            of <tt class="classname">V</tt> and <tt class="classname">U</tt> !=
            <tt class="classname">V</tt> (according to the <a href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.10" target="_top">Java
            Language Specification 3rd edition chapter 4.10
            Subtyping</a>).</p></li><li><p>A <tt class="classname">ConstraintValidator&lt;A, U&gt;</tt>
            compliant with <tt class="classname">T</tt> is considered maximally
            specific if no other <tt class="classname">ConstraintValidator&lt;A,
            V&gt;</tt> compliant with <tt class="classname">T</tt> is
            strictly more specific than <tt class="classname">ConstraintValidator&lt;A,
            U&gt;</tt>.</p></li><li><p>If more than one maximally specific
            <tt class="classname">ConstraintValidator</tt> is found, a
            <tt class="classname">UnexpectedTypeException</tt> is raised.</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>While the Java compiler itself cannot determine if a
          constraint declaration will lead to a
          <tt class="classname">UnexpectedTypeException</tt>, rules can be
          statically checked. A tool such as an IDE or a Java 6 annotation
          processor can apply these rules and prevent compilation in case of
          ambiguity. The specification encourages Bean Validation providers to
          provide such a tool to their users.</p></div><p>Let's see a couple of declarations and their respective
        <tt class="classname">ConstraintValidator</tt> resolution. Assuming the
        definitions shown in <a href="#example-constraintvalidator-resolution" title="Example&nbsp;3.15.&nbsp;ConstraintValidator and type resolution">Example&nbsp;3.15, &#8220;ConstraintValidator and type resolution&#8221;</a>:</p><div class="example"><a name="example-constraintvalidator-resolution"></a><p class="title"><b>Example&nbsp;3.15.&nbsp;ConstraintValidator and type resolution</b></p><pre class="programlisting">[...]
@Constraint(validatedBy={
    SizeValidatorForCollection.class,
    SizeValidatorForSet.class,
    SizeValidatorForSerializable.class })
public @interface Size { ...}

public class SizeValidatorForCollection implements ConstraintValidator&lt;Size, Collection&gt; { ... }
public class SizeValidatorForSet implements ConstraintValidator&lt;Size, Set&gt; { ... }
public class SizeValidatorForSerializable implements ConstraintValidator&lt;Size, Serializable&gt; { ... }

public interface SerializableCollection extends Serializable,  Collection {}</pre></div><p>The resolutions shown in <a href="#table-constraintvalidator-resolution" title="Table&nbsp;3.1.&nbsp;Resolution of ConstraintValidator for various constraints&#xA;          declarations">Table&nbsp;3.1, &#8220;Resolution of ConstraintValidator for various constraints
          declarations&#8221;</a> occur.</p><div class="table"><a name="table-constraintvalidator-resolution"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Resolution of ConstraintValidator for various constraints
          declarations</b></p><table summary="Resolution of ConstraintValidator for various constraints&#xA;          declarations" border="1"><colgroup><col align="center"><col></colgroup><thead><tr><th align="center">Declaration</th><th>Resolution</th></tr></thead><tbody><tr><td align="center"><tt class="code">@Size Collection getAddresses() { ...
                }</tt></td><td><tt class="classname">SizeValidatorForCollection</tt>:
                direct match</td></tr><tr><td align="center"><tt class="code">@Size Collection&lt;?&gt; getAddresses() { ...
                }</tt></td><td><tt class="classname">SizeValidatorForCollection</tt>:
                <tt class="classname">Collection</tt> is a direct supertype of
                <tt class="classname">Collection&lt;?&gt;</tt></td></tr><tr><td align="center"><tt class="code">@Size Collection&lt;Address&gt; getAddresses() {
                ... }</tt></td><td><tt class="classname">SizeValidatorForCollection</tt>:
                <tt class="classname">Collection</tt> is a direct supertype of
                <tt class="classname">Collection&lt;Address&gt;</tt></td></tr><tr><td align="center"><tt class="code">@Size Set&lt;Address&gt; getAddresses() { ...
                }</tt></td><td><tt class="classname">SizeValidatorForSet</tt>: direct
                supertype of <tt class="classname">Set&lt;Address&gt;</tt></td></tr><tr><td align="center"><tt class="code">@Size SortedSet&lt;Address&gt; getAddresses() {
                ... }</tt></td><td><tt class="classname">SizeValidatorForSet</tt>:
                <tt class="classname">Set</tt> is the closest supertype of
                <tt class="classname">SortedSet&lt;Address&gt;</tt></td></tr><tr><td align="center"><tt class="code">@Size SerializableCollection getAddresses() { ...
                }</tt></td><td><tt class="classname">UnexpectedTypeException</tt>:
                <tt class="classname">SerializableCollection</tt> is a subtype of
                both <tt class="classname">Collection</tt> and
                <tt class="classname">Serializable</tt> and neither
                <tt class="classname">Collection</tt> nor
                <tt class="classname">Serializable</tt> are subtypes of each
                other.</td></tr><tr><td align="center"><tt class="code">@Size String getName() { ... }</tt></td><td><tt class="classname">UnexpectedTypeException</tt>: none of
                the <tt class="classname">ConstraintValidator</tt> types are
                supertypes of <tt class="classname">String</tt>.</td></tr></tbody></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2749"></a>3.6.&nbsp;Examples</h2></div></div><div></div></div><p>The first example demonstrates how beans, fields and getters are
      annotated to express some constraints.</p><div class="example"><a name="d0e2754"></a><p class="title"><b>Example&nbsp;3.16.&nbsp;Place constraint declarations on the element to
        validate</b></p><pre class="programlisting">@ZipCodeCityCoherenceChecker
public class Address {
    @NotNull @Size(max=30)
    private String addressline1;

    @Size(max=30)
    private String addressline2;

    private String zipCode;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}</pre></div><p>During the validation routine execution on an
      <tt class="classname">Address</tt> object,</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">addressline1</tt> field value is passed to
          the <tt class="classname">@NotNull</tt> as well as
          <tt class="classname">@Size</tt> constraint validation
          implementation.</p></li><li><p><tt class="methodname">addressline2</tt> field value is passed to
          the <tt class="classname">@Size</tt> constraint validation
          implementation.</p></li><li><p><tt class="methodname">getCity</tt> value is passed to the
          <tt class="classname">@Size</tt> and <tt class="classname">@NotNull</tt>
          constraint validation implementations</p></li><li><p><tt class="classname">@ZipCodeCoherenceChecker</tt> is a
          constraint whose validation implementation's
          <tt class="methodname">isValid</tt> method receives the
          <tt class="classname">Address</tt> object</p></li></ul></div><p>The second example demonstrates object graph validation</p><div class="example"><a name="d0e2808"></a><p class="title"><b>Example&nbsp;3.17.&nbsp;Define object graph validation</b></p><pre class="programlisting">public class Country {
    @NotNull
    private String name;
    @Size(max=2) private String ISO2Code;
    @Size(max=3) private String ISO3Code;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getISO2Code() {
        return ISO2Code;
    }

    public void setISO2Code(String ISO2Code) {
        this.ISO2Code = ISO2Code;
    }

    public String getISO3Code() {
        return ISO3Code;
    }

    public void setISO3Code(String ISO3Code) {
        this.ISO3Code = ISO3Code;
    }
}

public class Address {
    @NotNull @Size(max=30)
    private String addressline1;
    @Size(max=30)
    private String addressline2;
    @Size(max=11)
    private String zipCode;
    <span class="bold"><b>@NotNull @Valid</b></span>
    private Country country;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    @Size(max=30) @NotNull
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public Country getCountry() {
        return country;
    }

    public void setCountry(Country country) {
        this.country = country;
    }
}</pre></div><p>During the validation routine execution on an
      <tt class="classname">Address</tt> object, constraints on
      <tt class="methodname">addressLine1</tt>,
      <tt class="methodname">addressLine2</tt>, <tt class="methodname">zipCode</tt>,
      <tt class="classname">getCity</tt> and <tt class="methodname">country</tt> are
      processed as well as the validation of the
      <tt class="classname">Country</tt> object itself, more specifically
      <tt class="methodname">country.name</tt> is checked for
      <tt class="classname">@NotNull</tt>, <tt class="methodname">ISO2Code</tt> and
      <tt class="methodname">ISO3Code</tt> are checked for
      <tt class="classname">@Size</tt>.</p><p>Assuming that <tt class="classname">@NotEmpty</tt> is defined as
      such</p><pre class="programlisting">package com.acme.constraint;

@Documented
@NotNull
@Size(min=1)
@ReportAsSingleViolation
@Constraint(validatedBy = NotEmpty.NotEmptyValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface NotEmpty {
    String message() default "{com.acme.constraint.NotEmpty.message}"
    Class&lt;?&gt; groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        NotEmpty[] value();
    }    

    class NotEmptyValidator implements ConstraintValidator&lt;NotEmpty, String&gt; {
        public void initialize(NotEmpty constraintAnnotation) {}

        public boolean isValid(String value, ConstraintValidatorContext context) {
            return true;
        }
    }
}</pre><p>The third example demonstrates superclass, inheritance and
      composite constraints.</p><div class="example"><a name="d0e2863"></a><p class="title"><b>Example&nbsp;3.18.&nbsp;Use inheritance, constraints on superclasses and composite
        constraints</b></p><pre class="programlisting">public interface Person {
    @NotEmpty
    String getFirstName();

    String getMiddleName();
    
    @NotEmpty
    String getLastName();
}

public class Customer implements Person {
    private String firstName;
    private String middleName;
    private String lastName;
    @NotNull
    private String customerId;
    @Password(robustness=5)
    private String password;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getMiddleName() {
        return middleName;
    }

    public void setMiddleName(String middleName) {
        this.middleName = middleName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCustomerId() {
        return customerId;
    }

    public void setCustomerId(String customerId) {
        this.customerId = customerId;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

public class PreferredGuest extends Customer {
    @CreditCard
    private String guestCreditCardNumber;

    public String getGuestCreditCardNumber() {
        return guestCreditCardNumber;
    }

    public void setGuestCreditCardNumber(String guestCreditCardNumber) {
        this.guestCreditCardNumber = guestCreditCardNumber;
    }
}

public class CommonGuest extends customer {}</pre></div><p>When validating a <tt class="classname">PreferredGuest</tt> the
      following constraints are processed:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">@NotEmpty</tt>,
          <tt class="classname">@NotNull</tt> and
          <tt class="classname">@Size(min=1)</tt> on
          <tt class="methodname">firstName</tt></p></li><li><p><tt class="classname">@NotEmpty</tt>,
          <tt class="classname">@NotNull</tt> and
          <tt class="classname">@Size(min=1)</tt> on
          <tt class="methodname">lastName</tt></p></li><li><p><tt class="classname">@NotNull</tt> on
          <tt class="methodname">customerId</tt>,
          <tt class="classname">@Password</tt> on
          <tt class="methodname">password</tt></p></li><li><p><tt class="classname">@CreditCard</tt> on
          <tt class="methodname">guestCreditCardNumber</tt></p></li></ul></div><p>When validating <tt class="classname">CommonGuest</tt>, the following
      constraints are processed:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">@NotEmpty</tt>,
          <tt class="classname">@NotNull</tt> and
          <tt class="classname">@Size(min=1)</tt> on
          <tt class="methodname">firstName</tt></p></li><li><p><tt class="classname">@NotEmpty</tt>,
          <tt class="classname">@NotNull</tt> and
          <tt class="classname">@Size(min=1)</tt> on
          <tt class="methodname">lastName</tt></p></li><li><p><tt class="classname">@NotNull</tt> on
          <tt class="methodname">customerId</tt>,
          <tt class="classname">@Password</tt> on
          <tt class="methodname">password</tt></p></li></ul></div><p>The fourth example demonstrates the influence of group
      sequence.</p><div class="example"><a name="d0e2967"></a><p class="title"><b>Example&nbsp;3.19.&nbsp;Use groups and group sequence to define constraint
        ordering</b></p><pre class="programlisting"><span class="bold"><b>@GroupSequence({First.class, Second.class, Last.class})</b></span>
public interface Complete {}

public class Book {
    @NotEmpty(groups=First.class)
    private String title;

    @Size(max=30, groups=Second.class)
    private String subtitle;

    @Valid
    @NotNull(groups=First.class)
    private Author author;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getSubtitle() {
        return subtitle;
    }

    public void setSubtitle(String subtitle) {
        this.subtitle = subtitle;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }
}

public class Author {
    @NotEmpty(groups=Last.class)
    private String firstName;
    
    @NotEmpty(groups=First.class)
    private String lastName;

    @Size(max=30, groups=Last.class)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}</pre></div><p>Assuming the validation of the <tt class="classname">Complete</tt>
      group on the following book instance:</p><pre class="programlisting">Author author = new Author();
author.setLastName( "Baudelaire" );
author.setFirstName( "" );
Book book = new Book();
book.setAuthor( author );</pre><p>the validation routine will return the following failure:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">@NotNull</tt> failure (from
          <tt class="classname">@NotEmpty</tt>) on the <tt class="literal">title</tt>
          field</p></li></ul></div><p>As both <tt class="methodname">title</tt> and
      <tt class="methodname">author.lastname</tt> are checked as part of the
      <tt class="literal"><tt class="classname">First</tt></tt> group. If the instance
      is updated:</p><pre class="programlisting">book.setTitle( "Les fleurs du mal" );
author.setCompany("Some random publisher with a very very very long name");</pre><p>the validation routine will return the following failures:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">author.firstName</tt> fails to pass the
          <tt class="classname">@Size(min=1)</tt> (from
          <tt class="classname">@NotEmpty</tt>) constraint</p></li><li><p><tt class="methodname">author.company</tt> fails to pass the
          <tt class="classname">@Size</tt> constraint</p></li></ul></div><p>As the <tt class="classname">First</tt> and
      <tt class="classname">Second</tt> groups pass without failure, the
      <tt class="classname">Last</tt> group is going through validation.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="validationapi"></a>Chapter&nbsp;4.&nbsp;Validation APIs</h2></div></div><div></div></div><p>The default package for the Bean Validation APIs is
    <tt class="classname">javax.validation</tt></p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validationapi-validatorapi"></a>4.1.&nbsp;Validator API</h2></div></div><div></div></div><p>The main Bean Validation API is the
      <tt class="classname">javax.validation.Validator</tt> interface.</p><p>A <tt class="classname">Validator</tt> instance is able to validate
      instances of beans and their associated objects if any. It is
      recommended to leave the caching of <tt class="classname">Validator</tt>
      instances to the <tt class="classname">ValidatorFactory</tt>.
      <tt class="classname">Validator</tt> implementations are thread-safe.</p><pre class="programlisting">/**
 * Validate bean instances. Implementations of this interface must be thread-safe.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface Validator {
    /**
     * Validates all constraints on &lt;code&gt;object&lt;/code&gt;.
     *
     * @param object object to validate
     * @param groups group or list of groups targeted for validation
     *               (default to {@link javax.validation.groups.Default})
     *
     * @return constraint violations or an empty Set if none
     *
     * @throws IllegalArgumentException if object is null
     *                                  or if null is passed to the varargs groups
     * @throws ValidationException if a non recoverable error happens
     *                                  during the validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T object, Class&lt;?&gt;... groups);

    /**
     * Validates all constraints placed on the property of &lt;code&gt;object&lt;/code&gt;
     * named &lt;code&gt;propertyName&lt;/code&gt;.
     *
     * @param object object to validate
     * @param propertyName property to validate (ie field and getter constraints)
     * @param groups group or list of groups targeted for validation
     *               (default to {@link javax.validation.groups.Default})
     *
     * @return constraint violations or an empty Set if none
     *
     * @throws IllegalArgumentException if &lt;code&gt;object&lt;/code&gt; is null,
     *            if &lt;code&gt;propertyName&lt;/code&gt; null, empty or not a valid object property
     *            or if null is passed to the varargs groups
     * @throws ValidationException      if a non recoverable error happens
     *                                  during the validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateProperty(T object,
                                                     String propertyName,
                                                     Class&lt;?&gt;... groups);

    /**
     * Validates all constraints placed on the property named &lt;code&gt;propertyName&lt;/code&gt;
     * of the class &lt;code&gt;beanType&lt;/code&gt; would the property value be &lt;code&gt;value&lt;/code&gt;
     * &lt;p/&gt;
     * &lt;code&gt;ConstraintViolation&lt;/code&gt; objects return null for
     * {@link ConstraintViolation#getRootBean()} and {@link ConstraintViolation#getLeafBean()}
     *
     * @param beanType the bean type
     * @param propertyName property to validate
     * @param value property value to validate
     * @param groups group or list of groups targeted for validation
     *               (default to {@link javax.validation.groups.Default})
     *
     * @return constraint violations or an empty Set if none
     *
     * @throws IllegalArgumentException if &lt;code&gt;beanType&lt;/code&gt; is null,
     *            if &lt;code&gt;propertyName&lt;/code&gt; null, empty or not a valid object property
     *            or if null is passed to the varargs groups
     * @throws ValidationException      if a non recoverable error happens
     *                                  during the validation process
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue(Class&lt;T&gt; beanType,
                                                  String propertyName,
                                                  Object value,
                                                  Class&lt;?&gt;... groups);

    /**
     * Return the descriptor object describing bean constraints.
     * The returned object (and associated objects including
     * &lt;code&gt;ConstraintDescriptor&lt;code&gt;s) are immutable.
     *
     * @param clazz class or interface type evaluated
     *
     * @return the bean descriptor for the specified class.
     *
     * @throws IllegalArgumentException if clazz is null
     * @throws ValidationException if a non recoverable error happens
     *                             during the metadata discovery or if some
     *                             constraints are invalid.
     */
    BeanDescriptor getConstraintsForClass(Class&lt;?&gt; clazz);

    /**
     * Return an instance of the specified type allowing access to
     * provider-specific APIs.  If the Bean Validation provider
     * implementation does not support the specified class,
     * &lt;code&gt;ValidationException&lt;/code&gt; is thrown.
     *
     * @param type the class of the object to be returned.
     *
     * @return an instance of the specified class
     *
     * @throws ValidationException if the provider does not support the call.
     */
    public &lt;T&gt; T unwrap(Class&lt;T&gt; type);
}</pre><p><tt class="methodname">getConstraintsForClass</tt> is described in
      <a href="#constraintmetadata" title="Chapter&nbsp;5.&nbsp;Constraint metadata request APIs">Chapter&nbsp;5, <i>Constraint metadata request APIs</i></a>.</p><p><tt class="methodname">unwrap</tt> is provided as a way to access
      objects of a given type specific to a Bean Validation provider typically
      as a complement to the <tt class="classname">Validator</tt> contract. Using
      this method makes your code non portable.</p><div class="example"><a name="d0e3086"></a><p class="title"><b>Example&nbsp;4.1.&nbsp;Using unwrap to access a provider specific contract</b></p><pre class="programlisting">//if using the ACME provider
ACMEValidator acmeValidator = factory.unwrap(ACMEValidator.class);
acmeValidator.setSpecificConfiguration(...);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="validationapi-validatorapi-validationmethods"></a>4.1.1.&nbsp;Validation methods</h3></div></div><div></div></div><p><tt class="methodname">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
        validate(T object, Class&lt;?&gt;... groups)</tt> is used to
        validate a given object. This method implements the logic described in
        <a href="#constraintdeclarationvalidationprocess-validationroutine" title="3.5.&nbsp;Validation routine">Section&nbsp;3.5, &#8220;Validation routine&#8221;</a>.
        A <tt class="classname">Set</tt> containing all
        <tt class="classname">ConstraintViolation</tt> objects representing the
        failing constraints is returned, an empty <tt class="classname">Set</tt>
        is returned otherwise.</p><p><tt class="methodname">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
        validateProperty(T object, String propertyName, Class&lt;?&gt;...
        groups)</tt> validates a given field or property of an object.
        The property name is the JavaBeans property name (as defined by the
        JavaBeans <tt class="classname">Introspector</tt> class). This method
        implements the logic described in <a href="#constraintdeclarationvalidationprocess-validationroutine" title="3.5.&nbsp;Validation routine">Section&nbsp;3.5, &#8220;Validation routine&#8221;</a>
        but only to the given property. <tt class="literal">@Valid</tt> is not
        honored by this method. This method is useful for partial object
        validation.</p><p><tt class="methodname">&lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt;
        validateValue(Class&lt;T&gt; beanType, String propertyName, Object
        value, Class&lt;?&gt;... groups)</tt> validates the property
        referenced by <i class="parameter"><tt>propertyName</tt></i> present on
        <tt class="literal">beanType</tt> or any of its superclasses, if the
        property value were <i class="parameter"><tt>value</tt></i>. This method
        implements the logic described in <a href="#constraintdeclarationvalidationprocess-validationroutine" title="3.5.&nbsp;Validation routine">Section&nbsp;3.5, &#8220;Validation routine&#8221;</a>
        and apply it only to the given property and for the given value.
        <tt class="literal">@Valid</tt> is not honored by this method. This method
        is useful for ahead of time validation (i.e. before the JavaBean is
        populated or updated).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If multiple constrained fields or getters share the same name
          and hide one another in the class hierarchy according to the Java
          visibility rules, the list of constraints evaluated is unspecified.
          This will be clarified in a later version of this specification.
          Note that method overriding is not impacted.</p><p>If getters and fields share the same name and are present at
          different levels of the hierarchy, the list of constraints evaluated
          is unspecified. This will be clarified in a later version of this
          specification.</p><p>However, constraints hosted on the most specific (hierarchy
          wise) element type are always evaluated.</p></div><p>If some unrecoverable failure happens during validation, a
        <tt class="classname">ValidationException</tt> is raised. This exception
        can be specialized in some situations (invalid group definition,
        invalid constraint definition, invalid constraint declaration). See
        <a href="#exception" title="Chapter&nbsp;8.&nbsp;Exception model">Chapter&nbsp;8, <i>Exception model</i></a> or the relative sections for more
        information).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3153"></a>4.1.1.1.&nbsp;Examples</h4></div></div><div></div></div><p>All the examples will be based on the following class
          definition, constraint declarations and address instance.</p><pre class="programlisting">public class Address {
    <span class="bold"><b>@NotNull @Size(max=30)</b></span>
    private String addressline1;

    <span class="bold"><b>@Size(max=30)</b></span>
    private String addressline2;

    private String zipCode;

    private String city;

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    <span class="bold"><b>@Size(max=30) @NotNull</b></span>
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}

Address address = new Address();
address.setAddressline1( null );
address.setAddressline2( null );
address.setCity("Llanfairpwllgwyngyllgogerychwyrndrobwyll-llantysiliogogogoch");
//town in North Wales</pre><p>The following code will return two
          <tt class="classname">ConstraintViolation</tt> objects. One for
          <tt class="literal">addressline1</tt> violating
          <tt class="literal">@NotNull</tt> and one for <tt class="literal">city</tt>
          violating <tt class="literal">@Size</tt>.</p><pre class="programlisting">validator.validate(address).size() == 2</pre><p>The following code will return one
          <tt class="classname">ConstraintViolation</tt> since
          <tt class="literal">city</tt> violates <tt class="literal">@Size</tt> and only
          <tt class="literal">city</tt> is validated.</p><pre class="programlisting">validator.validateProperty(address, "city").size() == 1</pre><p>The following code will return no
          <tt class="classname">ConstraintViolation</tt> object because the value
          "Paris" for <tt class="literal">city</tt> would not raise any constraint
          failure.</p><pre class="programlisting">validator.validateValue("city", "Paris").size() == 0</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="validationapi-validatorapi-groups"></a>4.1.2.&nbsp;groups</h3></div></div><div></div></div><p>Groups allow you to restrict the set of constraints applied
        during validation. Groups targeted are passed as parameters to the
        <tt class="methodname">validate</tt>,
        <tt class="methodname">validateProperty</tt> and
        <tt class="methodname">validateValue</tt> methods. All constraints
        belonging to the targeted group are applied during the <a href="#constraintdeclarationvalidationprocess-validationroutine" title="3.5.&nbsp;Validation routine">Section&nbsp;3.5, &#8220;Validation routine&#8221;</a>.
        If no group is passed, the
        <tt class="literal"><tt class="classname">Default</tt></tt> group is assumed.
        <a href="#constraintsdefinitionimplementation-constraintdefinition-groups" title="2.1.1.2.&nbsp;groups">Section&nbsp;2.1.1.2, &#8220;groups&#8221;</a>
        describes how to define groups on constraints.</p><p>When more than one group is evaluated and passed to the various
        validate methods, order is not constrained. It is equivalent to the
        validation of a group <tt class="literal">G</tt> inheriting all groups (i.e.
        implementing all interfaces) passed to the validation method.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3241"></a>4.1.2.1.&nbsp;Examples</h4></div></div><div></div></div><pre class="programlisting">/** Validates a minimal set of constraints */
public interface Minimal {}

public class Address {

    @NotEmpty(groups = Minimal.class)
    @Size(max=50)
    private String street1;
    
    @NotEmpty
    private String city;

    @NotEmpty(groups = {Minimal.class, Default.class})
    private String zipCode;
    ...
}</pre><p>In the previous example, <tt class="classname">@NotEmpty</tt> (and
          it's composing constraints) on <tt class="methodname">street1</tt>
          applies to the group <tt class="classname">Minimal</tt>,
          <tt class="classname">@Size</tt> on <tt class="methodname">street1</tt>
          applies to the group <tt class="literal">Default</tt> and
          <tt class="classname">@NotEmpty </tt>(and it's composing constraints) on
          <tt class="methodname">zipCode</tt> applies to the groups
          <tt class="literal"><tt class="classname">Default</tt></tt> and
          <tt class="literal"><tt class="classname">Minimal</tt></tt>.</p><pre class="programlisting">validator.validate(address);</pre><p>validates the group <tt class="classname">Default</tt>
          (implicitly) and applies <tt class="classname">@Size</tt> on
          <tt class="methodname">street1</tt>, <tt class="classname">@NotEmpty</tt>
          (and its composing constraints) on <tt class="methodname">city</tt>,
          <tt class="classname">@NotEmpty</tt> (and its composing constraints) on
          <tt class="methodname">zipCode</tt>. Particularly,
          <tt class="classname">@NotEmpty</tt> (and its composing constraints) on
          <tt class="methodname">street1</tt> are not applied.</p><pre class="programlisting">validator.validate(address, Minimal.class);</pre><p>applies <tt class="classname">@NotEmpty</tt> (and its composing
          constraints) on <tt class="methodname">street1</tt> and
          <tt class="classname">@NotEmpty</tt> (and its composing constraints) on
          <tt class="methodname">zipCode</tt> because they belong to the
          <tt class="classname">Minimal</tt> group.</p><pre class="programlisting">validator.validate(address, Minimal.class, Default.class);</pre><p>validates both <tt class="classname">Default</tt> and
          <tt class="classname">Minimal</tt> groups. The routine applies
          <tt class="classname">@NotEmpty</tt> (and its composing constraints) and
          <tt class="classname">@Size</tt> on <tt class="methodname">street1</tt>,
          <tt class="classname">@NotEmpty</tt> (and its composing constraints) on
          <tt class="methodname">city</tt>, <tt class="classname">@NotEmpty</tt> (and
          its composing constraints) on <tt class="methodname">zipCode</tt>. Note
          that if <tt class="methodname">zipCode</tt> is empty, only one
          <tt class="classname">ConstraintViolation</tt> object will represent the
          failure and the not empty validation will only be executed
          once.</p><p>Let's look at a more complex example involving group
          sequence.</p><pre class="programlisting">public class Address {
    @NotEmpty(groups = Minimal.class)
    @Size(max=50, groups=FirstStep.class)
    private String street1;
    
    @NotEmpty(groups=SecondStep.class)
    private String city;

    @NotEmpty(groups = {Minimal.class, SecondStep.class})
    private String zipCode;
    ...

    public interface FirstStep {}

    public interface SecondStep {}
    
    @GroupSequence({Firststep.class, SecondStep.class})
    public interface Total {}
}</pre><p>When running:</p><pre class="programlisting">validator.validate(address, Minimal.class, Total.class);</pre><p>the validation process will process
          <tt class="classname">@NotEmpty</tt> (and it's composing constraints)
          and <tt class="classname">@Size</tt> from
          <tt class="methodname">street1</tt> and
          <tt class="classname">@NotEmpty</tt> (and it's composing constraints)
          from <tt class="methodname">zipCode</tt>. If
          <tt class="classname">@Size</tt> from <tt class="methodname">street1</tt>
          does not generate a failure, then <tt class="classname">@NotEmpty</tt>
          (and it's composing constraints) from <tt class="methodname">city</tt>
          will be processed as part of <tt class="classname">SecondStep</tt>. Note
          that <tt class="classname">@NotEmpty</tt> (and it's composing
          constraints) from <tt class="methodname">zipCode</tt> are not
          reprocessed as they have already been processed before.</p><p>When running:</p><pre class="programlisting">validator.validate(address, Total.class, SecondStep.class);</pre><p><tt class="classname">@NotEmpty</tt> (and it's composing
          constraints) from <tt class="methodname">city</tt> and
          <tt class="classname">@NotEmpty</tt> (and it's composing constraints)
          from <tt class="methodname">zipCode</tt> will be processed even if
          <tt class="classname">@Size</tt> from <tt class="methodname">street1</tt>
          fails: while <tt class="literal"><tt class="classname">SecondStep</tt></tt> is
          in the <tt class="literal"><tt class="classname">Total</tt></tt> group
          sequence and hence should not be triggered if
          <tt class="literal"><tt class="classname">FirstStep</tt></tt> has a failure,
          it also has been requested outside the sequence (in this case
          explicitly).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If the group definition is invalid, a
            <tt class="classname">GroupDefinitionException</tt> is raised.</p></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validationapi-constraintviolation"></a>4.2.&nbsp;ConstraintViolation</h2></div></div><div></div></div><p><tt class="classname">ConstraintViolation</tt> is the class describing
      a single constraint failure. A set of
      <tt class="classname">ConstraintViolation</tt> is returned for an object
      validation.</p><pre class="programlisting">/**
 * Describe a constraint violation. This object exposes the constraint
 * violation context as well as the message describing the violation.
 *
 * @author Emmanuel Bernard
 */
public interface ConstraintViolation&lt;T&gt; {

    /**
     * @return The interpolated error message for this constraint violation.
     */
    String getMessage();

    /**
     * @return The non-interpolated error message for this constraint violation.
     */
    String getMessageTemplate();

    /**
     * @return The root bean being validated. Null when returned by
     *         {@link javax.validation.Validator#validateValue(Class, String, Object, Class[])}
     */
    T getRootBean();

    /**
     * @return The class of the root bean being validated
     */
    Class&lt;T&gt; getRootBeanClass();

    /**
     * If a bean constraint, the bean instance the constraint is applied on
     * If a property constraint, the bean instance hosting the property the
     * constraint is applied on
     *
     * @return the leaf bean the constraint is applied on. Null when returned by
     *         {@link javax.validation.Validator#validateValue(Class, String, Object, Class[])}
     */
    Object getLeafBean();

    /**
     * @return the property path to the value from {@code rootBean}.
     */
    Path getPropertyPath();

    /**
     * @return the value failing to pass the constraint.
     */
    Object getInvalidValue();

    /**
     * Constraint metadata reported to fail.
     * The returned instance is immutable.
     *
     * @return constraint metadata
     */
    ConstraintDescriptor&lt;?&gt; getConstraintDescriptor();
}</pre><p>The <tt class="methodname">getMessage</tt> method returns the
      interpolated (localized) message for the failing constraint (see <a href="#validationapi-message" title="4.3.&nbsp;Message interpolation">Section&nbsp;4.3, &#8220;Message interpolation&#8221;</a> for more information on message
      interpolator). This can be used by clients to expose user friendly
      messages.</p><p>The <tt class="methodname">getMessageTemplate</tt> method returns the
      non-interpolated error message (usually the <tt class="literal">message</tt>
      attribute on the constraint declaration). Frameworks can use this as an
      error code key.</p><p>The <tt class="methodname">getRootBean</tt> method returns the root
      object being validated that led to the failing constraint (i.e. the
      object the client code passes to the
      <tt class="methodname">Validator.validate</tt> method.</p><p>The <tt class="methodname">getInvalidValue</tt> method returns the
      value (field, property or validated object) being passed to
      <tt class="methodname">isValid</tt>.</p><p><tt class="methodname">getConstraintDescriptor</tt> provides access
      to the failing constraint metadata (see <a href="#constraintmetadata-constraintdescriptor" title="5.5.&nbsp;ConstraintDescriptor">Section&nbsp;5.5, &#8220;ConstraintDescriptor&#8221;</a>).</p><p>The <tt class="methodname">getPropertyPath</tt> returns the Path
      object representing the navigation path from the root object to the
      failing object.</p><pre class="programlisting">/**
 * Represent the navigation path from an object to another
 * in an object graph.
 * Each path element is represented by a &lt;code&gt;Node&lt;/code&gt;.
 *
 * The path corresponds to the succession of nodes
 * in the order they are returned by the &lt;code&gt;Iterator&lt;/code&gt;
 *
 * @author Emmanuel Bernard
 */
public interface Path extends Iterable&lt;Path.Node&gt; {

    /**
     * Represents an element of a navigation path
     */
    interface Node {
        /**
         * Property name the node represents
         * or null if representing an entity on the leaf node
         * (in particular the node in a &lt;code&gt;Path&lt;/code&gt; representing
         * the root object has its name null).
         * 
         * @return property name the node represents
         */
        String getName();

        /**
         * @return true if the node represents an object contained in an Iterable
         * or in a Map.
         */
        boolean isInIterable();

        /**
         * @return The index the node is placed in if contained
         * in an array or List. Null otherwise.
         */
        Integer getIndex();

        /**
         * @return The key the node is placed in if contained
         * in a Map. Null otherwise.
         */
        Object getKey();
    }
}</pre><p><tt class="classname">Path</tt> is made of
      <tt class="classname">Node</tt>s and is built according to the following
      rules:</p><div class="itemizedlist"><ul type="disc"><li><p>if the failing object is the root object, a
          <tt class="classname">Node</tt> with name set to null is added to the
          <tt class="classname">Path</tt>.</p></li><li><p>When an association is traversed:</p><div class="itemizedlist"><ul type="circle"><li><p>a <tt class="classname">Node</tt> object whose
              <tt class="literal">name</tt> equals the name of the association
              property (field name or Java Bean property name) is added to
              <tt class="classname">Path</tt></p></li><li><p>if the association is a <tt class="classname">List</tt> or an
              array, the following <tt class="classname">Node</tt> object added
              contains the index value in
              <tt class="methodname">getIndex</tt>.</p></li><li><p>if the association is a <tt class="classname">Map</tt>, the
              following <tt class="classname">Node</tt> object added (representing
              a given map entry) contains the key value in
              <tt class="methodname">getKey</tt></p></li><li><p>for all <tt class="classname">Iterable</tt> or
              <tt class="classname">Map</tt>, the following
              <tt class="classname">Node</tt> object added is marked as
              <tt class="literal">inIterable</tt>
              (<tt class="methodname">isInIterable</tt>)</p></li></ul></div></li><li><p>For a property level constraint (field and getter)</p><div class="itemizedlist"><ul type="circle"><li><p>a <tt class="classname">Node</tt> object is added to
              <tt class="classname">Path</tt> whose <tt class="literal">name</tt> equals
              the name of the property (field name or Java Bean property
              name)</p></li><li><p>the property path is considered complete</p></li></ul></div></li><li><p>For a class level constraint:</p><div class="itemizedlist"><ul type="circle"><li><p>a <tt class="classname">Node</tt> object is added to
              <tt class="classname">Path</tt> whose <tt class="literal">name</tt> is
              null</p></li><li><p>the property path is considered complete</p></li></ul></div></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A given <tt class="classname">Node</tt> object derives its
        <tt class="literal">inIterable</tt>, <tt class="literal">key</tt> and
        <tt class="literal">index</tt> properties from the previous association
        traversed.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>From <tt class="methodname">rootBean</tt> and
        <tt class="methodname">propertyPath</tt>, it is possible to rebuild the
        context of the failure</p></div><p>Assuming the following object definitions and when book is
      validated:</p><pre class="programlisting">@SecurityChecking
public class Author {
    private String firstName;
    
    @NotEmpty(message="lastname must not be null")
    private String lastName;

    @Size(max=30)
    private String company;
    ...
}

@AvailableInStore(groups={Availability.class})
public class Book {
    @NotEmpty(groups={FirstLevelCheck.class, Default.class})
    private String title;

    @Valid
    @NotNull
    private List&lt;Author&gt; authors;

    @Valid
    private Map&lt;String, Review&gt; reviewsPerSource;

    @Valid
    private Review pickedReview;
    ...
}

public class Review {
    @Min(0) private int rating;
    ...
}</pre><p><tt class="literal">propertyPath</tt> evaluations are described in <a href="#table-propertypath" title="Table&nbsp;4.1.&nbsp;propertyPath examples">Table&nbsp;4.1, &#8220;propertyPath examples&#8221;</a>:</p><div class="table"><a name="table-propertypath"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;propertyPath examples</b></p><table summary="propertyPath examples" border="1"><colgroup><col><col></colgroup><thead><tr><th>Constraint</th><th>propertyPath</th></tr></thead><tbody><tr><td><tt class="classname">@AvailableInStore</tt> on
              <tt class="classname">Book</tt></td><td><p>Node(name=null,inIterable=false, index=null,
              key=null)</p></td></tr><tr><td><tt class="classname">@NotEmpty</tt> on
              <tt class="classname">Book.title</tt></td><td><p>Node(name=title,inIterable=false, index=null,
              key=null)</p></td></tr><tr><td><tt class="classname">@NotNull</tt> on
              <tt class="classname">Book.authors</tt></td><td><p>Node(name=authors,inIterable=false, index=null,
              key=null)</p></td></tr><tr><td><tt class="classname">@SecurityChecking</tt> on the fourth
              author, <tt class="classname">Author</tt></td><td><p>Node(name=authors,inIterable=false, index=null,
              key=null)</p><p>Node(name=null,inIterable=true, index=3,
              key=null)</p></td></tr><tr><td><tt class="classname">@Size</tt> on the fourth author,
              <tt class="classname">Author.lastname</tt></td><td><p>Node(name=authors,inIterable=false, index=null,
              key=null)</p><p>Node(name=lastname,inIterable=true,
              index=4, key=null)</p></td></tr><tr><td><tt class="classname">@NotEmpty</tt> on the first author,
              <tt class="classname">Author.company</tt></td><td><p>Node(name=authors,inIterable=false, index=null,
              key=null)</p><p>Node(name=company,inIterable=true,
              index=0, key=null)</p></td></tr><tr><td><tt class="classname">@Min</tt> on the review associated to
              Consumer Report, <tt class="classname">Review.rating</tt></td><td><p>Node(name=reviewsPerSource,inIterable=false,
              index=null,
              key=null)</p><p>Node(name=rating,inIterable=true,
              index=null, key="Consumer Report")</p></td></tr><tr><td><tt class="classname">@Min</tt> on the picked review,
              <tt class="classname">Review.rating</tt></td><td><p>Node(name=pickedReview,inIterable=false,
              index=null,
              key=null)</p><p>Node(name=rating,inIterable=false,
              index=null, key=null)</p></td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Bean Validation implementations should ensure that a
        <tt class="classname">ConstraintViolation</tt> implementation is
        <tt class="classname">Serializable</tt> provided that the root bean, the
        leaf bean, the invalid value and keys in the
        <tt class="classname">Path</tt> object are
        <tt class="classname">Serializable</tt> objects.</p><p>If a user wishes to send
        <tt class="classname">ConstraintViolation</tt> remotely, it should make
        sure the object graph validated is itself
        <tt class="classname">Serializable</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3779"></a>4.2.1.&nbsp;Examples</h3></div></div><div></div></div><p>These examples assume the following definition of
        <tt class="classname">@NotEmpty</tt>.</p><pre class="programlisting">package com.acme.constraint;

@Documented
@NotNull
@Size(min=1)
@ReportAsSingleViolation
@Constraint(validatedBy = NotEmpty.NotEmptyValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface NotEmpty {
    String message() default "{com.acme.constraint.NotEmpty.message}"
    Class&lt;?&gt; groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        NotEmpty[] value();
    }

    class NotEmptyValidator implements ConstraintValidator&lt;NotEmpty, String&gt; {
        public void initialize(NotEmpty constraintAnnotation) {}

        public boolean isValid(String value, ConstraintValidatorContext context) {
            return true;
        }
    }
}</pre><p>and the following class definitions</p><pre class="programlisting">public class Author {
    private String firstName;
    
    @NotEmpty(message="lastname must not be null")
    private String lastName;

    @Size(max=30)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}

public class Book {
    @NotEmpty(groups={FirstLevelCheck.class, Default.class})
    private String title;

    @Valid
    @NotNull
    private Author author;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }
}

Author author = new Author();
author.setCompany("ACME");
Book book = new Book();
book.setTitle("");
book.setAuthor(author);

Set&lt;ConstraintViolation&gt; constraintViolations = validator.validate(book);</pre><p><tt class="classname">ConstraintViolations</tt> is a set of size 2.
        One of the entries represents the failure of
        <tt class="literal">@NotEmpty</tt> (or more precisely
        <tt class="classname">@Size(min=1)</tt> a composing constraint of
        <tt class="classname">@NotEmpty</tt>) on the <tt class="literal">title</tt>
        property.</p><p>The <tt class="classname">ConstraintViolation</tt> object for this
        failure passes the following assertions:</p><pre class="programlisting">//assuming an english locale, the interpolated message is returned
assert "may not be null or empty".equals( constraintViolation.getMessage() );
assert book == constraintViolation.getRootBean();
assert book == constraintViolation.getLeafBean();
//the offending value
assert book.getTitle().equals( constraintViolation.getInvalidValue() );
//the offending property
Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();
assert "title".equals( nodeIter.next().getName() );
assert false == nodeIter.hasNext();</pre><p>The second failure, <tt class="literal">@NotEmpty</tt> (or more
        precisely <tt class="classname">@NotNull</tt> a composing constraint of
        <tt class="classname">@NotEmpty</tt>) on the author's
        <tt class="methodname">lastname</tt>, will produce the
        <tt class="classname">ConstraintViolation</tt> object satisfying the
        following assertions:</p><pre class="programlisting">assert "lastname must not be null".equals( constraintViolation.getMessage() );
assert book == constraintViolation.getRootBean();
assert author == constraintViolation.getLeafBean();
//the offending value
assert book.getAuthor().getLastName() == constraintViolation.getInvalidValue();
//the offending property
Iterator&lt;Node&gt; nodeIter = constraintViolation.getPropertyPath().iterator();
assert "author".equals( nodeIter.next().getName() );
assert "lastName".equals( nodeIter.next().getName() );
assert false == nodeIter.hasNext();</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validationapi-message"></a>4.3.&nbsp;Message interpolation</h2></div></div><div></div></div><p>A message interpolator is responsible for transforming the message
      string from the constraint into a human readable error message.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="default-messageresolver"></a>4.3.1.&nbsp;Default message interpolation</h3></div></div><div></div></div><p>A conforming implementation includes a default message
        interpolator. This message interpolator shall use the algorithm
        defined here to interpolate message descriptors into human-readable
        messages.</p><p>Each constraint defines a message descriptor via its
        <tt class="methodname">message</tt> property. Every constraint definition
        shall define a default message descriptor for that constraint.
        Messages can be overridden at declaration time in constraints by
        setting the <tt class="methodname">message</tt> property on the
        constraint.</p><p>The message descriptor is a string literal and may contain one
        or more message parameters. Message parameters are string literals
        enclosed in braces. The following character escaping apply:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="code">\{</tt> is considered as the literal
            <tt class="literal">{</tt> instead of being considered as the beginning
            of a message parameter</p></li><li><p><tt class="code">\}</tt> is considered as the literal
            <tt class="literal">}</tt> instead of being considered as the end of a
            message parameter</p></li><li><p><tt class="code">\\</tt> is considered as the literal
            <tt class="literal">\</tt> instead of being considered as the escaping
            character</p></li></ul></div><p></p><div class="example"><a name="d0e3881"></a><p class="title"><b>Example&nbsp;4.2.&nbsp;Message using parameters</b></p><pre class="programlisting">Value must be between {min} and {max}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="default-resolution-algorithm"></a>4.3.1.1.&nbsp;Default message interpolation algorithm</h4></div></div><div></div></div><p>The default message interpolator uses the following
          steps:</p><div class="orderedlist"><ol type="1"><li><p>Message parameters are extracted from the message string
              and used as keys to search the
              <tt class="classname">ResourceBundle</tt> named
              <tt class="literal">ValidationMessages</tt> (often materialized as the
              property file
              <tt class="filename">/ValidationMessages.properties</tt> and its
              locale variations) using the defined locale (see below). If a
              property is found, the message parameter is replaced with the
              property value in the message string. Step 1 is applied
              recursively until no replacement is performed (i.e. a message
              parameter value can itself contain a message parameter).</p></li><li><p>Message parameters are extracted from the message string
              and used as keys to search the Bean Validation provider's
              built-in <tt class="classname">ResourceBundle</tt> using the defined
              locale (see below). If a property is found, the message
              parameter is replaced with the property value in the message
              string. Contrary to step 1, step 2 is not processed
              recursively.</p></li><li><p>If step 2 triggers a replacement, then step 1 is applied
              again. Otherwise step 4 is performed.</p></li><li><p>Message parameters are extracted from the message string.
              Those matching the name of an attribute of the constraint are
              replaced by the value of that attribute in the constraint
              declaration.</p></li></ol></div><p>The defined locale is as followed:</p><div class="itemizedlist"><ul type="disc"><li><p>if the locale is passed to the interpolator method
              i<tt class="methodname">nterpolate(String, Context, Locale)</tt>,
              this <tt class="classname">Locale</tt> instance is used.</p></li><li><p>otherwise, the default <tt class="classname">Locale</tt> as
              provided by <tt class="methodname">Locale.getDefault()</tt> is
              used.</p></li></ul></div><p>The proposed algorithm ensures that custom resource bundle
          always have priority over built-in resource bundle at all level of
          the recursive resolution. It also ensures that constraint
          declarations attributes values are not interpolated further.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-message-resolution"></a>4.3.2.&nbsp;Custom message interpolation</h3></div></div><div></div></div><p>A custom message interpolator may be provided (e.g., to
        interpolate contextual data, or to adjust the default
        <tt class="classname">Locale </tt>used). A message interpolator implements
        the <tt class="classname">MessageInterpolator</tt> interface.</p><pre class="programlisting">/**
 * Interpolate a given constraint violation message.
 * Implementations should be as tolerant as possible on syntax errors.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface MessageInterpolator {
    /**
     * Interpolate the message template based on the contraint validation context.
     * The locale is defaulted according to the &lt;code&gt;MessageInterpolator&lt;/code&gt;
     * implementation. See the implementation documentation for more detail.
     *
     * @param messageTemplate The message to interpolate.
     * @param context contextual information related to the interpolation
     *
     * @return Interpolated error message.
     */
    String interpolate(String messageTemplate, Context context);

    /**
     * Interpolate the message template based on the contraint validation context.
     * The &lt;code&gt;Locale&lt;/code&gt; used is provided as a parameter.
     *
     * @param messageTemplate The message to interpolate.
     * @param context contextual information related to the interpolation
     * @param locale the locale targeted for the message
     *
     * @return Interpolated error message.
     */
    String interpolate(String messageTemplate, Context context,  Locale locale);

    /**
     * Information related to the interpolation context
     */
    interface Context {
        /**
         * @return ConstraintDescriptor corresponding to the constraint being validated
         */
        ConstraintDescriptor&lt;?&gt; getConstraintDescriptor();

        /**
         * @return value being validated
         */
        Object getValidatedValue();
    }
}</pre><p><i class="parameter"><tt>messageTemplate</tt></i> is the value of the
        <tt class="literal">message</tt> attribute of the constraint declaration or
        provided to the <tt class="classname">ConstraintValidatorContext</tt>
        methods.</p><p>The <tt class="classname">Context</tt> object contains contextual
        information related to the interpolation.</p><p><i class="parameter"><tt>getConstraintDescriptor</tt></i> is the
        <tt class="classname">ConstraintDescriptor</tt> object representing the
        metadata of the failing constraint (see <a href="#constraintmetadata" title="Chapter&nbsp;5.&nbsp;Constraint metadata request APIs">Chapter&nbsp;5, <i>Constraint metadata request APIs</i></a>).</p><p><i class="parameter"><tt>getValidatedValue</tt></i> is the value being
        validated.</p><p><tt class="methodname">MessageInterpolator.interpolate(String,
        Context)</tt> is invoked for each constraint violation report
        generated. The default <tt class="classname">Locale</tt> is implementation
        specific.</p><p><tt class="methodname">MessageInterpolator.interpolate(String, Context,
        Locale)</tt> can be invoked by a wrapping
        <tt class="classname">MessageInterpolator</tt> to enforce a specific
        <tt class="classname">Locale</tt> value by bypassing or overriding the
        default <tt class="classname">Locale</tt> strategy (see <a href="#validationapi-message-examples-specificlocale" title="Example&nbsp;4.3.&nbsp;Use MessageInterpolator to use a specific Locale&#xA;          value">Example&nbsp;4.3, &#8220;Use MessageInterpolator to use a specific Locale
          value&#8221;</a>).</p><p>A message interpolator implementation shall be
        thread-safe.</p><p>The message interpolator is provided to the
        <tt class="classname">ValidatorFactory</tt> at construction time using
        <tt class="methodname">Configuration.messageInterpolator(MessageInterpolator)</tt>.
        This message interpolator is shared by all
        <tt class="classname">Validator</tt> objects generated by this
        <tt class="classname">ValidatorFactory</tt>.</p><p>It is possible to override the
        <tt class="classname">MessageInterpolator</tt> implementation for a given
        <tt class="classname">Validator</tt> instance by invoking
        <tt class="methodname">ValidatorFactory.usingContext().messageInterpolator(messageInterpolator).getValidator()</tt>.</p><p>It is recommended that
        <tt class="classname">MessageInterpolator</tt> implementations delegate
        final interpolation to the Bean Validation default
        <tt class="classname">MessageInterpolator</tt> to ensure standard Bean
        Validation interpolation rules are followed, The default
        implementation is accessible through
        <tt class="methodname">Configuration.getDefaultMessageInterpolator()</tt>.</p><p>If the interpolation process leads to an exception, the
        exception is wrapped into a
        <tt class="classname">ValidationException</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="validationapi-message-examples"></a>4.3.3.&nbsp;Examples</h3></div></div><div></div></div><p>These examples describe message interpolation based on the
        default message interpolator's built-in messages (see <a href="#standard-resolver-messages" title="Appendix&nbsp;B.&nbsp;Standard ResourceBundle messages">Appendix&nbsp;B, <i>Standard ResourceBundle messages</i></a>), and the
        <tt class="filename">ValidationMessages.properties</tt> file shown in table
        <a href="#table-messageinterpolation" title="Table&nbsp;4.2.&nbsp;message interpolation">Table&nbsp;4.2, &#8220;message interpolation&#8221;</a>. The current locale is
        assumed English.</p><pre class="programlisting">//ValidationMessages.properties
myapp.creditcard.error=credit card number not valid</pre><p></p><div class="table"><a name="table-messageinterpolation"></a><p class="title"><b>Table&nbsp;4.2.&nbsp;message interpolation</b></p><table summary="message interpolation" border="1"><colgroup><col align="center"><col></colgroup><tbody><tr><td align="center">Failing constraint declaration</td><td>interpolated message</td></tr><tr><td align="center"><tt class="classname">@NotNull</tt></td><td>must not be null</td></tr><tr><td align="center"><tt class="classname">@Max(30)</tt></td><td>must be less than or equal to 30</td></tr><tr><td align="center"><tt class="classname">@Size(min=5, max=15, message="Key must have
                \\{{min}\\} \\ \\{{max}\\} characters")</tt></td><td>Key must have {5} \ {15} characters</td></tr><tr><td align="center"><tt class="classname">@Digits(integer=9,
                fraction=2)</tt></td><td>numeric value out of bounds (&lt;9 digits&gt;.&lt;2
                digits&gt; expected)</td></tr><tr><td align="center"><tt class="classname">@CreditCard(message={myapp.creditcard.error})</tt></td><td>credit card number not valid</td></tr></tbody></table></div><p>Here is an approach to specify the <tt class="classname">Locale</tt>
        value to choose on a given <tt class="classname">Validator</tt>.
        <tt class="classname">Locale</tt> aware
        <tt class="classname">MessageInterpolator</tt>. See <a href="#bootstrapping" title="4.4.&nbsp;Bootstrapping">Section&nbsp;4.4, &#8220;Bootstrapping&#8221;</a> for more details on the APIs.</p><div class="example"><a name="validationapi-message-examples-specificlocale"></a><p class="title"><b>Example&nbsp;4.3.&nbsp;Use MessageInterpolator to use a specific Locale
          value</b></p><pre class="programlisting">/**
 * delegates to a MessageInterpolator implementation but enforce a given Locale
 */
public class LocaleSpecificMessageInterpolator implements MessageInterpolator {
    private final MessageInterpolator defaultInterpolator;
    private final Locale defaultLocale;

    public LocaleSpecificMessageInterpolator(MessageInterpolator interpolator, Locale locale) {
        this.defaultLocale = locale;
        this.defaultInterpolator = interpolator;
    }

    /**
     * enforece the locale passed to the interpolator
     */
    public String interpolate(String message, 
                              Context context) {
        return defaultInterpolator.interpolate(message, 
                                               context, 
                                               this.defaultLocale);
    }

    // no real use, implemented for completeness
    public String interpolate(String message,
                              Context context,
                              Locale locale) {
        return defaultInterpolator.interpolate(message, context, locale);
    }
}


Locale locale = getMyCurrentLocale();
MessageInterpolator interpolator = new LocaleSpecificMessageInterpolator(
                                       validatorFactory.getMessageInterpolator(),
                                       locale);

Validator validator = validatorFactory.usingContext()
                                      .messageInterpolator(interpolator)
                                      .getValidator();</pre></div><p>Most of the time, however, the relevant
        <tt class="classname">Locale</tt> will be provided by your application
        framework transparently. This framework will implement its own version
        of <tt class="classname">MessageInterpolator</tt> and pass it during the
        <tt class="classname">ValidatorFactory</tt> configuration. The application
        will not have to set the <tt class="classname">Locale</tt> itself. This
        example shows how a container framework would implement
        <tt class="classname">MessageInterpolator</tt> to provide a user specific
        default locale.</p><div class="example"><a name="validationapi-message-examples-jsflocale"></a><p class="title"><b>Example&nbsp;4.4.&nbsp;Contextual container possible
          <tt class="classname">MessageInterpolator</tt> implementation</b></p><pre class="programlisting">public class ContextualMessageInterpolator implements MessageInterpolator {
    private final MessageInterpolator delegate;

    public ContextualMessageInterpolator(MessageInterpolator delegate) { 
        this.delegate = delegate; 
    }

    public String interpolate(String message, Context context) {
        Locale locale = Container.getManager().getUserLocale();
        return this.delegate.interpolate(
                        message, context, locale );
    }

    public String interpolate(String message, Context context, Locale locale) {
        return this.delegate.interpolate(message, context, locale);
    }
}


//Build the ValidatorFactory
Configuration&lt;?&gt; configuration = Validation.byDefaultProvider().configure();
ValidatorFactory factory = configuration
    .messageInterpolator( 
        new ContextualMessageInterpolator( 
                configuration.getDefaultMessageInterpolator() ) )
    .buildValidatorFactory();

//The container uses the factory to validate constraints using the specific MessageInterpolator
Validator validator = factory.getValidator();</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bootstrapping"></a>4.4.&nbsp;Bootstrapping</h2></div></div><div></div></div><p>The bootstrapping API aims at providing a
      <tt class="classname">ValidatorFactory</tt> object which is used to create
      <tt class="classname">Validator</tt> instances. The bootstrap process is
      decoupled from the provider implementation initialization: a bootstrap
      implementation must be able to bootstrap any Bean Validation provider
      implementation. The bootstrap sequence has been designed to achieve
      several goals:</p><div class="itemizedlist"><ul type="disc"><li><p>plug multiple implementations</p></li><li><p>choose a specific implementation</p></li><li><p>extensibility: an application using a specific provider
          implementation can use specific configurations</p></li><li><p>share and reuse of metadata across
          <tt class="classname">Validator</tt>s</p></li><li><p>leave as much freedom as possible to implementations</p></li><li><p>provide integration mechanisms to Java EE 6 and other
          containers</p></li><li><p>type safety</p></li></ul></div><p>The main artifacts involved in the bootstrap process are:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">Validation</tt>: API entry point. Lets you
          optionally define the Bean Validation provider targeted as well as a
          provider resolution strategy. <tt class="classname">Validation</tt>
          generates <tt class="classname">Configuration</tt> objects and can
          bootstrap any provider implementation.</p></li><li><p><tt class="classname">ValidationProvider</tt>: contract between
          the bootstrap procedure and a Bean Validation provider
          implementation.</p></li><li><p><tt class="classname">ValidationProviderResolver</tt>: returns a
          list of all Bean Validation providers available in the execution
          context (generally the classpath).</p></li><li><p><tt class="classname">Configuration</tt>: collects the
          configuration details that will be used to build
          <tt class="classname">ValidatorFactory</tt>. A specific sub interface of
          <tt class="classname">Configuration</tt> must be provided by Bean
          Validation providers. This sub interface typically hosts provider
          specific configurations.</p></li><li><p><tt class="classname">ValidatorFactory</tt>: result of the
          bootstrap process. Build <tt class="classname">Validator</tt> instances
          from a given Bean Validation provider.</p></li><li><p><tt class="filename">META-INF/validation.xml</tt>: a configuration
          file, Bean Validation users can use to customize the configuration
          of the default <tt class="classname">ValidatorFactory</tt>.</p></li></ul></div><p>Let's first see the API in action through some examples before
      diving into the concrete definitions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4236"></a>4.4.1.&nbsp;Examples</h3></div></div><div></div></div><p>The most simple approach is to initialize the default Bean
        Validation provider or the one defined in the XML configuration file.
        The <tt class="classname">ValidatorFactory</tt> is then ready to provide
        <tt class="classname">Validator</tt> instances.</p><div class="example"><a name="d0e4247"></a><p class="title"><b>Example&nbsp;4.5.&nbsp;Simple Bean Validation bootstrap sequence</b></p><pre class="programlisting">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();</pre></div><p>The <tt class="classname">ValidatorFactory</tt> object is
        thread-safe. Building <tt class="classname">Validator</tt> instances is
        typically a cheap operation. Building a
        <tt class="classname">ValidatorFactory</tt> is typically more expensive.
        Make sure to check your Bean Validation implementation documentation
        for more accurate details.</p><p>The second example shows how a container can customize some Bean
        Validator resource handling to match its own behavior.</p><div class="example"><a name="d0e4265"></a><p class="title"><b>Example&nbsp;4.6.&nbsp;Customize message resolution, traversable resolver and
          constraint Validator factory implementation</b></p><pre class="programlisting">//some customization from a container
ValidatorFactory factory = Validation
       .byDefaultProvider().configure()
          .messageInterpolator( new ContainerMessageInterpolator() )
          .constraintValidatorFactory( new ContainerComponentConstraintValidatorFactory() )
          .traversableResolver( new JPAAwareTraversableResolver() )
          .buildValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();</pre></div><p>The third example shows how to bootstrap Bean Validation in an
        environment not following the traditional Java classloader strategies
        (such as tools or alternative service containers like OSGi). They can
        provider some alternative provider resolution strategy to discover
        Bean Validation providers.</p><div class="example"><a name="d0e4272"></a><p class="title"><b>Example&nbsp;4.7.&nbsp;Customize the Bean Validation provider resolution
          mechanism</b></p><pre class="programlisting">//osgi environment
ValidatorFactory factory = Validation
       .byDefaultProvider()
          .providerResolver( new OSGiServiceDiscoverer() )
          .configure()
             .buildValidatorFactory();

//cache the factory somewhere
Validator validator = factory.getValidator();</pre></div><p>The next example shows how a client can choose a specific Bean
        Validation provider and configure provider specific properties
        programmatically in a type-safe way.</p><div class="example"><a name="d0e4279"></a><p class="title"><b>Example&nbsp;4.8.&nbsp;Use a specific provider and add specific
          configuration</b></p><pre class="programlisting">ValidatorFactory factory = Validation
       .byProvider( ACMEProvider.class )  //chose a specific provider
       .configure()
          .messageInterpolator( new ContainerMessageInterpolator() ) //default configuration option
          .addConstraint(Address.class, customConstraintDescriptor) //ACME specific method
          .buildValidatorFactory();

//same initialization decomposing calls
ACMEConfiguration acmeConfiguration = Validation
       .byProvider( ACMEProvider.class )
       .configure();

ValidatorFactory factory = acmeConfiguration
          .messageInterpolator( new ContainerMessageInterpolator() ) //default configuration option
          .addConstraint(Address.class, customConstraintDescriptor) //ACME specific method
          .buildValidatorFactory();

/**
 * ACME specific validator configuration and configuration options
 */
public interface ACMEConfiguration extends Configuration&lt;ACMEConfiguration&gt; {
    /**
     * Programmatically add constraints. Specific to the ACME provider.
     */
    ACMEConfiguration addConstraint(Class&lt;?&gt; entity, 
                                    ACMEConstraintDescriptor constraintDescriptor);
}

/**
 * ACME validation provider
 * Note how ACMEConfiguration and ACMEProvider are linked together 
 * via the generic parameter.
 */
public class ACMEProvider implements ValidationProvider&lt;ACMEConfiguration&gt; {
    ...
}</pre></div><p>The last example shows how a <tt class="classname">Validator</tt>
        can use a specific <tt class="classname">MessageInterpolator</tt>
        implementation</p><div class="example"><a name="d0e4292"></a><p class="title"><b>Example&nbsp;4.9.&nbsp;Use a specific MessageInterpolator instance for a given
          Validator</b></p><pre class="programlisting">ValidatorFactory factory = ...;
MessageInterpolator customInterpolator = new LocaleSpecificMessageInterpolator(
    locale, 
    factory.getMessageInterpolator()
);

Validator localizedValidator = 
    factory.usingContext()
                   .messageInterpolator(customInterpolator)
                   .getValidator();</pre></div><p>In the same way, a custom
        <tt class="classname">TraversableResolver</tt> can be passed.</p><p>We will now explore the various interfaces, their constraints
        and usage. We will go from the <tt class="classname">ValidatorFactory</tt>
        to the <tt class="classname">Validation</tt> class walking up the
        bootstrap chain.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4310"></a>4.4.2.&nbsp;ValidatorFactory</h3></div></div><div></div></div><p><tt class="classname">ValidatorFactory</tt> objects build and
        provide initialized instances of <tt class="classname">Validator</tt> to
        Bean Validation clients. Each <tt class="classname">Validator</tt>
        instance is configured for a given context (message interpolator,
        traversable resolver). Clients should cache
        <tt class="classname">ValidatorFactory</tt> objects and reuse them for
        optimal performances. The API is designed to allow implementors to
        share constraint metadata in
        <tt class="classname">ValidatorFactory</tt>.</p><p><tt class="classname">ValidatorFactory</tt> implementations must be
        thread-safe. <tt class="classname">ValidatorFactory</tt> implementations
        can cache <tt class="classname">Validator</tt> instances if needed.</p><div class="example"><a name="d0e4339"></a><p class="title"><b>Example&nbsp;4.10.&nbsp;ValidatorFactory interface</b></p><pre class="programlisting">/**
 * Factory returning initialized &lt;code&gt;Validator&lt;/code&gt; instances.
 * Implementations are thread-safe
 * This object is typically cached and reused.
 *
 * @author Emmanuel Bernard
 */
public interface ValidatorFactory {
    /**
     * Returns an initialized &lt;code&gt;Validator&lt;/code&gt; instance using the
     * factory defaults for message interpolator, traversable resolver
     * and constraint validator factory.
     * &lt;p&gt;
     * Validator instances can be pooled and shared by the implementation.
     * &lt;/p&gt;
     * @return an initialized &lt;code&gt;Validator&lt;/code&gt; instance
     */
    Validator getValidator();

    /**
     * Defines a new validator context and return a &lt;code&gt;Validator&lt;/code&gt;
     * compliant this new context.
     *
     * @return a &lt;code&gt;ValidatorContext&lt;/code&gt;.
     */
    ValidatorContext usingContext();

    /**
     * Returns the &lt;code&gt;MessageInterpolator&lt;/code&gt; instance configured at
     * initialization time for the &lt;code&gt;ValidatorFactory&lt;code&gt;.
     * This is the instance used by #getValidator().
     *
     * @return MessageInterpolator instance.
     */
    MessageInterpolator getMessageInterpolator();

    /**
     * Returns the &lt;code&gt;TraversableResolver&lt;/code&gt; instance configured
     * at initialization time for the &lt;code&gt;ValidatorFactory&lt;code&gt;.
     * This is the instance used by #getValidator().
     *
     * @return TraversableResolver instance.
     */
    TraversableResolver getTraversableResolver();

    /**
     * Returns the &lt;code&gt;ConstraintValidatorFactory&lt;/code&gt; instance
     * configured at initialization time for the
     * &lt;code&gt;ValidatorFactory&lt;code&gt;.
     * This is the instance used by #getValidator().
     *
     * @return ConstraintValidatorFactory instance.
     */
    ConstraintValidatorFactory getConstraintValidatorFactory();

    /**
     * Return an instance of the specified type allowing access to
     * provider-specific APIs. If the Bean Validation provider
     * implementation does not support the specified class,
     * &lt;code&gt;ValidationException,&lt;/code&gt; is thrown.
     *
     * @param type  the class of the object to be returned.
     *
     * @return an instance of the specified class.
     *
     * @throws ValidationException if the provider does not
     *         support the call.
     */
    public &lt;T&gt; T unwrap(Class&lt;T&gt; type);
}</pre></div><p>A <tt class="classname">ValidatorFactory</tt> is provided by a
        <tt class="classname">Configuration</tt> object.</p><p><tt class="methodname">unwrap</tt> is provided as a way to access
        objects of a given type specific to a Bean Validation provider
        typically as a complement to the
        <tt class="classname">ValidatorFactory</tt> contract. Using this method
        makes your code non portable.</p><div class="example"><a name="d0e4359"></a><p class="title"><b>Example&nbsp;4.11.&nbsp;Using unwrap to access a provider specific contract</b></p><pre class="programlisting">//if using the ACME provider
ACMEValidatorFactory acmeFactory = factory.unwrap(ACMEValidatorFactory.class);
acmeFactory.setSpecificConfiguration(...);</pre></div><p><tt class="methodname">getMessageInterpolator()</tt> returns the
        <tt class="classname">MessageInterpolator</tt> instance configured during
        the initialization of the <tt class="classname">ValidatorFactory</tt>. It
        is particularly useful to build a <tt class="classname">Validator</tt>
        specific <tt class="classname">MessageInterpolator</tt> wrapping the one
        from the <tt class="classname">ValidatorFactory</tt>.</p><p><tt class="methodname">getTraversableResolver()</tt> returns the
        <tt class="classname">TraversableResolver</tt> instance configured during
        the initialization of the <tt class="classname">ValidatorFactory</tt>. It
        is particularly useful to build a <tt class="classname">Validator</tt>
        specific <tt class="classname">TraversableResolver</tt> wrapping the one
        from the <tt class="classname">ValidatorFactory</tt>.</p><p><tt class="methodname">getConstraintValidatorFactory()</tt> returns
        the <tt class="classname">ConstraintValidatorFactory</tt> instance
        configured during the initialization of the
        <tt class="classname">ValidatorFactory</tt>. It is particularly useful to
        build a <tt class="classname">Validator</tt> specific
        <tt class="classname">ConstraintValidatorFactory</tt> wrapping the one
        from the <tt class="classname">ValidatorFactory</tt>.</p><p><tt class="classname">ValidatorContext</tt> returned by
        <tt class="methodname">usingContext</tt> can be used to customize the
        state in which the <tt class="classname">Validator</tt> must be
        initialized. This is used to customize the
        <tt class="classname">MessageInterpolator</tt>, the
        <tt class="classname">TraversableResolver</tt> or the
        <tt class="classname">ConstraintValidatorFactory</tt>.</p><div class="example"><a name="d0e4440"></a><p class="title"><b>Example&nbsp;4.12.&nbsp;ValidatorContext interface</b></p><pre class="programlisting">/**
 * Represents the context that is used to create &lt;code&gt;Validator&lt;/code&gt;
 * instances.
 *
 * A client may use methods of the &lt;code&gt;ValidatorContext&lt;/code&gt; returned by
 * &lt;code&gt;ValidatorFactory#usingContext&lt;/code&gt; to customize
 * the context used to create &lt;code&gt;Validator&lt;/code&gt; instances
 * (for instance establish different message interpolators or
 * traversable resolvers).
 * 
 * @author Emmanuel Bernard
 */
public interface ValidatorContext {
    /**
     * Defines the message interpolator implementation used by the
     * &lt;code&gt;Validator&lt;/code&gt;.
     * If not set or if null is passed as a parameter,
     * the message interpolator of the &lt;code&gt;ValidatorFactory&lt;/code&gt;
     * is used.
     *
     * @return self following the chaining method pattern
     */
    ValidatorContext messageInterpolator(MessageInterpolator messageInterpolator);

    /**
     * Defines the traversable resolver implementation used by the
     * &lt;code&gt;Validator&lt;/code&gt;.
     * If not set or if null is passed as a parameter,
     * the traversable resolver of the &lt;code&gt;ValidatorFactory&lt;/code&gt; is used.
     *
     * @return self following the chaining method pattern
     */
    ValidatorContext traversableResolver(TraversableResolver traversableResolver);

    /**
     * Defines the constraint validator factory implementation used by the
     * &lt;code&gt;Validator&lt;/code&gt;.
     * If not set or if null is passed as a parameter,
     * the constraint validator factory of the &lt;code&gt;ValidatorFactory&lt;/code&gt; is used.
     *
     * @return self following the chaining method pattern
     */
    ValidatorContext constraintValidatorFactory(ConstraintValidatorFactory factory);

    /**
     * @return an initialized &lt;code&gt;Validator&lt;/code&gt; instance respecting the defined state.
     * Validator instances can be pooled and shared by the implementation.
     */
    Validator getValidator();
}</pre></div><p>The <tt class="classname">MessageInterpolator</tt>, the
        <tt class="classname">TraversableResolver</tt> or the
        <tt class="classname">ConstraintValidatorFactory</tt> passed to the
        <tt class="classname">ValidatorContext</tt> are used instead of the
        <tt class="classname">ValidatorFactory</tt>'s
        <tt class="classname">MessageInterpolator</tt> or
        <tt class="classname">TraversableResolver</tt> instances.</p><div class="example"><a name="d0e4468"></a><p class="title"><b>Example&nbsp;4.13.&nbsp;Use of ValidatorFactory</b></p><pre class="programlisting">ValidatorFactory factory = ...
Validator validatorUsingDefaults = factory.getValidator();
Validator validatorUsingCustomTraversable = factory
                     .usingContext()
                     .traversableResolver( new JPATraversableResolver() )
                     .getValidator();</pre></div><p>See <a href="#validationapi-message-examples-specificlocale" title="Example&nbsp;4.3.&nbsp;Use MessageInterpolator to use a specific Locale&#xA;          value">Example&nbsp;4.3, &#8220;Use MessageInterpolator to use a specific Locale
          value&#8221;</a> for an
        example using
        <tt class="methodname">ValidatorFactory.getMessageInterpolator()</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4480"></a>4.4.3.&nbsp;Configuration</h3></div></div><div></div></div><p><tt class="classname">Configuration</tt> collects configuration
        information, determines the correct provider implementation and
        delegates it the <tt class="classname">ValidatorFactory</tt> creation.
        This class lets you define:</p><div class="itemizedlist"><ul type="disc"><li><p>the message interpolator strategy instance</p></li><li><p>the traversable resolver strategy instance</p></li><li><p>the constraint validator factory instance</p></li><li><p>XML constraint mappings</p></li><li><p>provider specific properties</p></li><li><p>whether or not
            <tt class="classname">META-INF/validation.xml</tt> is
            considered.</p></li></ul></div><p>A <tt class="classname">Configuration</tt> does provide a
        <tt class="classname">MessageInterpolator</tt> implementation following
        the default Bean Validation <tt class="classname">MessageInterpolator</tt>
        rules as defined in <a href="#default-messageresolver" title="4.3.1.&nbsp;Default message interpolation">Section&nbsp;4.3.1, &#8220;Default message interpolation&#8221;</a>. You
        can access it by calling
        <tt class="methodname">getDefaultMessageInterpolator()</tt>. Such an
        implementation is useful to let a custom
        <tt class="classname">MessageInterpolator</tt> delegate to the standard
        <tt class="classname">MessageInterpolator</tt> (see <a href="#custom-message-resolution" title="4.3.2.&nbsp;Custom message interpolation">Section&nbsp;4.3.2, &#8220;Custom message interpolation&#8221;</a> and an example making use of
        <tt class="methodname">getDefaultMessageInterpolator()</tt> in <a href="#validationapi-message-examples-jsflocale" title="Example&nbsp;4.4.&nbsp;Contextual container possible&#xA;          MessageInterpolator implementation">Example&nbsp;4.4, &#8220;Contextual container possible
          MessageInterpolator implementation&#8221;</a>).</p><p>A <tt class="classname">Configuration</tt> does provide a
        <tt class="classname">TraversableResolver</tt> implementation following
        the default Bean Validation <tt class="classname">TraversableResolver</tt>
        rules as defined in <a href="#constraintdeclarationvalidationprocess-validationroutine-traversable" title="3.5.2.&nbsp;Traversable property">Section&nbsp;3.5.2, &#8220;Traversable property&#8221;</a>.
        You can access it by calling
        <tt class="methodname">getDefaultTraversableResolver()</tt>. Such an
        implementation is useful to let a custom
        <tt class="classname">TraversableResolver</tt> delegate to the standard
        <tt class="classname">TraversableResolver</tt>.</p><p>A <tt class="classname">Configuration</tt> does provide a
        <tt class="classname">ConstraintValidatorFactory</tt> implementation
        following the default Bean Validation
        <tt class="classname">ConstraintValidatorFactory</tt> rules as defined in
        <a href="#constraintsdefinitionimplementation-constraintfactory" title="2.5.&nbsp;The ConstraintValidatorFactory">Section&nbsp;2.5, &#8220;The ConstraintValidatorFactory&#8221;</a>.
        You can access it by calling
        <tt class="methodname">getDefaultConstraintValidatorFactory()</tt>. Such
        an implementation is useful to let a custom
        <tt class="classname">ConstraintValidatorFactory</tt> delegate to the
        standard <tt class="classname">TraversableResolver</tt>.</p><p>Clients call
        <tt class="methodname">Configuration.buildValidatorFactory()</tt> to
        retrieve the initialized <tt class="classname">ValidatorFactory</tt>
        instance.</p><div class="example"><a name="d0e4593"></a><p class="title"><b>Example&nbsp;4.14.&nbsp;Configuration interface</b></p><pre class="programlisting">/**
 * Receives configuration information, selects the appropriate
 * Bean Validation provider and builds the appropriate &lt;code&gt;ValidatorFactory&lt;/code&gt;.
 * &lt;p/&gt;
 * Usage:
 * &lt;pre&gt;
 * {@code
 * Configuration&lt;?&gt; configuration = //provided by one of the Validation bootstrap methods
 *     ValidatorFactory = configuration
 *         .messageInterpolator( new CustomMessageInterpolator() )
 *         .buildValidatorFactory();}
 * &lt;/pre&gt;
 * &lt;p/&gt;
 * By default, the configuration information is retrieved from
 * &lt;i&gt;META-INF/validation.xml&lt;/i&gt;.
 * It is possible to override the configuration retrieved from the XML file
 * by using one or more of the &lt;code&gt;Configuration&lt;/code&gt; methods.
 * &lt;p/&gt;
 * The {@link ValidationProviderResolver} is specified at configuration time
 * (see {@link javax.validation.spi.ValidationProvider}).
 * If none is explicitly requested, the default &lt;code&gt;ValidationProviderResolver&lt;/code&gt; is used.
 * &lt;p/&gt;
 * The provider is selected in the following way:
 * &lt;ul&gt;
 * &lt;li&gt;if a specific provider is requested programmatically using
 * &lt;code&gt;Validation.byProvider(Class)&lt;/code&gt;, find the first provider implementing
 * the provider class requested and use it&lt;/li&gt;
 * &lt;li&gt;if a specific provider is requested in &lt;i&gt;META-INF/validation.xml&lt;/i&gt;,
 * find the first provider implementing the provider class requested and use it&lt;/li&gt;
 * &lt;li&gt;otherwise, use the first provider returned by the &lt;code&gt;ValidationProviderResolver&lt;code&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * Implementations are not meant to be thread-safe.
 *
 * @author Emmanuel Bernard
 */
public interface Configuration&lt;T extends Configuration&lt;T&gt;&gt; {

    /**
     * Ignore data from the &lt;i&gt;META-INF/validation.xml&lt;/i&gt; file if this
     * method is called.
     * This method is typically useful for containers that parse
     * &lt;i&gt;META-INF/validation.xml&lt;/i&gt; themselves and pass the information
     * via the &lt;code&gt;Configuration&lt;/code&gt; methods.
     *
     * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern.
     */
    T ignoreXmlConfiguration();

    /**
     * Defines the message interpolator used. Has priority over the configuration
     * based message interpolator.
     * If &lt;code&gt;null&lt;/code&gt; is passed, the default message interpolator is used
     * (defined in XML or the specification default).
     *
     * @param interpolator message interpolator implementation.
     *
     * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern.
     */
    T messageInterpolator(MessageInterpolator interpolator);

    /**
     * Defines the traversable resolver used. Has priority over the configuration
     * based traversable resolver.
     * If &lt;code&gt;null&lt;/code&gt; is passed, the default traversable resolver is used
     * (defined in XML or the specification default).
     *
     * @param resolver traversable resolver implementation.
     *
     * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern.
     */
    T traversableResolver(TraversableResolver resolver);

    /**
     * Defines the constraint validator factory. Has priority over the configuration
     * based constraint factory.
     * If null is passed, the default constraint validator factory is used
     * (defined in XML or the specification default).
     *
     * @param constraintValidatorFactory constraint factory inmplementation.
     *
     * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern.
     */
    T constraintValidatorFactory(ConstraintValidatorFactory constraintValidatorFactory);

    /**
     * Add a stream describing constraint mapping in the Bean Validation
     * XML format.
     * &lt;p/&gt;
     * The stream should be closed by the client API after the
     * &lt;code&gt;ValidatorFactory&lt;/code&gt; has been built. The Bean Validation provider
     * must not close the stream.
     *
     * @param stream XML mapping stream.
     *
     * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern.
     * @throws IllegalArgumentException if &lt;code&gt;stream&lt;/code&gt; is null
     */
    T addMapping(InputStream stream);

    /**
     * Add a provider specific property. This property is equivalent to
     * XML configuration properties.
     * If the underlying provider does not know how to handle the property,
     * it must silently ignore it.
     * &lt;p/&gt;
     * Note: Using this non type-safe method is generally not recommended.
     * &lt;p/&gt;
     * It is more appropriate to use, if available, the type-safe equivalent provided
     * by a specific provider via its &lt;code&gt;Configuration&lt;code&gt; subclass.
     * &lt;code&gt;ValidatorFactory factory = Validation.byProvider(ACMEPrivoder.class)
     * .configure()
     * .providerSpecificProperty(ACMEState.FAST)
     * .buildValidatorFactory();
     * &lt;/code&gt;
     * This method is typically used by containers parsing &lt;i&gt;META-INF/validation.xml&lt;/i&gt;
     * themselves and injecting the state to the Configuration object.
     * &lt;p/&gt;
     * If a property with a given name is defined both via this method and in the
     * XML configuration, the value set programmatically has priority.
     *
     * If null is passed as a value, the value defined in XML is used. If no value
     * is defined in XML, the property is considered unset.
     *
     * @param name property name.
     * @param value property value.
     * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern.
     *
     * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; is null
     */
    T addProperty(String name, String value);

    /**
     * Return an implementation of the &lt;code&gt;MessageInterpolator&lt;/code&gt; interface
     * following the default &lt;code&gt;MessageInterpolator&lt;/code&gt; defined in the
     * specification:
     * &lt;ul&gt;
     * &lt;li&gt;use the ValidationMessages resource bundle to load keys&lt;/li&gt;
     * &lt;li&gt;use Locale.getDefault()&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return default MessageInterpolator implementation compliant with the specification
     */
    MessageInterpolator getDefaultMessageInterpolator();

    /**
     * Return an implementation of the &lt;code&gt;TraversableResolver&lt;/code&gt; interface
     * following the default &lt;code&gt;TraversableResolver&lt;/code&gt; defined in the
     * specification:
     * &lt;ul&gt;
     * &lt;li&gt;if Java Persistence is available in the runtime environment, 
     * a property is considered reachable if Java Persistence considers
     * the property as loaded&lt;/li&gt;
     * &lt;li&gt;if Java Persistence is not available in the runtime environment,
     * all properties are considered reachable&lt;/li&gt;
     * &lt;li&gt;all properties are considered cascadable.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return default TraversableResolver implementation compliant with the specification
     */
    TraversableResolver getDefaultTraversableResolver();

    /**
     * Return an implementation of the &lt;code&gt;ConstraintValidatorFactory&lt;/code&gt; interface
     * following the default &lt;code&gt;ConstraintValidatorFactory&lt;/code&gt; defined in the
     * specification:
     * &lt;ul&gt;
     * &lt;li&gt;uses the public no-arg constructor of the &lt;code&gt;ConstraintValidator&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return default ConstraintValidatorFactory implementation compliant with the specification
     */
    ConstraintValidatorFactory getDefaultConstraintValidatorFactory();

    /**
     * Build a &lt;code&gt;ValidatorFactory&lt;/code&gt; implementation.
     *
     * @return ValidatorFactory
     * @throws ValidationException if the ValidatorFactory cannot be built
     */
    ValidatorFactory buildValidatorFactory();
}</pre></div><p>A Bean Validation provider must define a sub interface of
        <tt class="classname">Configuration</tt> uniquely identifying the
        provider. This subclass is linked to its provider via the
        <tt class="classname">ValidationProvider</tt> generic parameter. The
        <tt class="classname">Configuration</tt> sub interface typically hosts
        provider specific configuration methods.</p><p>To facilitate the use of provider specific configuration
        methods, <tt class="classname">Configuration</tt> uses generics:
        <tt class="classname">Configuration&lt;T extends
        Configuration&lt;T&gt;&gt;</tt> ; the generic return type
        <tt class="classname">T</tt> is returned by chaining methods. The provider
        specific sub interface must resolve the generic T as itself as shown
        in <a href="#example-providerspecific-config" title="Example&nbsp;4.15.&nbsp;Example of provider specific Configuration sub&#xA;          interface">Example&nbsp;4.15, &#8220;Example of provider specific Configuration sub
          interface&#8221;</a>.</p><div class="example"><a name="example-providerspecific-config"></a><p class="title"><b>Example&nbsp;4.15.&nbsp;Example of provider specific Configuration sub
          interface</b></p><pre class="programlisting">/**
 * Unique identifier of the ACME provider
 * also hosts some provider specific configuration methods
 */
public interface ACMEConfiguration 
    extends Configuration&lt;ACMEConfiguration&gt; {

    /**
     * Enables constraints implementation dynamic reloading when using ACME
     * default to false
     */
    ACMEConfiguration enableDynamicReloading(boolean);

}</pre></div><p>When
        <tt class="methodname">Configuration.buildValidatorFactory()</tt> is
        called, the initialized <tt class="classname">ValidatorFactory</tt> is
        returned. More specifically, the requested Bean Validation provider is
        determined and the result of
        <tt class="code">validationProvider.buildValidatorFactory(ConfigurationState)</tt>
        is returned. <tt class="classname">ConfigurationState</tt> gives access to
        the configuration artifacts defined in
        <tt class="filename">META-INF/validation.xml</tt> (unless XML configuration
        is ignored) and provided programmatically to
        <tt class="classname">Configuration</tt>. Generally speaking,
        programmatically defined elements have priority over XML defined
        configuration elements (read the <tt class="classname">Configuration</tt>
        JavaDoc and see <a href="#xml-config" title="4.4.6.&nbsp;XML Configuration: META-INF/validation.xml">Section&nbsp;4.4.6, &#8220;XML Configuration: META-INF/validation.xml&#8221;</a> for more
        information).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A typical implementation of
          <tt class="classname">Configuration</tt> also implements
          <tt class="classname">ConfigurationState</tt>, hence <tt class="code">this</tt>
          can be passed to
          <tt class="methodname">buildValidatorFactory(ConfigurationState)</tt>.</p></div><p>Streams represented in the XML configuration and opened by the
        <tt class="classname">Configuration</tt> implementation must be closed by
        the <tt class="classname">Configuration</tt> implementation after the
        <tt class="classname">ValidatorFactory</tt> creation (or if an exception
        occurs). Streams provided programmatically are the responsibility of
        the application.</p><div class="example"><a name="d0e4678"></a><p class="title"><b>Example&nbsp;4.16.&nbsp;ConfigurationState interface</b></p><pre class="programlisting">package javax.validation.spi;

/**
 * Contract between a &lt;code&gt;Configuration&lt;/code&gt; and a
 * &lt;/code&gt;ValidatorProvider&lt;/code&gt; to create a &lt;code&gt;ValidatorFactory&lt;/code&gt;.
 * The configuration artifacts defined in the XML configuration and provided to the
 * &lt;code&gt;Configuration&lt;/code&gt; are merged and passed along via
 * &lt;code&gt;ConfigurationState&lt;/code&gt;.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConfigurationState {

    /**
     * Returns true if Configuration.ignoreXMLConfiguration() has been called
     * In this case, the ValidatorFactory must ignore META-INF/validation.xml
     *
     * @return {@code true} if META-INF/validation.xml should be ignored
     */
    boolean isIgnoreXmlConfiguration();

    /**
     * Returns the message interpolator of this configuration.
     * Message interpolator is defined in the following decreasing priority:
     * &lt;ul&gt;
     * &lt;li&gt;set via the &lt;code&gt;Configuration&lt;/code&gt; programmatic API&lt;/li&gt;
     * &lt;li&gt;defined in META-INF/validation.xml provided that ignoreXmlConfiguration
     * is false. In this case the instance is created via its no-arg constructor.&lt;/li&gt;
     * &lt;li&gt;{@code null} if undefined.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return message provider instance or null if not defined
     */
    MessageInterpolator getMessageInterpolator();

    /**
     * Returns a set of configuration streams.
     * The streams are defined by:
     * &lt;ul&gt;
     * &lt;li&gt;mapping XML streams passed programmatically in &lt;code&gt;Configuration&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt;mapping XML stream located in the resources defined in&lt;/li&gt;
     * META-INF/validation.xml (constraint-mapping element)
     * &lt;/ul&gt;
     * Streams represented in the XML configuration and opened by the
     * &lt;code&gt;Configuration&lt;/code&gt; implementation must be closed by the
     * &lt;code&gt;Configuration&lt;/code&gt; implementation after the &lt;code&gt;ValidatorFactory&lt;/code&gt;
     * creation (or if an exception occurs).
     *
     * @return set of input stream
     */
    Set&lt;InputStream&gt; getMappingStreams();

    /**
     * Returns the constraint validator factory of this configuration.
     * The {@code ConstraintValidatorFactory} implementation is defined in the following
     * decreasing priority:
     * &lt;ul&gt;
     * &lt;li&gt;set via the &lt;code&gt;Configuration&lt;/code&gt; programmatic API&lt;/li&gt;
     * &lt;li&gt;defined in META-INF/validation.xml provided that ignoredXmlConfiguration
     * is false. In this case the instance is created via its no-arg constructor.&lt;/li&gt;
     * &lt;li&gt;{@code null} if undefined.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return factory instance or {@code null} if not defined
     */
    ConstraintValidatorFactory getConstraintValidatorFactory();

    /**
     * Returns the traversable resolver for this configuration.
     * &lt;code&gt;TraversableResolver&lt;/code&gt; is defined in the following decreasing priority:
     * &lt;ul&gt;
     * &lt;li&gt;set via the &lt;code&gt;Configuration&lt;/code&gt; programmatic API&lt;/li&gt;
     * &lt;li&gt;defined in META-INF/validation.xml provided that ignoredXmlConfiguration
     * is false. In this case the instance is created via its no-arg constructor.&lt;/li&gt;
     * &lt;li&gt;{@code null} if undefined.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return traversable provider instance or {@code null} if not defined
     */
    TraversableResolver getTraversableResolver();

    /**
     * Returns a map of non type-safe custom properties.
     * Properties defined via:
     * &lt;ul&gt;
     * &lt;li&gt;Configuration.addProperty(String, String)&lt;/li&gt;
     * &lt;li&gt;META-INF/validation.xml provided that ignoredXmlConfiguration&lt;/li&gt;
     * is false.
     * &lt;/ul&gt;
     * If a property is defined both programmatically and in XML,
     * the value defined programmatically has priority
     *
     * @return Map whose key is the property key and the value the property value
     */
    Map&lt;String, String&gt; getProperties();
}</pre></div><p>The requested provider implementation is resolved according to
        the following rules in the following order:</p><div class="itemizedlist"><ul type="disc"><li><p>Use the provider implementation requested if
            <tt class="classname">Configuration</tt> has been created from
            <tt class="classname">Validation.byProvider(Class)</tt>.</p></li><li><p>Use the provider implementation described in the XML
            configuration (under
            <tt class="literal">validation-config.default-provider</tt> see <a href="#xml-config" title="4.4.6.&nbsp;XML Configuration: META-INF/validation.xml">Section&nbsp;4.4.6, &#8220;XML Configuration: META-INF/validation.xml&#8221;</a>) if defined: the value of this element is
            the fully qualified class name of the
            <tt class="classname">ValidationProvider</tt> implementation uniquely
            identifying the provider.</p></li><li><p>Use the first provider implementation returned by
            <tt class="classname">validationProviderResolver.getValidationProviders()</tt>.</p></li></ul></div><p>The <tt class="classname">ValidationProviderResolver</tt> is
        specified when <tt class="classname">Configuration</tt> instances are
        created (see <tt class="classname">ValidationProvider</tt>). If no
        <tt class="classname">ValidationProviderResolver</tt> instance has been
        specified, the default
        <tt class="classname">ValidationProviderResolver</tt> is used.</p><p><tt class="classname">Configuration</tt> instances are provided to
        the Bean Validation client through the
        <tt class="classname">Validation</tt> methods.
        <tt class="classname">Configuration</tt> instances are created by
        <tt class="classname">ValidationProvider</tt>.</p><p>If a problem occurs while building the
        <tt class="classname">ValidationFactory</tt>, a
        <tt class="classname">ValidationException</tt> is raised. This can be due
        to various reasons including:</p><div class="itemizedlist"><ul type="disc"><li><p>malformed XML configuration</p></li><li><p>malformed XML mapping</p></li><li><p>inability to find the provider (or a provider)</p></li><li><p>inability to instantiate extension classes provided in the
            XML configuration</p></li><li><p>inconsistent XML mapping (entity declared more than once,
            incorrect field etc).</p></li><li><p>invalid constraint declaration or definition</p></li></ul></div><p>Other exception causes may occur.</p><p>Here is an example of <tt class="classname">Configuration</tt>
        use.</p><div class="example"><a name="d0e4776"></a><p class="title"><b>Example&nbsp;4.17.&nbsp;Use Configuration</b></p><pre class="programlisting">Configuration&lt;?&gt; configuration = ...
ValidatorFactory factory = configuration
              .messageInterpolator( new WBMessageInterpolator() )
              .traversableResolver( new JPAAwareTraversableResolver() )
              .buildValidatorFactory();</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4781"></a>4.4.4.&nbsp;ValidationProvider and ValidationProviderResolver</h3></div></div><div></div></div><p><tt class="classname">ValidationProvider</tt> is the contract
        between the bootstrap process and a specific Bean Validation provider.
        <tt class="classname">ValidationProviderResolver</tt> implements the
        discovery mechanism for Bean Validation provider implementations. Any
        Bean Validation client can implement such a discovery mechanism but it
        is typically implemented by containers having specific classloader
        structures and restrictions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4791"></a>4.4.4.1.&nbsp;ValidationProviderResolver</h4></div></div><div></div></div><p><tt class="classname">ValidationProviderResolver</tt> returns the
          list of Bean Validation providers available at runtime and more
          specifically a <tt class="classname">ValidationProvider</tt> instance
          for each provider available in the context. This service can be
          customized by implementing
          <tt class="classname">ValidationProviderResolver</tt>. Implementations
          must be thread-safe.</p><div class="example"><a name="d0e4804"></a><p class="title"><b>Example&nbsp;4.18.&nbsp;ValidationProviderResolver</b></p><pre class="programlisting">/**
 * Determines the list of Bean Validation providers available in the runtime environment
 * &lt;p/&gt;
 * Bean Validation providers are identified by the presence of
 * META-INF/services/javax.validation.spi.ValidationProvider
 * files following the Service Provider pattern described
 * &lt;a href="http://java.sun.com/j2se/1.5.0/docs/guide/jar/jar.html#Service%20Provider"&gt;here&lt;/a&gt;
 * &lt;p/&gt;
 * Each META-INF/services/javax.validation.spi.ValidationProvider file contains the list of
 * &lt;code&gt;ValidationProvider&lt;/code&gt; implementations each of them representing a provider.
 * &lt;p/&gt;
 * Implementations must be thread-safe.
 *
 * @author Emmanuel Bernard
 */
public interface ValidationProviderResolver {
    /**
     * Returns a list of ValidationProviders available in the runtime environment.
     *
     * @return list of validation providers.
     */
    List&lt;ValidationProvider&lt;?&gt;&gt; getValidationProviders();
}</pre></div><p>By default, providers are resolved using the Service Provider
          pattern described in <a href="http://java.sun.com/j2se/1.5.0/docs/guide/jar/jar.html#Service%20Provider" target="_top">http://java.sun.com/j2se/1.5.0/docs/guide/jar/jar.html#Service%20Provider</a>.
          Bean Validation providers must supply a service provider
          configuration file by creating a text file
          <tt class="filename">javax.validation.spi.ValidationProvider</tt> and
          placing it in the <tt class="filename">META-INF/services</tt> directory
          of one of its jar files. The content of the file should contain the
          name of the provider implementation class of the
          <tt class="classname">javax.validation.spi.ValidationProvider</tt>
          interface.</p><p>Bean Validation provider jars may be installed or made
          available in the same ways as other service providers, e.g. as
          extensions or added to the application classpath according to the
          guidelines in the JAR file specification.</p><p>The default <tt class="classname">ValidationProviderResolver</tt>
          implementation will locate all the Bean Validation providers by
          their provider configuration files visible in the classpath. The
          default <tt class="classname">ValidationProviderResolver</tt>
          implementation is recommended and custom
          <tt class="classname">ValidationProviderResolver</tt> implementations
          should be rarely used. A typical use of a custom resolution is
          resolving providers in a classloader constrained container like OSGi
          or in a tool environment (IDE).</p><p>The default <tt class="classname">ValidationProviderResolver</tt>
          can be accessed via
          <tt class="classname">BootStrapState.getDefaultValidationProviderResolver()</tt>.
          This method is typically used by the Bean Validation provider
          <tt class="classname">Configuration</tt> implementation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id-bootstrap-validationprovider"></a>4.4.4.2.&nbsp;ValidationProvider</h4></div></div><div></div></div><p><tt class="classname">ValidationProvider</tt> represents the SPI
          (Service Provider Interface) defining the contract between the
          provider discovery and initialization mechanism, and the provider. A
          <tt class="classname">ValidationProvider</tt> does:</p><div class="itemizedlist"><ul type="disc"><li><p>Provide a generic <tt class="classname">Configuration</tt>
              implementation (i.e. not tied to a given provider).</p></li><li><p>Provide a provider specific
              <tt class="classname">Configuration</tt> implementation. This
              <tt class="classname">Configuration</tt> will specifically build
              <tt class="classname">ValidatorFactory</tt> instances of the
              provider it comes from.</p></li><li><p>Build a <tt class="classname">ValidatorFactory</tt> object
              from the configuration provided by
              <tt class="classname">ConfigurationState</tt>.</p></li></ul></div><div class="example"><a name="d0e4885"></a><p class="title"><b>Example&nbsp;4.19.&nbsp;ValidationProvider</b></p><pre class="programlisting">package javax.validation.spi;

/**
 * Contract between the validation bootstrap mechanism and the provider engine.
 * &lt;p/&gt;
 * Implementations must have a public no-arg constructor. The construction of a provider
 * should be as "lightweight" as possible.
 *
 * &lt;code&gt;T&lt;/code&gt; represents the provider specific Configuration subclass
 * which typically host provider's additional configuration methods.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ValidationProvider&lt;T extends Configuration&lt;T&gt;&gt; {

    /**
     * Returns a &lt;code&gt;Configuration&lt;/code&gt; instance implementing &lt;code&gt;T&lt;/code&gt;,
     * the &lt;code&gt;Configuration&lt;/code&gt; subinterface.
     * The returned &lt;code&gt;Configuration&lt;/code&gt; instance must use the current provider
     * (&lt;code&gt;this&lt;/code&gt;) to build the &lt;code&gt;ValidatorFactory&lt;/code&gt; instance.
     * &lt;p/&gt;
     *
     * @param state bootstrap state
     *
     * @return specific Configuration implementation
     */
    T createSpecializedConfiguration(BootstrapState state);

    /**
     * Returns a &lt;code&gt;Configuration&lt;/code&gt; instance. This instance is not bound to
     * use the current provider. The choice of provider follows the algorithm described
     * in {@link javax.validation.Configuration}
     * &lt;p/&gt;
     * The &lt;code&gt;ValidationProviderResolver&lt;/code&gt; used by &lt;code&gt;Configuration&lt;/code&gt;
     * is provided by &lt;code&gt;state&lt;/code&gt;.
     * If null, the default &lt;code&gt;ValidationProviderResolver&lt;/code&gt; is used.
     *
     * @param state bootstrap state
     *
     * @return Non specialized Configuration implementation
     */
    Configuration&lt;?&gt; createGenericConfiguration(BootstrapState state);

    /**
     * Build a &lt;code&gt;ValidatorFactory&lt;/code&gt; using the current provider implementation.
     * The &lt;code&gt;ValidatorFactory&lt;/code&gt; is assembled and follows the configuration passed
     * via &lt;code&gt;ConfigurationState&lt;/code&gt;.
     * &lt;p&gt;
     * The returned &lt;code&gt;ValidatorFactory&lt;/code&gt; is properly initialized and ready for use.
     * &lt;/p&gt;
     *
     * @param configurationState the configuration descriptor
     *
     * @return the instanciated ValidatorFactory
     * @throws javax.validation.ValidationException if the ValidatorFactory cannot be built
     */
    ValidatorFactory buildValidatorFactory(ConfigurationState configurationState);
}</pre></div><div class="example"><a name="d0e4890"></a><p class="title"><b>Example&nbsp;4.20.&nbsp;BootstrapState interface</b></p><pre class="programlisting">package javax.validation.spi;

/**
 * Defines the state used to bootstrap the &lt;code&gt;Configuration&lt;/code&gt;
 *
 * @author Emmanuel Bernard
 * @author Sebastian Thomschke 
 */
public interface BootstrapState {
    /**
     * User defined &lt;code&gt;ValidationProviderResolver&lt;/code&gt; strategy
     * instance or &lt;code&gt;null&lt;/code&gt; if undefined.
     *
     * @return ValidationProviderResolver instance or null
     */
    ValidationProviderResolver getValidationProviderResolver();

    /**
     * Specification default &lt;code&gt;ValidationProviderResolver&lt;/code&gt;
     * strategy instance.
     * 
     * @return default implementation of ValidationProviderResolver
     */
    ValidationProviderResolver getDefaultValidationProviderResolver();
}</pre></div><p>A client can request a specific Bean Validation provider by
          using <tt class="classname">&lt;T extends Configuration&lt;T&gt;, U extends
          ValidationProvider&lt;T&gt;&gt;
          Validation.byProvider(Class&lt;U&gt;)</tt> or by defining the
          provider in the XML configuration file. The key uniquely identifying
          a Bean Validation provider is the
          <tt class="classname">ValidationProvider</tt> implementation specific to
          this provider.</p><p>A <tt class="classname">ValidationProvider</tt> implementation is
          linked (via it's generic parameter) to a specific sub interface of
          <tt class="classname">Configuration</tt>. The Bean Validation bootstrap
          API makes use of this link to return the specific Configuration
          subinterface implementation in a type-safe way when a specific
          provider is requested. The sub interface does not have to add any
          new method but is the natural holder for provider specific
          configuration methods.</p><div class="example"><a name="d0e4911"></a><p class="title"><b>Example&nbsp;4.21.&nbsp;Example of provider specific Configuration sub
            interface</b></p><pre class="programlisting">/**
 * Unique identifier of the ACME provider
 * also hosts some provider specific configuration methods
 */
public interface ACMEConfiguration 
    extends Configuration&lt;ACMEConfiguration&gt; {

    /**
     * Enables constraints implementation dynamic reloading when using ACME
     * default to false
     */
    ACMEConfiguration enableDynamicReloading(boolean);

}

/**
 * ACME validation provider
 * Note how ACMEConfiguration and ACMEProvider are linked together 
 * via the generic parameter.
 */
public class ACMEProvider implements ValidationProvider&lt;ACMEConfiguration&gt; {
    ...
}</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><tt class="classname">Configuration</tt> references itself in
            the generic definition. Methods of
            <tt class="classname">Configuration</tt> will return the
            <tt class="classname">ACMEConfiguration</tt> making the API easy to
            use even for vendor specific extensions.</p></div><p>The provider discovery mechanism uses the following
          algorithm:</p><div class="itemizedlist"><ul type="disc"><li><p>Retrieve available providers using
              <tt class="methodname">ValidationProviderResolver.getValidationProviders()</tt>.</p></li><li><p>The first <tt class="classname">ValidationProvider</tt>
              matching the requested provider is returned. Providers are
              evaluated in the order they are returned by
              <tt class="classname">ValidationProviderResolver</tt>. A provider
              instance is considered matching if it is assignable to the
              requested provider class.</p></li></ul></div><p>When the default Bean Validation provider is requested, the
          first <tt class="classname">ValidationProvider</tt> returned by the
          <tt class="classname">ValidationProviderResolver</tt> strategy is
          returned.</p><p>Every Bean Validation provider must provide a
          <tt class="classname">ValidationProvider</tt> implementation containing
          a public no-arg constructor and add the corresponding
          <tt class="filename">META-INF/services/javax.validation.spi.ValidationProvider</tt>
          file descriptor in one of its jars.</p><p>If a problem occurs while building the
          <tt class="classname">ValidationFactory</tt>, a
          <tt class="classname">ValidationException</tt> is raised. This can be
          due to various reasons including:</p><div class="itemizedlist"><ul type="disc"><li><p>malformed XML mapping</p></li><li><p>inability to find the provider (or a provider)</p></li><li><p>inability to instantiate extension classes provided in the
              XML configuration</p></li><li><p>inconsistent XML mapping (entity declared more than once,
              incorrect field etc).</p></li><li><p>invalid constraint declaration or definition</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4985"></a>4.4.5.&nbsp;Validation</h3></div></div><div></div></div><p>The <tt class="classname">Validation</tt> class is the entry point
        used to bootstrap Bean Validation providers. The first entry point,
        <tt class="methodname">buildDefaultValidatorFactory()</tt>, is considered
        to be the default <tt class="classname">ValidatorFactory</tt> and is
        equivalent to the <tt class="classname">ValidatorFactory</tt> returned by
        <tt class="code">Validation.byDefaultProvider().configure().buildValidatorFactory()</tt>.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Should the resolver strategy be configurable by XML</p></div><div class="example"><a name="d0e5008"></a><p class="title"><b>Example&nbsp;4.22.&nbsp;Validation methods available</b></p><pre class="programlisting">/**
 * This class is the entry point for Bean Validation. There are three ways
 * to bootstrap it:
 * &lt;ul&gt;
 * &lt;li&gt;
 * The easiest approach is to build the default &lt;code&gt;ValidatorFactory&lt;/code&gt;.
 * &lt;pre&gt;{@code ValidatorFactory factory = Validation.buildDefaultValidatorFactory();}&lt;/pre&gt;
 * In this case, the default validation provider resolver
 * will be used to locate available providers.
 * The chosen provider is defined as followed:
 * &lt;ul&gt;
 * &lt;li&gt;if the XML configuration defines a provider, this provider is used&lt;/li&gt;
 * &lt;li&gt;if the XML configuration does not define a provider or if no XML configuration
 * is present the first provider returned by the 
 * &lt;code&gt;ValidationProviderResolver&lt;/code&gt; instance is used.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/li&gt;
 * &lt;li&gt;
 * The second bootstrap approach allows to choose a custom
 * &lt;code&gt;ValidationProviderResolver&lt;/code&gt;. The chosen
 * &lt;code&gt;ValidationProvider&lt;/code&gt; is then determined in the same way
 * as in the default bootstrapping case (see above).
 * &lt;pre&gt;{@code
 * Configuration&lt;?&gt; configuration = Validation
 *    .byDefaultProvider()
 *    .providerResolver( new MyResolverStrategy() )
 *    .configure();
 * ValidatorFactory factory = configuration.buildValidatorFactory();}
 * &lt;/pre&gt;
 * &lt;/li&gt;
 * &lt;li&gt;
 * The third approach allows you to specify explicitly and in
 * a type safe fashion the expected provider.
 * &lt;p/&gt;
 * Optionally you can choose a custom &lt;code&gt;ValidationProviderResolver&lt;/code&gt;.
 * &lt;pre&gt;{@code
 * ACMEConfiguration configuration = Validation
 *    .byProvider(ACMEProvider.class)
 *    .providerResolver( new MyResolverStrategy() )  // optionally set the provider resolver
 *    .configure();
 * ValidatorFactory factory = configuration.buildValidatorFactory();}
 * &lt;/pre&gt;
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * Note:&lt;br/&gt;
 * &lt;ul&gt;
 * &lt;li&gt;
 * The &lt;code&gt;ValidatorFactory&lt;/code&gt; object built by the bootstrap process should be cached
 * and shared amongst &lt;code&gt;Validator&lt;/code&gt; consumers.
 * &lt;/li&gt;
 * &lt;li&gt;
 * This class is thread-safe.
 * &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public class Validation {

    /**
     * Build and return a &lt;code&gt;ValidatorFactory&lt;/code&gt; instance based on the
     * default Bean Validation provider and following the XML configuration.
     * &lt;p/&gt;
     * The provider list is resolved using the default validation provider resolver
     * logic.
     * &lt;p/&gt; The code is semantically equivalent to
     * &lt;code&gt;Validation.byDefaultProvider().configure().buildValidatorFactory()&lt;/code&gt;
     *
     * @return &lt;code&gt;ValidatorFactory&lt;/code&gt; instance.
     *
     * @throws ValidationException if the ValidatorFactory cannot be built
     */
    public static ValidatorFactory buildDefaultValidatorFactory() {
        [...]
    }

    /**
     * Build a &lt;code&gt;Configuration&lt;/code&gt;. The provider list is resolved
     * using the strategy provided to the bootstrap state.
     * &lt;pre&gt;
     * Configuration&amp;lt?&amp;gt; configuration = Validation
     *    .byDefaultProvider()
     *    .providerResolver( new MyResolverStrategy() )
     *    .configure();
     * ValidatorFactory factory = configuration.buildValidatorFactory();
     * &lt;/pre&gt;
     * The provider can be specified in the XML configuration. If the XML
     * configuration does not exsist or if no provider is specified,
     * the first available provider will be returned.
     *
     * @return instance building a generic &lt;code&gt;Configuration&lt;/code&gt;
     *         compliant with the bootstrap state provided.
     */
    public static GenericBootstrap byDefaultProvider() {
        [...]
    }

    /**
     * Build a &lt;code&gt;Configuration&lt;/code&gt; for a particular provider implementation.
     * Optionally overrides the provider resolution strategy used to determine the provider.
     * &lt;p/&gt;
     * Used by applications targeting a specific provider programmatically.
     * &lt;p/&gt;
     * &lt;pre&gt;
     * ACMEConfiguration configuration =
     *     Validation.byProvider(ACMEProvider.class)
     *             .providerResolver( new MyResolverStrategy() )
     *             .configure();
     * &lt;/pre&gt;,
     * where &lt;code&gt;ACMEConfiguration&lt;/code&gt; is the
     * &lt;code&gt;Configuration&lt;/code&gt; sub interface uniquely identifying the
     * ACME Bean Validation provider. and &lt;code&gt;ACMEProvider&lt;/code&gt; is the
     * &lt;code&gt;ValidationProvider&lt;/code&gt; implementation of the ACME provider.
     *
     * @param providerType the &lt;code&gt;ValidationProvider&lt;/code&gt; implementation type
     *
     * @return instance building a provider specific &lt;code&gt;Configuration&lt;/code&gt;
     *         sub interface implementation.
     */
    public static &lt;T extends Configuration&lt;T&gt;, U extends ValidationProvider&lt;T&gt;&gt;
            ProviderSpecificBootstrap&lt;T&gt; byProvider(Class&lt;U&gt; providerType) {
        [...]
    }

    [...]
}</pre></div><p>The second entry point lets the client provide a custom
        <tt class="classname">ValidationProviderResolution</tt> instance. This
        instance is passed to <tt class="classname">GenericBootstrap</tt>.
        <tt class="classname">GenericBootstrap</tt> builds a generic
        <tt class="classname">Configuration</tt> using the first
        <tt class="classname">ValidationProvider</tt> returned by
        <tt class="classname">ValidationProviderResolution</tt> and calling
        <tt class="code">ValidationProvider.createGenericConfiguration(BootstrapState
        state)</tt>. <tt class="classname">BootstrapState</tt> holds the
        <tt class="classname">ValidationProviderResolution</tt> instance passed to
        <tt class="classname">GenericBootstrap</tt> and will be used by the
        <tt class="classname">Configuration</tt> instance when resolving the
        provider to use. Note that
        <tt class="code">ValidationProvider.createGenericConfiguration</tt> returns a
        <tt class="classname">Configuration</tt> object not bound to any
        particular provider.</p><div class="example"><a name="d0e5054"></a><p class="title"><b>Example&nbsp;4.23.&nbsp;GenericBootstrap interface</b></p><pre class="programlisting">package javax.validation.bootstrap;

/**
 * Defines the state used to bootstrap Bean Validation and
 * creates a provider agnostic &lt;code&gt;Configuration&lt;/code&gt;.
 *
 * @author Emmanuel Bernard
 */
public interface GenericBootstrap {
    /**
     * Defines the provider resolution strategy.
     * This resolver returns the list of providers evaluated
     * to build the &lt;code&gt;Configuration&lt;/code&gt;
     * &lt;p/&gt;
     * If no resolver is defined, the default &lt;code&gt;ValidationProviderResolver&lt;/code&gt;
     * implementation is used.
     *
     * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern
     */
    GenericBootstrap providerResolver(ValidationProviderResolver resolver);

    /**
     * Returns a generic &lt;code&gt;Configuration&lt;/code&gt; implementation.
     * At this stage the provider used to build the &lt;code&gt;ValidatorFactory&lt;/code&gt; 
     * is not defined.
     * &lt;p/&gt;
     * The &lt;code&gt;Configuration&lt;/code&gt; implementation is provided by the first provider 
     * returned by the &lt;code&gt;ValidationProviderResolver&lt;/code&gt; strategy.
     *
     * @return a Configuration implementation compliant with the bootstrap state
     * @throws javax.validation.ValidationException if the Configuration object cannot be built
     *                        this is generally due to an issue with the ValidationProviderResolver
     */
    Configuration&lt;?&gt; configure();
}</pre></div><p>The last entry point lets the client define the specific Bean
        Validation provider requested as well as a custom
        <tt class="classname">ValidationProviderResolver</tt> implementation if
        needed. The entry point method,
        <tt class="methodname">Validation.byProvider(Class&lt;U&gt;
        providerType)</tt>, takes the provider specific
        <tt class="classname">ValidationProvider</tt> implementation type and
        returns a <tt class="classname">ProviderSpecificBootstrap</tt> object that
        guarantees to return an instance of the specific
        <tt class="classname">Configuration</tt> sub interface. Thanks to the use
        of generics, the client API does not have to cast to the
        <tt class="classname">Configuration</tt> sub interface.</p><p>A <tt class="classname">ProviderSpecificBootstrap</tt> object can
        optionally receive a <tt class="classname">ValidationProviderResolver</tt>
        instance.</p><div class="example"><a name="d0e5087"></a><p class="title"><b>Example&nbsp;4.24.&nbsp;ProviderSpecificBootstrap interface</b></p><pre class="programlisting">package javax.validation.bootstrap;

/**
 * Defines the state used to bootstrap Bean Validation and
 * creates a provider specific &lt;code&gt;Configuration&lt;/code&gt;
 * of type&lt;code&gt;T&lt;/code&gt;.
 * &lt;p/&gt;
 * The specific &lt;code&gt;Configuration&lt;/code&gt; is linked to the provider via the generic
 * parameter of the &lt;code&gt;ValidationProvider&lt;/code&gt; implementation.
 * &lt;p/&gt;
 * The requested provider is the first provider instance assignable to
 * the requested provider type (known when &lt;code&gt;ProviderSpecificBootstrap&lt;/code&gt; is built).
 * The list of providers evaluated is returned by {@link ValidationProviderResolver}.
 * If no &lt;code&gt;ValidationProviderResolver&lt;/code&gt; is defined, the
 * default &lt;code&gt;ValidationProviderResolver&lt;/code&gt; strategy is used.
 *
 * @author Emmanuel Bernard
 */
public interface ProviderSpecificBootstrap&lt;T extends Configuration&lt;T&gt;&gt; {

    /**
     * Optionally defines the provider resolver implementation used.
     * If not defined, use the default &lt;code&gt;ValidationProviderResolver&lt;/code&gt;
     *
     * @param resolver &lt;code&gt;ValidationProviderResolver&lt;/code&gt; implementation used
     *
     * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern
     */
    public ProviderSpecificBootstrap&lt;T&gt; providerResolver(ValidationProviderResolver resolver);

    /**
     * Determines the provider implementation suitable for &lt;code&gt;T&lt;/code&gt; and delegates
     * the creation of this specific &lt;code&gt;Configuration&lt;/code&gt; subclass to the provider.
     *
     * @return &lt;code&gt;Configuration&lt;/code&gt; sub interface implementation
     * @throws javax.validation.ValidationException if the Configuration object cannot be built
     *                        this is generally due to an issue with the ValidationProviderResolver
     */
    public T configure();
}</pre></div><p><tt class="methodname">ProviderSpecificBootstrap.configure()</tt>
        must return the result of
        <tt class="methodname">ValidationProvider.createSpecializedConfiguration(BootstrapState
        state)</tt>. The state parameter holds the
        <tt class="classname">ValidationProviderResolver</tt> passed to
        <tt class="classname">ProviderSpecificBootstrap</tt>. The validation
        provider instance used is the one assignable to the type passed as a
        parameter in <tt class="methodname">Validation.byProvider(Class)</tt>.
        The validation provider is selected according to the algorithm
        described in (<a href="#id-bootstrap-validationprovider" title="4.4.4.2.&nbsp;ValidationProvider">Section&nbsp;4.4.4.2, &#8220;ValidationProvider&#8221;</a>).</p><p>The <tt class="classname">Validation</tt> implementation must not
        contain any non private attribute or method aside from the three
        public static bootstrap methods:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">public static ValidatorFactory
            buildDefaultValidatorFactory()</tt></p></li><li><p><tt class="methodname">public static GenericBootstrap
            byDefaultProvider()</tt></p></li><li><p><tt class="methodname">public static &lt;T extends
            Configuration&lt;T&gt;, U extends ValidationProvider&lt;T&gt;&gt;
            ProviderSpecificBootstrap&lt;T&gt; byProvider(Class&lt;U&gt;
            providerType)</tt></p></li></ul></div><p>The bootstrap API is designed to allow complete portability
        amongst Bean Validation provider implementations. The bootstrap
        implementation must ensure it can bootstrap third party
        providers.</p><p>When building the <tt class="classname">Configuration</tt> object,
        if the <tt class="classname">ValidationProviderResolver</tt> either fail
        or if the expected provider is not found, a
        <tt class="classname">ValidationException</tt> is raised.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml-config"></a>4.4.6.&nbsp;XML Configuration: META-INF/validation.xml</h3></div></div><div></div></div><p>Unless explicitly ignored by calling
        <tt class="classname">Configuration.ignoreXMLConfiguration()</tt>, a
        <tt class="classname">Configuration</tt> takes into account the
        configuration available in
        <tt class="filename">META-INF/validation.xml</tt>. This configuration file
        is optional but can be used by applications to refine some of the Bean
        Validation behavior. If more than one
        <tt class="filename">META-INF/validation.xml</tt> file is found in the
        classpath, a <tt class="classname">ValidationException</tt> is
        raised.</p><p>Unless stated otherwise, XML based configuration settings are
        overridden by values explicitly set via the
        <tt class="classname">Configuration</tt> API. For example, the
        <tt class="classname">MessageInterpolator</tt> defined via
        <tt class="methodname">Configuration.messageInterpolator(MessageInterpolator)</tt>
        has priority over the <tt class="literal">message-interpolator</tt>
        definition.</p><p><tt class="literal">default-provider</tt>: represents the class name
        of the provider specific <tt class="classname">ValidationProvider</tt>
        implementation class. If defined, the specific provider is used
        (unless a specific provider has been chosen via the programmatic
        approach).</p><p><tt class="literal">message-interpolator</tt>: represents the fully
        qualified class name of the <tt class="classname">MessageInterpolator</tt>
        implementation. When defined in XML, the implementation must have a
        public no-arg constructor. This element is optional.</p><p><tt class="literal">traversable-resolver</tt>: represents the fully
        qualified class name of the <tt class="classname">TraversableResolver</tt>
        implementation. When defined in XML, the implementation must have a
        public no-arg constructor. This element is optional.</p><p><tt class="literal">constraint-validator-factory</tt>: represents the
        fully qualified class name of the
        <tt class="classname">ConstraintValidatorFactory</tt> implementation. When
        defined in XML, the implementation must have a public no-arg
        constructor. This element is optional.</p><p><tt class="literal">constraint-mapping</tt>: represents the resource
        path of an XML mapping file. More than one
        <tt class="literal">constraint-mapping</tt> element can be present. Mappings
        provided via
        <tt class="methodname">Configuration.addMapping(InputString)</tt> are
        added to the list of mappings described via
        <tt class="literal">constraint-mapping</tt>.</p><p><tt class="literal">property</tt>: represents a key/value pair
        property providing room to provider specific configurations. Vendors
        should use vendor namespaces for properties (e.g.,
        <tt class="literal">com.acme.validation.logging</tt>). Entries that make use
        of the namespace <tt class="literal">javax.validation</tt> and its
        subnamespaces must not be used for vendor-specific information. The
        namespace <tt class="literal">javax.validation</tt> is reserved for use by
        this specification. Properties defined via
        <tt class="methodname">Configuration.addProperty(String, String)</tt> are
        added to the properties defined via <tt class="literal">property</tt>. If a
        property with the same name are defined in both XML and via the
        programmatic API, the value provided via programmatic API has
        priority.</p><p>If a public no-arg constructor is missing, a
        <tt class="classname">ValidationException</tt> is raised during the
        <tt class="methodname">Configuration.buildValidatorFactory()</tt>
        call.</p><div class="example"><a name="d0e5243"></a><p class="title"><b>Example&nbsp;4.25.&nbsp;Example of META-INF/validation.xml file</b></p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;validation-config
        xmlns="http://jboss.org/xml/ns/javax/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/configuration validation-configuration-1.0.xsd"&gt;
    &lt;default-provider&gt;com.acme.ACMEProvider&lt;/default-provider&gt;
    &lt;message-interpolator&gt;com.acme.ACMEAwareMessageInterpolator&lt;/message-interpolator&gt;

    &lt;constraint-mapping&gt;META-INF/validation/order-constraints.xml&lt;/constraint-mapping&gt;
    &lt;constraint-mapping&gt;META-INF/validation/catalog-constraints.xml&lt;/constraint-mapping&gt;
    &lt;constraint-mapping&gt;META-INF/validation/customer-constraints.xml&lt;/constraint-mapping&gt;

    &lt;property name="com.acme.validation.logging"&gt;WARN&lt;/property&gt;
    &lt;property name="com.acme.validation.safetyChecking"&gt;failOnError&lt;/property&gt;

&lt;/validation-config&gt;</pre></div><p>The XML schema is described in <a href="#xml-config-xsd" title="7.2.&nbsp;Configuration schema">Section&nbsp;7.2, &#8220;Configuration schema&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5252"></a>4.4.7.&nbsp;Usage</h3></div></div><div></div></div><p>The Bean Validation bootstrap API can be used directly by the
        application, through the use of a container or by framework in need
        for validation. In all cases, the following rules apply:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">ValidatorFactory</tt> is a thread-safe
            object that should be built once per deployment unit</p></li><li><p><tt class="classname">Validator</tt> is thread-safe too and
            should be considered a lightweight object.
            <tt class="classname">ValidatorFactory</tt> would typically implement
            appropriate <tt class="classname">Validator</tt> instance caching
            strategies if needed.</p></li></ul></div><p>Containers such as Java EE, dependency injection frameworks,
        component frameworks are encouraged to propose access to
        <tt class="classname">ValidatorFactory</tt> and
        <tt class="classname">Validator</tt> objects in a way that respects the
        previous rules. For example, injection of
        <tt class="classname">Validator</tt> should be possible.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="constraintmetadata"></a>Chapter&nbsp;5.&nbsp;Constraint metadata request APIs</h2></div></div><div></div></div><p>The Bean Validation specification provides a way to query the
    constraint repository. This API is expected to be used for tooling support
    as well as integration with other frameworks, libraries and JSRs. The Bean
    Validation specification aims to provide both a validation engine and a
    metadata repository for object constraints. Frameworks (EE or SE) in need
    for constraint definition, validation and metadata will be able to rely on
    the Bean Validation specification for these services avoiding any
    unnecessary duplication work from an application and infrastructure point
    of view.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5290"></a>5.1.&nbsp;Validator</h2></div></div><div></div></div><p>The main API to access all metadata related to a given object is
      <tt class="classname">Validator</tt> (see <a href="#bootstrapping" title="4.4.&nbsp;Bootstrapping">Section&nbsp;4.4, &#8220;Bootstrapping&#8221;</a>
      for more information on how to retrieve a
      <tt class="classname">Validator</tt> instance).</p><p>A <tt class="classname">Validator</tt> instance hosts the method to
      access to the metadata repository for a given class. It is recommended
      to leave the caching of <tt class="classname">Validator</tt> instances to
      the <tt class="classname">ValidatorFactory</tt>.
      <tt class="classname">Validator</tt> implementations are thread-safe.</p><pre class="programlisting">/**
 * Validate bean instances. Implementations of this interface must be thread-safe.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface Validator {

    [...] //See 4.1

    /**
     * Return the descriptor object describing bean constraints.
     * The returned object (and associated objects including
     * &lt;code&gt;ConstraintDescriptor&lt;code&gt;s) are immutable.
     *
     * @param clazz class or interface type evaluated
     *
     * @return the bean descriptor for the specified class.
     *
     * @throws IllegalArgumentException if clazz is null
     * @throws ValidationException if a non recoverable error happens
     *                             during the metadata discovery or if some
     *                             constraints are invalid.
     */
    BeanDescriptor getConstraintsForClass(Class&lt;?&gt; clazz);
}</pre><p><tt class="methodname">getConstraintsForClass</tt> returns a
      <tt class="classname">BeanDescriptor</tt> object describing the bean level
      constraints (see <a href="#constraintdeclarationvalidationprocess-requirements-object" title="3.1.1.&nbsp;Object validation">Section&nbsp;3.1.1, &#8220;Object validation&#8221;</a>)
      and providing access to the property level constraints metadata.</p><p>If a constraint definition or declaration hosted by the requested
      class (or any of it's superclasses and interfaces according to the
      constraint propagation rules) is invalid, a
      <tt class="classname">ValidationException</tt> is raised. This can be a
      subclass of <tt class="classname">ValidationException</tt> like
      <tt class="classname">ConstraintDefinitionException</tt>,
      <tt class="classname">ConstraintDeclarationException</tt>,
      <tt class="classname">UnexpectedTypeException</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintmetadata-elementdescriptor"></a>5.2.&nbsp;ElementDescriptor</h2></div></div><div></div></div><p><tt class="classname">ElementDescriptor</tt> is the root interface
      describing elements hosting constraints. It is used to describe the list
      of constraints for a given element (whether it be a field, a method or a
      class).</p><p><tt class="classname">ElementDescriptor</tt> lives in the
      <tt class="classname">javax.validation.metadata</tt> package.</p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a validated element (class, field or property).
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ElementDescriptor {

    /**
     * Return &lt;code&gt;true&lt;/code&gt; if at least one constraint declaration is present
     * for this element in the class hierarchy, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    boolean hasConstraints();

    /**
     * @return Statically defined returned type.
     */
    Class&lt;?&gt; getElementClass();

    /**
     * Return all constraint descriptors for this element in the class hierarchy
     * or an empty &lt;code&gt;Set&lt;/code&gt; if none are present.
     *
     * @return &lt;code&gt;Set&lt;/code&gt; of constraint descriptors for this element
     */
    Set&lt;ConstraintDescriptor&lt;?&gt;&gt; getConstraintDescriptors();

    /**
     * Find constraints and potentially restricts them to certain criteria.
     *
     * @return ConstraintFinder object.
     */
    ConstraintFinder findConstraints();

    /**
     * Declare restrictions on retrieved constraints.
     * Restrictions are cumulative.
     *
     * A &lt;code&gt;ConstraintFinder&lt;/code&gt; is not thread-safe. The set of matching
     * &lt;code&gt;ConstraintDescriptor&lt;/code&gt; is.
     */
    interface ConstraintFinder {
        /**
         * Restrict to the constraints matching a given set of groups for this element
         *
         * This method respects group sequences and group inheritance (including
         * class-level &lt;code&gt;Default&lt;/code&gt; group overriding) but does not return
         * &lt;code&gt;ConstraintDescriptor&lt;/code&gt;s in any particular order.
         * Specifically, ordering of the group sequence is not respected.
         *
         * @param groups groups targeted
         *
         * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern
         */
        ConstraintFinder unorderedAndMatchingGroups(Class&lt;?&gt;... groups);

        /**
         * Restrict to the constraints matching the provided scope for this element.
         *
         * Defaults to &lt;code&gt;Scope.HIERARCHY&lt;/code&gt;
         *
         * @param scope expected scope
         * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern
         */
        ConstraintFinder lookingAt(Scope scope);

        /**
         * Restrict to the constraints hosted on the listed &lt;code&gt;types&lt;/code&gt;
         * for a given element.
         *
         * Default to all possible types of the element.
         *
         * Typically used to restrict to fields (&lt;code&gt;FIELD&lt;/code&gt;)
         * or getters (&lt;code&gt;METHOD&lt;/code&gt;)
         *
         * @param types targeted types
         * @return &lt;code&gt;this&lt;/code&gt; following the chaining method pattern
         */
        ConstraintFinder declaredOn(ElementType... types);

        /**
         * Retrieve the constraint descriptors following the defined
         * restrictions and hosted on the element described by
         * &lt;code&gt;ElementDescriptor&lt;/code&gt;
         *
         * @return matching constraint descriptors
         */
        Set&lt;ConstraintDescriptor&lt;?&gt;&gt; getConstraintDescriptors();

        /**
         * Returns &lt;code&gt;true&lt;/code&gt; if at least one constraint declaration
         * matching the restrictions is present on the element,
         * &lt;code&gt;false&lt;/code&gt; otherwise.
         *
         * @return is there any constraint
         */
        boolean hasConstraints();
    }
}</pre><pre class="programlisting">package javax.validation.metadata;

/**
 * Scope looked at when discovering constraints
 *
 * @author Emmanuel Bernard
 */
public enum Scope {
    /**
     * Look for constraints declared on the current class element
     * and ignore inheritance and elements with the same name in
     * the class hierarchy.
     */
    LOCAL_ELEMENT,

    /**
     * Look for constraints declared on all elements of the class hierarchy
     * with the same name.
     */
    HIERARCHY
}</pre><p><tt class="methodname">getElementClass</tt> returns either the object
      type for a class, or the returned type for a property.</p><p><tt class="classname">getConstraintDescriptors</tt> returns all the
      <tt class="classname">ConstraintDescriptor</tt>s (see <a href="#constraintmetadata-constraintdescriptor" title="5.5.&nbsp;ConstraintDescriptor">Section&nbsp;5.5, &#8220;ConstraintDescriptor&#8221;</a>) hosted on the
      given element in the class hierarchy, each
      <tt class="classname">ConstraintDescriptor</tt> describing one of the
      constraints declared on the given element.</p><p><tt class="methodname">hasConstraints</tt> returns true if the given
      element (class, field or property) in the class hierarchy holds at least
      one constraint declaration.</p><p>If you need to query the metadata API in a more fine grained way
      for example by restricting the constraints to the one described on
      fields or on getters or by restricting to a given set of groups, you can
      use the <tt class="classname">ConstraintFinder</tt> fluent API by calling
      <tt class="methodname">findConstraints</tt>.</p><p>Here is an example restricting the list of constraints on getters,
      matching the default group and declared physically on the
      <tt class="literal">name</tt> getter of <tt class="classname">Customer</tt> (and
      not any of the getters on the super classes).</p><div class="example"><a name="d0e5399"></a><p class="title"><b>Example&nbsp;5.1.&nbsp;Using the fluent API to restrict matching constraints</b></p><pre class="programlisting">public class User {
    @Size(max=50) 
    String getName() { ... }
    ...
}

public class Customer extends User {
    @NotNull
    String getName() { ... }
}

PropertyDescriptor pd = 
    validator.getConstraintsForClass(Customer.class).getConstraintsForProperty("name");
Set&lt;ConstraintDescriptor&lt;?&gt;&gt; constraints = 
    pd.findConstraints()
        .declaredOn(ElementType.METHOD)
        .unorderedAndMatchingGroups(Default.class)
        .lookingAt(Scope.LOCAL_ELEMENT)
            .getConstraintDescriptors();

assert 1 == constraints.size();

constraints = pd.getConstraintDescriptors();
//equivalent to pd.findConstraints()..getConstraintDescriptors();
assert 2 == constraints.size();      </pre></div><p><tt class="classname">unorderedAndMatchingGroups</tt> restricts to the
      <tt class="classname">ConstraintDescriptor</tt>s (see <a href="#constraintmetadata-constraintdescriptor" title="5.5.&nbsp;ConstraintDescriptor">Section&nbsp;5.5, &#8220;ConstraintDescriptor&#8221;</a>) matching the set
      of groups passed as parameters and present on the element. Order is not
      respected but group inheritance and inheritance via sequence (including
      the <tt class="classname">Default</tt> group overriding at the class level)
      are honored.</p><p><tt class="methodname">declaredOn</tt> lets you restrict the list of
      element types constraints are hosted on. This is particularly useful to
      retrieve constraints only hosted on fields
      (<tt class="classname">ElementType.FIELD</tt>) or only hosted on getters
      (<tt class="classname">ElementType.METHOD</tt>).</p><p><tt class="methodname">lookingAt</tt> lets you restrict which
      constraints are considered. Either constraints belonging to the element
      but hosted on the class represented by
      <tt class="classname">BeanDescritptor</tt>
      (<tt class="classname">Scope.LOCAL_ELEMENT</tt>), or constraints belonging
      to the element but hosted anywhere in the class hierarchy
      (<tt class="classname">Scope.HIERARCHY</tt>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5439"></a>5.3.&nbsp;BeanDescriptor</h2></div></div><div></div></div><p>The <tt class="classname">BeanDescriptor</tt> interface describes a
      constrained Java Bean. This interface is returned by
      <tt class="methodname">Validator.getConstraintsForClass(Class&lt;?&gt;)</tt>.</p><p><tt class="classname">BeanDescriptor</tt> lives in the
      <tt class="classname">javax.validation.metadata</tt> package.</p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a constrained Java Bean and the constraints associated to it.
 *
 * @author Emmanuel Bernard
 */
public interface BeanDescriptor extends ElementDescriptor {
    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the bean involves validation:
     * &lt;ul&gt;
     * &lt;li&gt; a constraint is hosted on the bean itself &lt;/li&gt;
     * &lt;li&gt; a constraint is hosted on one of the bean properties&lt;/li&gt;
     * &lt;li&gt; or a bean property is marked for cascade (&lt;code&gt;@Valid&lt;/code&gt;)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the bean involves validation, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    boolean isBeanConstrained();

    /**
     * Return the property descriptor for a given property.
     * Return &lt;code&gt;null&lt;/code&gt; if the property does not exist or has no
     * constraint nor is marked as cascaded (see {@link #getConstrainedProperties()} )
     * &lt;p/&gt;
     * The returned object (and associated objects including &lt;code&gt;ConstraintDescriptor&lt;/code&gt;s)
     * are immutable.
     *
     * @param propertyName property evaluated
     *
     * @return the property descriptor for a given property.
     *
     * @throws IllegalArgumentException if propertyName is null
     */
    PropertyDescriptor getConstraintsForProperty(String propertyName);

    /**
     * Returns a set of property descriptors having at least one constraint defined 
     * or marked as cascaded (&lt;code&gt;@Valid&lt;c/ode&gt;). If not property matches, 
     * an empty set is returned.
     */
    Set&lt;PropertyDescriptor&gt; getConstrainedProperties();
}</pre><p><tt class="methodname">isBeanConstrained</tt> returns true if the
      given class (and superclasses and interfaces) hosts at least one
      validation declaration (either constraint or
      <tt class="classname">@Valid</tt> annotation). If the method returns false,
      the Bean Validation engine can safely ignore the bean as it will not be
      impacted by validation.</p><p><tt class="methodname">getConstraintsForProperty</tt> returns a
      <tt class="classname">PropertyDescriptor</tt> object describing the property
      level constraints (See <a href="#constraintdeclarationvalidationprocess-requirements-property" title="3.1.2.&nbsp;Field and property validation">Section&nbsp;3.1.2, &#8220;Field and property validation&#8221;</a>).
      The property is uniquely identified by its name as per the JavaBeans
      convention: field level and getter level constraints of the given name
      are all returned.</p><p><tt class="methodname">getConstrainedProperties</tt> returns the
      <tt class="classname">PropertyDescriptor</tt>s of the bean properties having
      at least one constraint or being cascaded (<tt class="classname">@Valid</tt>
      annotation).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5485"></a>5.4.&nbsp;PropertyDescriptor</h2></div></div><div></div></div><p>The <tt class="classname">PropertyDescriptor</tt> interface describes
      a constrained property of a Java Bean.</p><p><tt class="classname">PropertyDescriptor</tt> lives in the
      <tt class="classname">javax.validation.metadata</tt> package.</p><p>This interface is returned by
      <tt class="methodname">BeanDescriptor.getConstraintsForProperty(String)</tt>
      or <tt class="methodname">BeanDescriptor.getConstrainedProperties</tt>.
      Constraints declared on the attribute and the getter of the same name
      according to the Java Bean rules are returned by this descriptor.</p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a Java Bean property hosting validation constraints.
 *
 * Constraints placed on the attribute and the getter of a given property
 * are all referenced.
 *
 * @author Emmanuel Bernard
 */
public interface PropertyDescriptor extends ElementDescriptor {
    /**
     * Is the property marked by the &lt;code&gt;@Valid&lt;/code&gt; annotation.
     * @return &lt;code&gt;true&lt;/code&gt; if the annotation is present, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    boolean isCascaded();

    /**
     * Name of the property acording to the Java Bean specification.
     * @return property name.
     */
    String getPropertyName();
}</pre><p>The <tt class="methodname">isCascaded</tt> method returns
      <tt class="literal">true</tt> if the property is marked with
      <tt class="classname">@Valid</tt>.</p><p><tt class="methodname">getPropertyName</tt> returns the property name
      as described in <a href="#validationapi-constraintviolation" title="4.2.&nbsp;ConstraintViolation">Section&nbsp;4.2, &#8220;ConstraintViolation&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraintmetadata-constraintdescriptor"></a>5.5.&nbsp;ConstraintDescriptor</h2></div></div><div></div></div><p>A <tt class="classname">ConstraintDescriptor</tt> object describes a
      given constraint declaration (i.e. a constraint annotation).</p><p><tt class="classname">ConstraintDescriptor</tt> lives in the
      <tt class="classname">javax.validation.metadata</tt> package.</p><pre class="programlisting">package javax.validation.metadata;

/**
 * Describes a single constraint and its composing constraints.
 * &lt;code&gt;T&lt;/code&gt; is the constraint's annotation type.
 *
 * @author Emmanuel Bernard
 * @author Hardy Ferentschik
 */
public interface ConstraintDescriptor&lt;T extends Annotation&gt; {
    /**
     * Returns the annotation describing the constraint declaration.
     * If a composing constraint, attribute values are reflecting
     * the overridden attributes of the composing constraint
     *
     * @return The annotation for this constraint.
     */
    T getAnnotation();

    /**
     * The set of groups the constraint is applied on.
     * If the constraint declares no group, a set with only the &lt;code&gt;Default&lt;/code&gt;
     * group is returned.
     *
     * @return The groups the constraint is applied on.
     */
    Set&lt;Class&lt;?&gt;&gt; getGroups();

    /**
     * The set of payload the constraint hosts.
     *
     * @return payload classes hosted on the constraint or an empty set if none.
     */
    Set&lt;Class&lt;? extends Payload&gt;&gt; getPayload();

    /**
     * List of the constraint validation implementation classes.
     *
     * @return list of the constraint validation implementation classes.
     */
    List&lt;Class&lt;? extends ConstraintValidator&lt;T, ?&gt;&gt;&gt;
    getConstraintValidatorClasses();

    /**
     * Returns a map containing the annotation attribute names as keys and the
     * annotation attribute values as value.
     * If this constraint is used as part of a composed constraint, attribute
     * values are reflecting the overridden attribute of the composing constraint.
     *
     * @return a map containing the annotation attribute names as keys
     *         and the annotation attribute values as value.
     */
    Map&lt;String, Object&gt; getAttributes();

    /**
     * Return a set of composing &lt;code&gt;ConstraintDescriptor&lt;/code&gt;s where each
     * descriptor describes a composing constraint. &lt;code&gt;ConstraintDescriptor&lt;/code&gt;
     * instances of composing constraints reflect overridden attribute values in
     * {@link #getAttributes()}  and {@link #getAnnotation()}.
     *
     * @return a set of &lt;code&gt;ConstraintDescriptor&lt;code&gt; objects or an empty set
     *         in case there are no composing constraints.
     */
    Set&lt;ConstraintDescriptor&lt;?&gt;&gt; getComposingConstraints();

    /**
     * @return true if the constraint is annotated with &lt;code&gt;@ReportAsSingleViolation&lt;/code&gt;
     */
    boolean isReportAsSingleViolation();
}</pre><p><tt class="methodname">getAnnotation</tt> returns the annotation
      instance (or an annotation instance representing the given constraint
      declaration). If <tt class="classname">ConstraintDescriptor</tt> represents
      a composing annotation (see <a href="#constraintsdefinitionimplementation-constraintcomposition" title="2.3.&nbsp;Constraint composition">Section&nbsp;2.3, &#8220;Constraint composition&#8221;</a>),
      the returned annotation must reflect parameter overriding. In other
      words, the annotation parameter values are the overridden values.</p><p><tt class="methodname">getAttributes</tt> returns a map containing
      the annotation attribute names as a key, and the annotation attribute
      values as a value (this API is anticipated to be simpler to use by tools
      than reflection over the annotation instance). If
      <tt class="classname">ConstraintDescriptor</tt> represents a composing
      annotation (see <a href="#constraintsdefinitionimplementation-constraintcomposition" title="2.3.&nbsp;Constraint composition">Section&nbsp;2.3, &#8220;Constraint composition&#8221;</a>),
      the returned <tt class="classname">Map</tt> must reflects attribute
      overriding.</p><p><tt class="methodname">getGroups</tt> returns the groups the
      constraint is supposed to be applied upon. If no group is set on the
      constraint declaration, the <tt class="classname">Default</tt> group is
      returned. The groups of a composing constraint are the groups of the
      composed constraint.</p><p><tt class="literal">getPayload</tt> returns the payloads associated to
      the constraint or an empty set if none.</p><p><tt class="methodname">getConstraintValidatorClasses</tt> returns the
      <tt class="classname">ConstraintValidator</tt> classes associated with the
      constraint.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5583"></a>5.6.&nbsp;Example</h2></div></div><div></div></div><p>Assuming the following <tt class="classname">@NotEmpty</tt>
      definition</p><pre class="programlisting">package com.acme.constraint;

@Documented
@NotNull
@Size(min=1)
@ReportAsSingleViolation
@Constraint(validatedBy = NotEmpty.NotEmptyValidator.class)
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
public @interface NotEmpty {
    String message() default "{com.acme.constraint.NotEmpty.message}"
    Class&lt;?&gt; groups() default {};

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        NotEmpty[] value();
    }

    class NotEmptyValidator implements ConstraintValidator&lt;NotEmpty, String&gt; {
        public void initialize(NotEmpty constraintAnnotation) {}

        public boolean isValid(String value, ConstraintValidatorContext context) {
            return true;
        }
    }
}</pre><p>and the following class definitions</p><pre class="programlisting">public class Author {
    private String firstName;
    
    @NotEmpty(message="lastname must not be null")
    private String lastName;

    @Size(max=30)
    private String company;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public String getCompany() {
        return company;
    }

    public void setCompany(String company) {
        this.company = company;
    }
}

public class Book {
    private String title;
    private String description;

    @Valid
    @NotNull
    private Author author;

    @NotEmpty(groups={FirstLevelCheck.class, Default.class})
    @Size(max=30)
    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Author getAuthor() {
        return author;
    }

    public void setAuthor(Author author) {
        this.author = author;
    }

    public String getDescription() {
        return description;
    }

    public void setAuthor(String description) {
        this.description = description;
    }
}</pre><p>The following assertions are true.</p><pre class="programlisting">BeanDescriptor bookDescriptor = validator.getConstraintsForClass(Book.class);

assert ! bookDescriptor.hasConstraints();

assert bookDescriptor.isBeanConstrained();

assert bookDescriptor.getConstraintDescriptors().size() == 0 //no bean-level constraint

//more specifically "author" and "title"
assert bookDescriptor.getConstrainedProperties().size() == 2;

//not a property
assert bookDescriptor.getConstraintsForProperty("doesNotExist") == null; 

//property with no constraint
assert bookDescriptor.getConstraintsForProperty("description") == null; 

ElementDescriptor propertyDescriptor = bookDescriptor.getConstraintsForProperty("title");
assert propertyDescriptor.getConstraintDescriptors().size() == 2
assert "title".equals( propertyDescriptor.getPropertyName() );

//assuming the implementation returns the @NotEmpty constraint first
ConstraintDescriptor&lt;?&gt; constraintDescriptor = propertyDescriptor.getConstraintDescriptors()
                                                              .iterator().next();
assert constraintDescriptor.getAnnotation().getAnnotationType().equals( NotEmpty.class );
assert constraintDescriptor.getGroups().size() == 2; //FirstLevelCheck and Default
assert constraintDescriptor.getComposingConstraints().size() == 2;
assert constraintDescriptor.isReportAsSingleViolation() == true

//@NotEmpty cannot be null
boolean notNullPresence = false;
for ( ConstraintDescriptor&lt;?&gt; composingDescriptor : constraintDescriptor.getComposingConstraints() ) {
    if ( composingDescriptor.getAnnotation().getAnnotationType().equals( NotNull.class ) ) {
        notNullPresence = true;
    }
}
assert notNullPresence; 

//assuming the implementation returns the Size constraint second
constraintDescriptor = propertyDescriptor.getConstraintDescriptors().iterator().next().next();
assert constraintDescriptor.getAnnotation().getAnnotationType().equals( Size.class );
assert constraintDescriptor.getAttributes().get("max") == 30; 
assert constraintDescriptor.getGroups().size() == 1;

propertyDescriptor = bookDescriptor.getConstraintsForProperty("author");
assert propertyDescriptor.getConstraintDescriptors().size() == 1
assert propertyDescriptor.isCascaded()</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e5601"></a>Chapter&nbsp;6.&nbsp;Built-in Constraint definitions</h2></div></div><div></div></div><p>The specification defines a small set of built-in constraints. Their
    usage is encouraged both in regular constraint declarations and as
    composing constraints. Using this set of constraints will enhance
    portability of your constraints across constraint-consuming frameworks
    relying on the metadata API (such as client side validation frameworks or
    database schema generation frameworks).</p><p>Built-in annotations are annotated with an empty
    <tt class="classname">@Constraint</tt> annotation to avoid any dependency
    between the specification API and a specific implementation. Each Bean
    Validation provider must recognize built-in constraint annotations as
    valid constraint definitions and provide compliant constraint
    implementations for each. The built-in constraint validation
    implementation is having a lower priority than an XML mapping definition.
    In other words <tt class="classname">ConstraintValidator</tt> implementations
    for built-in constraints can be overridden by using the XML mapping (see
    <a href="#xml-mapping-constraintdefinition" title="7.1.2.&nbsp;Overriding constraint definitions in XML">Section&nbsp;7.1.2, &#8220;Overriding constraint definitions in XML&#8221;</a>).</p><p>All built-in constraints are in the
    <tt class="classname">javax.validation.constraints</tt> package. Here is the
    list of constraints and their declaration.</p><div class="example"><a name="d0e5621"></a><p class="title"><b>Example&nbsp;6.1.&nbsp;@Null constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be &lt;code&gt;null&lt;/code&gt;.
 * Accepts any type.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {})
public @interface Null {
    String message() default "{javax.validation.constraints.Null.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * Defines several &lt;code&gt;@Null&lt;/code&gt; annotations on the same element
     * @see javax.validation.constraints.Null
     *
     * @author Emmanuel Bernard
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Null[] value();
    }
}</pre></div><div class="example"><a name="d0e5626"></a><p class="title"><b>Example&nbsp;6.2.&nbsp;@NotNull constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must not be &lt;code&gt;null&lt;/code&gt;.
 * Accepts any type.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {})
public @interface NotNull {
    String message() default "{javax.validation.constraints.NotNull.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * Defines several &lt;code&gt;@NotNull&lt;/code&gt; annotations on the same element
     * @see javax.validation.constraints.NotNull
     *
     * @author Emmanuel Bernard
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        NotNull[] value();
    }
}</pre></div><div class="example"><a name="d0e5631"></a><p class="title"><b>Example&nbsp;6.3.&nbsp;@AssertTrue constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be true.
 * Supported types are &lt;code&gt;boolean&lt;/code&gt; and &lt;code&gt;Boolean&lt;/code&gt;
 * &lt;p/&gt;
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {})
public @interface AssertTrue {
    String message() default "{javax.validation.constraints.AssertTrue.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * Defines several &lt;code&gt;@AssertTrue&lt;/code&gt; annotations on the same element
     * @see AssertTrue
     *
     * @author Emmanuel Bernard
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        AssertTrue[] value();
    }
}</pre></div><div class="example"><a name="d0e5636"></a><p class="title"><b>Example&nbsp;6.4.&nbsp;@AssertFalse constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be false.
 * Supported types are &lt;code&gt;boolean&lt;/code&gt; and &lt;code&gt;Boolean&lt;/code&gt;
 * &lt;p/&gt;
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {})
public @interface AssertFalse {
    String message() default "{javax.validation.constraints.AssertFalse.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * Defines several &lt;code&gt;@AssertFalse&lt;/code&gt; annotations on the same element
     * @see javax.validation.constraints.AssertFalse
     *
     * @author Emmanuel Bernard
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        AssertFalse[] value();
    }
}</pre></div><div class="example"><a name="d0e5641"></a><p class="title"><b>Example&nbsp;6.5.&nbsp;@Min constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a number whose value must be higher or
 * equal to the specified minimum.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;BigInteger&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;,
 * and their respective wrappers&lt;/li&gt;
 * &lt;/ul&gt;
 * Note that &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;float&lt;/code&gt; are not supported due to rounding errors
 * (some providers might provide some approximative support)
 * &lt;p/&gt;
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {})
public @interface Min {
    String message() default "{javax.validation.constraints.Min.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * @return value the element must be higher or equal to
     */
    long value();

    /**
     * Defines several &lt;code&gt;@Min&lt;/code&gt; annotations on the same element
     * @see Min
     *
     * @author Emmanuel Bernard
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Min[] value();
    }
}</pre></div><div class="example"><a name="d0e5646"></a><p class="title"><b>Example&nbsp;6.6.&nbsp;@Max constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a number whose value must be lower or
 * equal to the specified maximum.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;BigInteger&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, 
 * and their respective wrappers&lt;/li&gt;
 * &lt;/ul&gt;
 * Note that &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;float&lt;/code&gt; are not supported due to rounding errors
 * (some providers might provide some approximative support)
 * &lt;p/&gt;
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {})
public @interface Max {
    String message() default "{javax.validation.constraints.Max.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * @return value the element must be lower or equal to
     */
    long value();

    /**
     * Defines several &lt;code&gt;@Max&lt;/code&gt; annotations on the same element
     * @see Max
     *
     * @author Emmanuel Bernard
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Max[] value();
    }
}</pre></div><div class="example"><a name="d0e5651"></a><p class="title"><b>Example&nbsp;6.7.&nbsp;@DecimalMin constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a number whose value must be higher or
 * equal to the specificed minimum.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;BigInteger&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;String&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;,
 * and their respective wrappers&lt;/li&gt;
 * &lt;/ul&gt;
 * Note that &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;float&lt;/code&gt; are not supported due to rounding errors
 * (some providers might provide some approximative support)
 * &lt;p/&gt;
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {})
public @interface DecimalMin {
    String message() default "{javax.validation.constraints.DecimalMin.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * The &lt;code&gt;String&lt;/code&gt; representation of the min value according to the
     * &lt;code&gt;BigDecimal&lt;/code&gt; string representation
     * @return value the element must be higher or equal to
     */
    String value();

    /**
     * Defines several &lt;code&gt;@DecimalMin&lt;/code&gt; annotations on the same element
     * @see DecimalMin
     *
     * @author Emmanuel Bernard
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        DecimalMin[] value();
    }
}</pre></div><div class="example"><a name="d0e5656"></a><p class="title"><b>Example&nbsp;6.8.&nbsp;@DecimalMax constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a number whose value must be lower or
 * equal to the specified maximum.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;BigInteger&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;String&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;,
 * and their respective wrappers&lt;/li&gt;
 * &lt;/ul&gt;
 * Note that &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;float&lt;/code&gt; are not supported due to rounding errors
 * (some providers might provide some approximative support)
 * &lt;p/&gt;
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { })
public @interface DecimalMax {
    String message() default "{javax.validation.constraints.DecimalMax.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * The &lt;code&gt;String&lt;/code&gt; representation of the max value according to the
     * &lt;code&gt;BigDecimal&lt;/code&gt; string representation
     *
     * @return value the element must be lower or equal to
     */
    String value();

    /**
     * Defines several &lt;code&gt;@DecimalMax&lt;/code&gt; annotations on the same element
     *
     * @author Emmanuel Bernard
     * @see DecimalMax
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
            @interface List {
        DecimalMax[] value();
    }
}</pre></div><div class="example"><a name="d0e5661"></a><p class="title"><b>Example&nbsp;6.9.&nbsp;@Size constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element size must be between the specified boundaries (included).
 *
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;String&lt;/code&gt; (string length is evaludated)&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;Collection&lt;/code&gt; (collection size is evaluated)&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;Map&lt;/code&gt; (map size is evaluated)&lt;/li&gt;
 * &lt;li&gt;Array (array length is evaluated)&lt;/li&gt;
 *
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {})
public @interface Size {
    String message() default "{javax.validation.constraints.Size.message}";
    
    Class&lt;?&gt;[] groups() default {};

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * @return size the element must be higher or equal to
     */
    int min() default 0;

    /**
     * @return size the element must be lower or equal to
     */
    int max() default Integer.MAX_VALUE;

    /**
     * Defines several &lt;code&gt;@Size&lt;/code&gt; annotations on the same element
     * @see Size
     *
     * @author Emmanuel Bernard
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Size[] value();
    }
}</pre></div><div class="example"><a name="d0e5666"></a><p class="title"><b>Example&nbsp;6.10.&nbsp;@Digits constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a number within accepted range
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;BigInteger&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;String&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;,
 * and their respective wrapper types&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {})
public @interface Digits {
    String message() default "{javax.validation.constraints.Digits.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * @return maximum number of integral digits accepted for this number.
     */
    int integer();

    /**
     * @return maximum number of fractional digits accepted for this number.
     */
    int fraction();

    /**
     * Defines several &lt;code&gt;@Digits&lt;/code&gt; annotations on the same element
     * @see Digits
     *
     * @author Emmanuel Bernard
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Digits[] value();
    }
}</pre></div><div class="example"><a name="d0e5671"></a><p class="title"><b>Example&nbsp;6.11.&nbsp;@Past constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a date in the past.
 * Now is defined as the current time according to the virtual machine
 * The calendar used if the compared type is of type &lt;code&gt;Calendar&lt;/code&gt;
 * is the calendar based on the current timezone and the current locale.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;java.util.Date&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;java.util.Calendar&lt;/code&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {})
public @interface Past {
    String message() default "{javax.validation.constraints.Past.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * Defines several &lt;code&gt;@Past&lt;/code&gt; annotations on the same element
     * @see Past
     *
     * @author Emmanuel Bernard
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Past[] value();
    }
}</pre></div><div class="example"><a name="d0e5676"></a><p class="title"><b>Example&nbsp;6.12.&nbsp;@Future constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated element must be a date in the future.
 * Now is defined as the current time according to the virtual machine
 * The calendar used if the compared type is of type &lt;code&gt;Calendar&lt;/code&gt;
 * is the calendar based on the current timezone and the current locale.
 * &lt;p/&gt;
 * Supported types are:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;java.util.Date&lt;/code&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;java.util.Calendar&lt;/code&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * &lt;code&gt;null&lt;/code&gt; elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {})
public @interface Future {
    String message() default "{javax.validation.constraints.Future.message}";

    Class&lt;?&gt;[] groups() default { };

    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * Defines several &lt;code&gt;@Future&lt;/code&gt; annotations on the same element
     * @see Future
     *
     * @author Emmanuel Bernard
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Future[] value();
    }
}</pre></div><div class="example"><a name="d0e5681"></a><p class="title"><b>Example&nbsp;6.13.&nbsp;@Pattern constraint</b></p><pre class="programlisting">package javax.validation.constraints;

/**
 * The annotated String must match the following regular expression.
 * The regular expression follows the Java regular expression conventions
 * see {@link java.util.regex.Pattern}.
 *
 * Accepts String. &lt;code&gt;null&lt;/code&gt; elements are considered valid.
 *
 * @author Emmanuel Bernard
 */
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {})
public @interface Pattern {
    /**
     * @return The regular expression to match.
     */
    String regexp();

    /**
     * @return Array of &lt;code&gt;Flag&lt;/code&gt;s considered when resolving the regular expression.
     */
    Flag[] flags() default {};

    /**
     * @return The error message template.
     */
    String message() default "{javax.validation.constraints.Pattern.message}";

    /**
     * @return The groups the constraint belongs to.
     */
    Class&lt;?&gt;[] groups() default { };

    /**
     * @return The payload associated to the constraint
     */
    Class&lt;? extends Payload&gt;[] payload() default {};

    /**
     * Possible Regexp flags
     */
    public static enum Flag {

        /**
         * Enables Unix lines mode
         * @see java.util.regex.Pattern#UNIX_LINES
         */
        UNIX_LINES(java.util.regex.Pattern.UNIX_LINES),

        /** 
         * Enables case-insensitive matching
         * @see java.util.regex.Pattern#CASE_INSENSITIVE
         */
        CASE_INSENSITIVE(java.util.regex.Pattern.CASE_INSENSITIVE),

        /**
         * Permits whitespace and comments in pattern
         * @see java.util.regex.Pattern#COMMENTS
         */
        COMMENTS(java.util.regex.Pattern.COMMENTS),

        /**
         * Enables multiline mode
         * @see java.util.regex.Pattern#MULTILINE
         */
        MULTILINE(java.util.regex.Pattern.MULTILINE),

        /**
         * Enables dotall mode
         * @see java.util.regex.Pattern#DOTALL
         */
        DOTALL(java.util.regex.Pattern.DOTALL),

        /**
         * Enables Unicode-aware case folding
         * @see java.util.regex.Pattern#UNICODE_CASE
         */
        UNICODE_CASE(java.util.regex.Pattern.UNICODE_CASE),

        /**
         * Enables canonical equivalence
         * @see java.util.regex.Pattern#CANON_EQ
         */
        CANON_EQ(java.util.regex.Pattern.CANON_EQ);

        //JDK flag value
        private final int value;

        private Flag(int value) {
            this.value = value;
        }

        /**
         * @return flag value as defined in {@link java.util.regex.Pattern}
         */
        public int getValue() {
            return value;
        }
    }

    /**
     * Defines several &lt;code&gt;@Pattern&lt;/code&gt; annotations on the same element
     * @see Pattern
     *
     * @author Emmanuel Bernard
     */
    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
    @Retention(RUNTIME)
    @Documented
    @interface List {
        Pattern[] value();
    }
}</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="xml"></a>Chapter&nbsp;7.&nbsp;XML deployment descriptor</h2></div></div><div></div></div><p>Two kind of XML descriptors are used by Bean Validation. The first
    one describes the Bean Validation configuration provided as
    <tt class="filename">META-INF/validation.xml</tt>. The second one describes
    constraints declarations and closely matches the annotations declaration
    approach.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-mapping"></a>7.1.&nbsp;Constraint definition and declaration</h2></div></div><div></div></div><p>Bean Validation lets you declare constraints via XML rather than
      annotations. You can either ignore constraints declared via annotations
      or consider XML as adding additional constraints on top of annotation
      constraints. While it is not possible to define a new constraint via
      XML, you can redefine the list of
      <tt class="classname">ConstraintValidator</tt> classes associated to a given
      constraint definition.</p><p>There is no distinction between an annotation based constraint
      declaration and an XML based constraint declaration: they are considered
      equivalent and should be treated as such by the Bean Validation
      provider. The rest of the specification only refers to annotations as
      validation metadata: it should be read as annotation or their XML
      descriptor equivalent.</p><p>Specifically when exploring metadata, the Bean Validation provider
      must ensure that an annotation instance corresponding to the XML
      declaration is provided via
      <tt class="classname">ConstraintDescriptor.getAnnnotation()</tt>. The
      annotation elements as well as
      <tt class="methodname">ConstraintValidator.getAttributes()</tt> must
      reflect the values described in the XML declaration (see <a href="#xml-mapping-typeconversion" title="7.1.3.&nbsp;Converting the string representation of a value">Section&nbsp;7.1.3, &#8220;Converting the string representation of a value&#8221;</a>). Likewise,
      <tt class="methodname">ConstraintDescriptor.getConstraintValidatorClasses()</tt>
      must reflect XML based constraint definition overriding (see <a href="#xml-mapping-constraintdefinition" title="7.1.2.&nbsp;Overriding constraint definitions in XML">Section&nbsp;7.1.2, &#8220;Overriding constraint definitions in XML&#8221;</a>).</p><p>A given class must not be described more than once amongst all the
      XML mapping descriptors. A given field or getter must not be described
      more than once on a given class description. A given constraint
      definition must not be overridden more than once amongst all the XML
      mapping descriptors. If any of these rule is violated in a given
      validation deployment, a <tt class="classname">ValidationException</tt> is
      raised during the creation of the
      <tt class="classname">ValidatorFactory</tt>.</p><p>The schema is provided in <a href="#xml-mapping-xsd" title="7.1.4.&nbsp;XML Schema">Section&nbsp;7.1.4, &#8220;XML Schema&#8221;</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5731"></a>7.1.1.&nbsp;Constraint declaration in XML</h3></div></div><div></div></div><p>If <tt class="literal">default-package</tt> is set, all unqualified
        class names (including annotations) are considered part of the package
        described by <tt class="literal">default-package</tt>.</p><p>A given JavaBean is described by the <tt class="classname">bean</tt>
        element. The name of the class is mandatory. By default, all
        constraint declarations expressed via annotation are ignored for
        classes described in XML. You can force Bean Validation to consider
        both annotations and XML constraint declarations by using
        <tt class="code">ignore-annotation="false"</tt> on
        <tt class="literal">bean</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <tt class="literal">ignore-annotation</tt> setting is not
          inherited from nor by the class hierarchy. In other words, it only
          applies to the current bean only.</p></div><p>If the name of the class does refer to a class not present in in
        the classpath, a <tt class="classname">ValidationException</tt> is
        raised.</p><div class="example"><a name="d0e5764"></a><p class="title"><b>Example&nbsp;7.1.&nbsp;Example of bean XML declaration</b></p><pre class="programlisting">&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.0.xsd"&gt;

    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;

    &lt;bean class="Customer" ignore-annotations="false"&gt;
        [...]
    &lt;/bean&gt;
    &lt;bean class="com.acme.common.model.Address"&gt;
        [...]
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5769"></a>7.1.1.1.&nbsp;Class-level overriding</h4></div></div><div></div></div><p>Class level annotations are described via the
          <tt class="literal">class</tt> element. If
          <tt class="literal">ignore-annotations</tt> is declared, Bean Validation
          must honor the explicit value for this element. If not declared, the
          default value defined in the encapsulating
          <tt class="classname">bean</tt> element is considered.</p><p>When <tt class="literal">ignore-annotations</tt> is true,
          class-level Bean Validation annotations are ignored for this class
          (including the <tt class="classname">@GroupSequence</tt>). When
          <tt class="literal">ignore-annotations</tt> is false:</p><div class="itemizedlist"><ul type="disc"><li><p>Constraints declared in XML and constraints declared in
              annotations are added and form the list of class-level declared
              constraints.</p></li><li><p><tt class="classname">@GroupSequence</tt> is considered unless
              <tt class="literal">group-sequence</tt> element is explicitly
              used.</p></li></ul></div><div class="example"><a name="d0e5806"></a><p class="title"><b>Example&nbsp;7.2.&nbsp;Example of class-level declaration</b></p><pre class="programlisting">&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.0.xsd"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;
        &lt;class ignore-annotations="true"&gt;
            [...]
        &lt;/class&gt;
    &lt;/bean&gt;
    &lt;bean class="com.acme.common.model.Address"&gt;
        &lt;class&gt;
            [...]
        &lt;/class&gt;
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5811"></a>7.1.1.2.&nbsp;Field-level overriding</h4></div></div><div></div></div><p>Field level annotations are described via the
          <tt class="literal">field</tt> element. The <tt class="literal">name</tt>
          attribute correspond to the name of the field considered. If
          <tt class="literal">ignore-annotations</tt> is declared, Bean Validation
          must honor the explicit value for this element. If not declared, the
          default value defined in the encapsulating
          <tt class="classname">bean</tt> element is considered.</p><p>When <tt class="literal">ignore-annotations</tt> is true,
          field-level Bean Validation annotations on the targeted field are
          ignored (including the <tt class="classname">@Valid</tt>). When
          <tt class="literal">ignore-annotations</tt> is false:</p><div class="itemizedlist"><ul type="disc"><li><p>Constraints declared in XML and constraints declared in
              annotations are added and form the list of field-level declared
              constraints.</p></li><li><p><tt class="classname">@Valid</tt> is considered unless the
              <tt class="literal">valid</tt> element is explicitly used. Note that
              the only way to disable cascading on a field marked as
              <tt class="classname">@Valid</tt> is to use
              <tt class="code">ignore-annotations=true</tt>.</p></li></ul></div><p>If the name of the field does not correspond to a field in the
          given bean a <tt class="classname">ValidationException</tt> is
          raised.</p><div class="example"><a name="d0e5862"></a><p class="title"><b>Example&nbsp;7.3.&nbsp;Field-level declaration</b></p><pre class="programlisting">&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.0.xsd"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;
        &lt;field name="firstName"&gt;
            [...]
        &lt;/field&gt;
        &lt;field name="orders"&gt;
            &lt;valid/&gt;
            [...]
        &lt;/field&gt;
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5867"></a>7.1.1.3.&nbsp;Property-level overriding</h4></div></div><div></div></div><p>Property-level annotations are described via the
          <tt class="literal">getter</tt> element. The <tt class="literal">name</tt>
          attribute correspond to the name of the property considered as
          defined in <a href="#constraintdeclarationvalidationprocess-requirements-property" title="3.1.2.&nbsp;Field and property validation">Section&nbsp;3.1.2, &#8220;Field and property validation&#8221;</a>
          (for example a getter <tt class="code">String getAge()</tt> would have
          <tt class="code">&lt;getter name="age"/&gt;</tt> as a corresponding
          descriptor). If <tt class="literal">ignore-annotations</tt> is declared,
          Bean Validation must honor the explicit value for this element. If
          not declared, the default value defined in the encapsulating
          <tt class="classname">bean</tt> element is considered.</p><p>When <tt class="literal">ignore-annotations</tt> is true,
          property-level Bean Validation annotations on the targeted property
          are ignored (including the <tt class="classname">@Valid</tt>). When
          <tt class="literal">ignore-annotations</tt> is false:</p><div class="itemizedlist"><ul type="disc"><li><p>Constraints declared in XML and constraints declared in
              annotations are added and form the list of property-level
              declared constraints.</p></li><li><p><tt class="classname">@Valid</tt> is considered unless the
              <tt class="literal">valid</tt> element is explicitly used. Note that
              the only way to disable cascading on a property marked as
              <tt class="classname">@Valid</tt> is to use
              <tt class="code">ignore-annotations=true</tt>.</p></li></ul></div><p>If the name of the property does not correspond to a property
          in the given bean a <tt class="classname">ValidationException</tt> is
          raised.</p><div class="example"><a name="d0e5926"></a><p class="title"><b>Example&nbsp;7.4.&nbsp;Property-level declaration</b></p><pre class="programlisting">&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.0.xsd"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;
        &lt;getter name="firstName"&gt;
            [...]
        &lt;/getter&gt;
        &lt;getter name="orders"&gt;
            &lt;valid/&gt;
            [...]
        &lt;/getter&gt;
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5931"></a>7.1.1.4.&nbsp;Constraint declaration</h4></div></div><div></div></div><p>A new constraint declaration is represented by the
          <tt class="literal">constraint</tt> element. The
          <tt class="literal">annotation</tt> attribute is the class name of the
          annotation representing the constraint. Message, groups and payload
          are defined respectively by the <tt class="literal">message</tt>,
          <tt class="literal">groups</tt> and <tt class="literal">payload</tt>
          elements.</p><p>Other custom elements of an annotation are represented by
          <tt class="literal">element</tt>. The <tt class="literal">name</tt> attribute is
          mandatory and represents the name of the element in the constraint
          declaration. &#8220;<span class="quote">message</span>&#8221;, &#8220;<span class="quote">groups</span>&#8221; and
          &#8220;<span class="quote">payload</span>&#8221; are not permitted names, use the
          <tt class="literal">message</tt>, <tt class="literal">groups</tt> or
          <tt class="literal">payload</tt> elements instead. Otherwise a
          <tt class="classname">ValidationException</tt> is raised.</p><p>If the element represents a primitive type, a class or an
          enum, the string representation of its value is placed in the
          element itself. See <a href="#xml-mapping-typeconversion" title="7.1.3.&nbsp;Converting the string representation of a value">Section&nbsp;7.1.3, &#8220;Converting the string representation of a value&#8221;</a>
          for a detailed explanation of the conversion rules from string to
          the type.</p><p>If the element represents a primitive type array, a class
          array or an enum array, the string representation of each value is
          placed in a <tt class="literal">value</tt> element placed under the
          element itself.</p><p>If the element represents an annotation, the
          <tt class="literal">annotation</tt> element is used to represent the
          annotation and placed under <tt class="literal">element</tt>. An
          <tt class="literal">annotation</tt> element contains
          <tt class="literal">element</tt> elements.</p><p>If the element represents an array of annotations, one or more
          <tt class="literal">annotation</tt> elements are placed under
          <tt class="literal">element</tt>.</p><p>Elements with default values in the annotation definition do
          not have to be represented in XML: the default value will be used in
          this case. If an XML constraint declaration is missing mandatory
          elements, or if it contains elements not part of the constraint
          definition, a <tt class="classname">ValidationException</tt> is
          raised.</p><div class="example"><a name="d0e6016"></a><p class="title"><b>Example&nbsp;7.5.&nbsp;Constraint declaration</b></p><pre class="programlisting">&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.0.xsd"&gt;
    &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
    &lt;bean class="Customer" ignore-annotations="false"&gt;

        &lt;field name="firstName"&gt;


            &lt;!-- @LooksLike(patterns={
                      @Pattern(value="myRegExp", flag=PatternFlag.INSENSITIVE),
                      @Pattern(value="my2ndRegExp")}
                  )
             --&gt;
            &lt;constraint annotation="com.acme.app.constraint.LooksLike"&gt;
                &lt;element name="patterns"&gt;
                    &lt;annotation&gt;
                        &lt;element name="value"&gt;myRegExp&lt;/element&gt;
                        &lt;element name="flag"&gt;
                            &lt;value&gt;INSENSITIVE&lt;/value&gt;
                        &lt;/element&gt;
                    &lt;/annotation&gt;
                    &lt;annotation&gt;
                        &lt;element name="value"&gt;my2ndRegExp&lt;/element&gt;
                    &lt;/annotation&gt;
                &lt;/element&gt;
            &lt;/constraint&gt;


        &lt;/field&gt;
        &lt;field name="orders"&gt;
            &lt;valid/&gt;


            &lt;!-- @DiscreteSize(value={ 0, 20 } )
             --&gt;
            &lt;constraint annotation="com.acme.app.constraint.DiscreteSize"&gt;
                &lt;element name="value"&gt;
                    &lt;value&gt;0&lt;/value&gt;
                    &lt;value&gt;20&lt;/value&gt;
                &lt;/element&gt;
            &lt;/constraint&gt;


        &lt;/field&gt;

        &lt;getter name="orders"&gt;
            &lt;valid/&gt;


            &lt;!-- @Size(message="Size is limited",
                       groups={Default.class, LightValidation.class},
                       max=30
                 )
            --&gt;
            &lt;constraint annotation="javax.validation.constraint.Size"&gt;
                &lt;message&gt;Size is limited&lt;/message&gt;
                &lt;groups&gt;
                    &lt;value&gt;com.acme.app.model.LightValidation&lt;/value&gt;
                    &lt;value&gt;javax.persistence.Default&lt;/value&gt;
                &lt;/groups&gt;
                &lt;payload&gt;
                    &lt;value&gt;com.acme.app.model.WARN&lt;/value&gt;
                &lt;/payload&gt;
                &lt;element name="max"&gt;30&lt;/element&gt;
            &lt;/constraint&gt;


        &lt;/getter&gt;
    &lt;/bean&gt;
&lt;/constraint-mappings&gt;</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml-mapping-constraintdefinition"></a>7.1.2.&nbsp;Overriding constraint definitions in XML</h3></div></div><div></div></div><p>A constraint definition (i.e. the annotation representing a
        constraint), cannot be fully expressed in XML but the list of
        <tt class="classname">ConstraintValidator</tt> associated to a given
        constraint can be altered.</p><p>A constraint definition is represented by a
        <tt class="literal">constraint-definition</tt> element. The
        <tt class="literal">annotation</tt> attribute represents the constraint
        annotation being altered. The <tt class="literal">validated-by</tt> elements
        represent the (ordered) list of
        <tt class="classname">ConstraintValidator</tt> implementations associated
        to the constraint.</p><p>If <tt class="literal">include-existing-validator</tt> is set to
        false, <tt class="classname">ConstraintValidator</tt> defined on the
        constraint annotation are ignored. If set to true, the list of
        <tt class="classname">ConstraintValidator</tt>s described in XML are
        concatenated to the list of <tt class="classname">ConstraintValidator</tt>
        described on the annotation to form a new array of
        <tt class="classname">ConstraintValidator</tt> evaluated. Annotation based
        <tt class="classname">ConstraintValidator</tt> come before XML based
        <tt class="classname">ConstraintValidatot</tt> in the array. The new list
        is returned by
        <tt class="methodname">ConstraintDescriptor.getConstraintValidatorClasses()</tt>.</p><div class="example"><a name="d0e6069"></a><p class="title"><b>Example&nbsp;7.6.&nbsp;Overriding constraint definitions</b></p><pre class="programlisting">&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
            "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.0.xsd"&gt;
   &lt;default-package&gt;com.acme.app.domain&lt;/default-package&gt;
   &lt;bean class="com.acme.common.model.Address"&gt;
       [...]
    &lt;/bean&gt;

    &lt;constraint-definition annotation="javax.validation.constraint.Size"&gt;
        &lt;validated-by include-existing-validators="true"&gt;
            &lt;value&gt;com.acme.app.constraint.SizeValidatorForDictionary&lt;/value&gt;
        &lt;/validated-by&gt;
    &lt;/constraint-definition&gt;
    &lt;constraint-definition annotation="AcmeOrderNumber"&gt;
        [...]
    &lt;/constraint-definition&gt;
&lt;/constraint-mappings&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml-mapping-typeconversion"></a>7.1.3.&nbsp;Converting the string representation of a value</h3></div></div><div></div></div><p>Primitive types, <tt class="classname">Class</tt> and
        <tt class="classname">Enum</tt> are represented as strings in the XML
        descriptor. Elements of an array are represented by the
        <tt class="literal">value</tt> element.</p><p><tt class="classname">byte</tt> are represented according to the
        rules defined in
        <tt class="methodname">Byte.parseByte(String)</tt>.</p><p><tt class="classname">short</tt> are represented according to the
        rules defined in
        <tt class="methodname">Short.parseShort(String)</tt>.</p><p><tt class="classname">int</tt> are represented according to the
        rules defined in
        <tt class="methodname">Integer.parseInt(String)</tt>.</p><p><tt class="classname">long</tt> are represented according to the
        rules defined in
        <tt class="methodname">Long.parseLong(String)</tt>.</p><p><tt class="classname">float</tt> are represented according to the
        rules defined in
        <tt class="methodname">Float.parseFloat(String)</tt>.</p><p><tt class="classname">double</tt> are represented according to the
        rules defined in
        <tt class="methodname">Double.parseDouble(String)</tt>.</p><p><tt class="classname">boolean</tt> are represented according to the
        rules defined in
        <tt class="methodname">Boolean.parseBoolean(String)</tt>.</p><p><tt class="classname">char</tt> are represented according to the
        following rules:</p><div class="itemizedlist"><ul type="disc"><li><p>the string must be of one character long</p></li><li><p>the character extracted from the string is the returned
            <tt class="classname">char</tt></p></li></ul></div><p>A <tt class="classname">Class</tt> is represented by the fully
        qualified class name of the class. Note that if the raw string is
        unqualified, default package is taken into account.</p><p>An enum is represented by its <tt class="code">enum.name()</tt>
        value.</p><p>If any of the string representation does not match its type
        counterpart, a <tt class="classname">ValidationException</tt> is
        raised.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xml-mapping-xsd"></a>7.1.4.&nbsp;XML Schema</h3></div></div><div></div></div><p>This section contains the XML schema used for constraint
        mapping.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema attributeFormDefault="unqualified"
           elementFormDefault="qualified"
           targetNamespace="http://jboss.org/xml/ns/javax/validation/mapping"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           version="1.0"&gt;
    &lt;xs:element name="constraint-mappings"
                type="map:constraint-mappingsType"
                xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;

    &lt;xs:complexType name="payloadType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="groupsType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="groupSequenceType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="constraint-mappingsType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="default-package" minOccurs="0"/&gt;
            &lt;xs:element type="map:beanType"
                        name="bean"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
            &lt;xs:element type="map:constraint-definitionType"
                        name="constraint-definition"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="validated-byType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:boolean" name="include-existing-validators" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="constraintType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="message" minOccurs="0"/&gt;
            &lt;xs:element type="map:groupsType"
                        name="groups"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
            &lt;xs:element type="map:payloadType"
                        name="payload"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;            
            &lt;xs:element type="map:elementType"
                        name="element"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="annotation" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="elementType" mixed="true"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="value" maxOccurs="unbounded" minOccurs="0"/&gt;
            &lt;xs:element type="map:annotationType"
                        name="annotation"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="name" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="classType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:groupSequenceType" 
                        name="group-sequence" 
                        minOccurs="0" 
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
            &lt;xs:element type="map:constraintType"
                        name="constraint"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="beanType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:classType"
                        name="class"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"&gt;
            &lt;/xs:element&gt;
            &lt;xs:element type="map:fieldType"
                        name="field"
                        minOccurs="0"
                        maxOccurs="unbounded"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
            &lt;xs:element type="map:getterType"
                        name="getter"
                        minOccurs="0"
                        maxOccurs="unbounded"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="class" use="required"/&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="annotationType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:elementType"
                        name="element"
                        maxOccurs="unbounded"
                        minOccurs="0"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="getterType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="valid" minOccurs="0" fixed=""/&gt;
            &lt;xs:element type="map:constraintType"
                        name="constraint"
                        minOccurs="0"
                        maxOccurs="unbounded"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="name" use="required"/&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="constraint-definitionType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="map:validated-byType"
                        name="validated-by"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="annotation" use="required"/&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="fieldType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="valid" minOccurs="0" fixed=""/&gt;
            &lt;xs:element type="map:constraintType"
                        name="constraint"
                        minOccurs="0"
                        maxOccurs="unbounded"
                        xmlns:map="http://jboss.org/xml/ns/javax/validation/mapping"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute type="xs:string" name="name" use="required"/&gt;
        &lt;xs:attribute type="xs:boolean" name="ignore-annotations" use="optional"/&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml-config-xsd"></a>7.2.&nbsp;Configuration schema</h2></div></div><div></div></div><p>XML Configuration is set in
      <tt class="filename">META-INF/validation.xml</tt>. The file is optional. The
      XML schema followed by the configuration file is as followed.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema attributeFormDefault="unqualified"
           elementFormDefault="qualified"
           targetNamespace="http://jboss.org/xml/ns/javax/validation/configuration"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           version="1.0"&gt;
    &lt;xs:element name="validation-config" type="config:validation-configType" xmlns:config="http://jboss.org/xml/ns/javax/validation/configuration"/&gt;
    &lt;xs:complexType name="validation-configType"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element type="xs:string" name="default-provider" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="message-interpolator" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="traversable-resolver" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="constraint-validator-factory" minOccurs="0"/&gt;
            &lt;xs:element type="xs:string" name="constraint-mapping" maxOccurs="unbounded" minOccurs="0"/&gt;
            &lt;xs:element type="config:propertyType" name="property" maxOccurs="unbounded" minOccurs="0" xmlns:config="http://jboss.org/xml/ns/javax/validation/configuration"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:complexType name="propertyType"&gt;
        &lt;xs:simpleContent&gt;
            &lt;xs:extension base="xs:string"&gt;
                &lt;xs:attribute name="name" use="required" type="xs:string"/&gt;
            &lt;/xs:extension&gt;
        &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;</pre><p>See <a href="#xml-config" title="4.4.6.&nbsp;XML Configuration: META-INF/validation.xml">Section&nbsp;4.4.6, &#8220;XML Configuration: META-INF/validation.xml&#8221;</a> for more information on XML
      based configuration.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="exception"></a>Chapter&nbsp;8.&nbsp;Exception model</h2></div></div><div></div></div><p>Illegal arguments passed to the Bean Validation APIs generally lead
    to a <tt class="classname">IllegalArgumentException</tt> (see the JavaDoc for
    specific details). Other exceptions raised by Bean Validation are or
    inherit from the runtime exception
    <tt class="classname">javax.validation.ValidationException</tt>. Exception
    cases are described in their respective sections but include (non
    exhaustive list):</p><div class="itemizedlist"><ul type="disc"><li><p>invalid constraint definitions (missing mandatory elements,
        illegal composition cycle, illegal attribute overriding, etc)</p></li><li><p>invalid constraint declarations
        (<tt class="classname">ConstraintValidator</tt> implementation matching
        failure, etc)</p></li><li><p>invalid group definition (circularity)</p></li><li><p>invalid <tt class="classname">Default</tt> group redefinition for
        classes (missing class group etc)</p></li><li><p>error when retrieving, initializing, executing
        <tt class="classname">ConstraintValidator</tt>s</p></li><li><p>error when parsing the XML configuration or mappings</p></li><li><p>multiple XML configuration files found</p></li><li><p>missing expected provider or no default provider found</p></li><li><p>missing no-arg constructor on extension implementations
        described in XML configuration files</p></li><li><p>same entity described more than once across the XML mapping
        files</p></li><li><p>same property or field described more than once for a given
        entity in the XML mapping files</p></li><li><p>class, field or getter declared in XML mapping files but not
        found</p></li><li><p>illegal XML constraint definition</p></li><li><p>illegal XML constraint declaration</p></li><li><p>exception raised either at initialization time or execution time
        by any of the extension interfaces</p></li></ul></div><p>Each of these error cases lead to a
    <tt class="classname">ValidationException</tt> or a subclass of
    <tt class="classname">ValidationException</tt> (see following
    subsections).</p><p>Every (runtime) exception raised either at initialization time or
    execution time by any of the extension interfaces
    (<tt class="classname">ConstraintValidator</tt>,
    <tt class="classname">ConstraintValidatorFactory</tt>,
    <tt class="classname">MessageInterpolator</tt>,
    <tt class="classname">TraversableResolver</tt>,
    <tt class="classname">ValidationProviderResolver</tt>) is wrapped in a
    <tt class="classname">ValidationException</tt>.</p><p>If a constraint definition or constraint declaration is invalid for
    a given class, the metadata API should raise the according
    exception.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6282"></a>8.1.&nbsp;Error report:
      <tt class="classname">ConstraintViolationException</tt></h2></div></div><div></div></div><p>Some frameworks or applications need to convey the result of a
      validation by raising an exception if the validation returns constraint
      violations.</p><p>Bean Validation provides a reference exception for such cases.
      Frameworks and applications are encouraged to use
      <tt class="classname">ConstraintViolationException</tt> as opposed to a
      custom exception to increase consistency of the Java platform. The
      exception can be raised directly or wrapped into the framework or
      application specific parent exception.</p><pre class="programlisting">/**
 * Reports the result of constraint violations
 *                                                    `
 * @author Emmanuel Bernard
 */
public class ConstraintViolationException extends ValidationException {
    private final Set&lt;ConstraintViolation&lt;?&gt;&gt; constraintViolations;

    /**
     * Creates a constraint violation report
     *
     * @param message error message
     * @param constraintViolations &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;ConstraintViolation&lt;/code&gt;
     */
    public ConstraintViolationException(String message,
                                        Set&lt;ConstraintViolation&lt;?&gt;&gt; constraintViolations) {
        super( message );
        this.constraintViolations = constraintViolations;
    }

    /**
     * Creates a constraint violation report
     *
     * @param constraintViolations &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;ConstraintViolation&lt;/code&gt;
     */
    public ConstraintViolationException(Set&lt;ConstraintViolation&lt;?&gt;&gt; constraintViolations) {
        super();
        this.constraintViolations = constraintViolations;
    }

    /**
     * Set of constraint violations reported during a validation
     *
     * @return &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;ConstraintViolation&lt;/code&gt;
     */
    public Set&lt;ConstraintViolation&lt;?&gt;&gt; getConstraintViolations() {
        return constraintViolations;
    }
}</pre><p>The <tt class="classname">ConstraintViolationException</tt> carries a
      <tt class="classname">Set</tt> of
      <tt class="classname">ConstraintViolation</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Bean Validation never raises this exception itself. Other
        frameworks like Java Persistence 2 do.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If this exception is meant to be send remotely,
        <tt class="classname">ConstraintViolation</tt> objects should be
        <tt class="classname">Serializable</tt> as defined an explained in <a href="#validationapi-constraintviolation" title="4.2.&nbsp;ConstraintViolation">Section&nbsp;4.2, &#8220;ConstraintViolation&#8221;</a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6321"></a>8.2.&nbsp;Constraint definition:
      <tt class="classname">ConstraintDefinitionException</tt></h2></div></div><div></div></div><p>If a constraint definition does not respect the Bean Validation
      rules or is inconsistent, a
      <tt class="classname">ConstraintDefinitionException</tt> is raised.
      <tt class="classname">ConstraintDefinitionException</tt> is a subclass of
      <tt class="classname">ValidationException</tt>.</p><p>This exception can be raised during validation or when the
      metadata model for the class hosting this constraint is
      requested.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>These exception cases can be determined at compile time by a
        tool such as an annotation processor.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6342"></a>8.3.&nbsp;Constraint declaration:
      <tt class="classname">ConstraintDeclarationException</tt> and
      <tt class="classname">UnexpectedTypeException</tt></h2></div></div><div></div></div><p>When a constraint declaration is illegal,
      <tt class="classname">ConstraintDeclarationException</tt> is raised.</p><p><tt class="classname">ConstraintDeclarationException</tt> is a
      subclass of <tt class="classname">ValidationException</tt>.</p><p>When the return type of a property cannot be processed for a given
      constraint, an <tt class="classname">UnexpectedTypeException</tt> is raised.
      This problem typically arise when either no
      <tt class="classname">ConstraintValidator</tt> or too many
      <tt class="classname">ConstraintValidator</tt>s match the return type (see
      <a href="#typevalidatorresolution" title="3.5.3.&nbsp;ConstraintValidator resolution algorithm">Section&nbsp;3.5.3, &#8220;ConstraintValidator resolution algorithm&#8221;</a>).</p><p><tt class="classname">UnexpectedTypeException</tt> is a subclass of
      <tt class="classname">ConstraintDeclarationException</tt>.</p><p>This exception can be raised during validation or when the
      metadata model for the class hosting this constraint is
      requested.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>These exception cases can be determined at compile time by a
        tool such as an annotation processor.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6387"></a>8.4.&nbsp;Group definition:
      <tt class="classname">GroupDefinitionException</tt></h2></div></div><div></div></div><p>When a group definition is illegal,
      <tt class="classname">GroupDefinitionException</tt> is raised. This
      typically arises when a cyclic group dependency is discovered, an
      illegal attribute overriding is defined etc.</p><p><tt class="classname">GroupDefinitionException</tt> is a subclass of
      <tt class="classname">ValidationException</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>These exception cases can be determined at compile time by a
        tool such as an annotation processor.</p></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="terminology"></a>Appendix&nbsp;A.&nbsp;Terminology</h2></div></div><div></div></div><p>This appendix aims at giving an overview on the different key terms
    used through this specification. They are not to be considered formal
    definitions. Formal definitions are to be inferred from the core
    specification.</p><div class="table"><a name="d0e6412"></a><p class="title"><b>Table&nbsp;A.1.&nbsp;terminology</b></p><table summary="terminology" border="1"><colgroup><col><col></colgroup><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody><tr><td>Constraint</td><td>A restriction on a bean instance, the value of a field or
            the value of a JavaBean property</td></tr><tr><td>Constraint declaration</td><td>Assignment of a constraint to a target (bean, field,
            property) for a specific class. Typically by declaring an
            annotation on the target but can also be done through a XML
            deployment descriptor</td></tr><tr><td>Validation routine</td><td><p>Sequence of operations executed by the Bean
            Validation provider to validate a given object
            graph</p></td></tr><tr><td>Constraint definition</td><td>Defines a type of constraint, its attributes and the actual
            constraint validation implementations. Done through annotations.
            The list of constraint validation implementations can be provided
            via XML</td></tr><tr><td>group</td><td>Constraints can belong to one or more group or context.
            Useful to apply a subset of the constraints for a given use case.
            By default, the <tt class="literal">Default</tt> group is used.</td></tr><tr><td>group sequence</td><td>Define a group ordering in the validation process. If a
            given group in the sequence contains one or more failure, the
            following groups in the sequence must be ignored.</td></tr><tr><td>Constraint validation</td><td>Constraint logic algorithm used to determine whether a
            given value passes a constraint or not.</td></tr><tr><td>Constraint validation implementation</td><td>Class implementing the constraint logic and used to
            determine whether a given value pass a constraint or not.</td></tr><tr><td>Bean validation provider</td><td>Product implementing this specification</td></tr><tr><td>Message interpolator</td><td>Algorithm used to build the end user message associated to
            a constraint failure. Typically useful for i18n</td></tr><tr><td>Constraint metadata API</td><td>API exposing the constraints applied to a given bean type.
            Also considered one of the integration points with other JSR or
            frameworks.</td></tr><tr><td>Bootstrap API</td><td>Bootstrapping part of the Bean Validation API producing a
            <tt class="classname">ValidatorFactory</tt>.</td></tr><tr><td>javax.validation.ConstraintValidator</td><td>Interface implemented by a constraint validation
            implementation</td></tr><tr><td>Composing constraint</td><td>Constraint declared on another constraint definition. When
            the main constraint is validated, the composing constraints are
            validated too.</td></tr><tr><td>javax.validation.Validator</td><td>Main API. Holds contracts to validate object graphs</td></tr><tr><td>javax.validation.ConstraintViolation</td><td>Interface describing a given constraint failure on a given
            bean</td></tr></tbody></table></div><p></p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="standard-resolver-messages"></a>Appendix&nbsp;B.&nbsp;Standard ResourceBundle messages</h2></div></div><div></div></div><p>The properties listed below are resolved by the default message
    interpolator.</p><pre class="programlisting">javax.validation.constraints.Null.message=must be null
javax.validation.constraints.NotNull.message=must not be null
javax.validation.constraints.AssertTrue.message=must be true
javax.validation.constraints.AssertFalse.message=must be false
javax.validation.constraints.Min.message=must be greater than or equal to {value}
javax.validation.constraints.Max.message=must be less than or equal to {value}
javax.validation.constraints.Size.message=size must be between {min} and {max}
javax.validation.constraints.Digits.message= \
    numeric value out of bounds (&lt;{integer} digits&gt;.&lt;{fraction} digits&gt; expected)
javax.validation.constraints.Past.message=must be a past date
javax.validation.constraints.Future.message=must be a future date
javax.validation.constraints.Pattern.message=must match the following regular expression: {regexp}</pre></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-methodlevelvalidation"></a>Appendix&nbsp;C.&nbsp;Proposal for method-level validation</h2></div></div><div></div></div><p>This proposition has not been integrated into the core specification
    and is not part of it. It remains here for archaeological purposes and
    will be seriously considered for a future revision of this specification.
    This proposal is likely to be a bit out of sync with the rest of the
    specification artifacts.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Bean Validation providers are free to implement this proposal as a
      specific extension. Such specific extension could for example be
      accessed via the use of the <tt class="methodname">Validator.unwrap</tt>
      method.</p></div><p>A popular demand was to provide a method and parameter level
    validation mechanism reusing the constraint descriptions of the
    specification. This set of APIs is meant to be used by interceptor
    frameworks such as:</p><div class="itemizedlist"><ul type="disc"><li><p>application frameworks like JSR-299</p></li><li><p>component frameworks like Enterprise Java Beans</p></li><li><p>aspect based frameworks</p></li></ul></div><p>These frameworks can call the validation APIs to validate either the
    parameter list or the returned value of a method when such method is
    called. More precisely, validation occurs around a method
    invocation.</p><p>This extension of the Bean Validation API allows to reuse the core
    engine as well as the constraint definition and declaration for such
    method level validations.</p><p>The following APIs are added to
    <tt class="classname">Validator</tt>.</p><pre class="programlisting">public interface Validator {
    // [...]
    
    
    /**
     * Validate each parameter value based on the constraints described on
     * the parameters of &lt;code&gt;method&lt;/code&gt;.
     *
     * @param clazz class hosting the method
     * @param method the method whose parameters are currectly validated
     * @param parameterValues the parameter values passed to the method for invocation
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the method does not belong to &lt;code&gt;T&lt;/code&gt;
     *         or if the Object[] does not match the method signature
     */
    &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateParameters(Class&lt;T&gt; clazz, Method method,
                                                       Object[] parameterValues,
                                                       Class&lt;?&gt;... groups);

    /**
     * Validate the parameter value based on the constraints described on
     * the parameterIndex-th parameter of &lt;code&gt;method&lt;/code&gt;.
     *
     * @param clazz class hosting the method
     * @param method the method whose parameters are currectly validated
     * @param parameterValue the parameter value passed to the parameterIndex-t parameter of method
     * @param parameterIndex parameter index of the parameter validated in method
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the method does not belong to &lt;code&gt;T&lt;/code&gt;
     *         or if prameterIndex is out of bound
     */
    &lt;T&gt; Set&lt;ConstraintViolation&gt; validateParameter(Class&lt;T&gt; clazz, Method method,
                                                   Object parameterValue,
                                                   int parameterIndex, Class&lt;?&gt;... groups);

    /**
     * Validate each parameter value based on the constraints described on
     * &lt;code&gt;method&lt;/code&gt;.
     *
     * @param clazz class hosting the method
     * @param method the method whose result is validated
     * @param returnedValue the value returned by the method invocation
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the method does not belong to &lt;code&gt;T&lt;/code&gt;
     */
    &lt;T&gt; Set&lt;ConstraintViolation&gt; validateReturnedValue(Class&lt;T&gt; clazz, Method method,
                                                       Object returnedValue, Class&lt;?&gt;... groups);

    /**
     * Validate each parameter value based on the constraints described on
     * the parameters of &lt;code&gt;constructor&lt;/code&gt;.
     *
     * @param clazz class hosting the constructor
     * @param constructor the constructor whose parameters are currectly validated
     * @param parameterValues the parameter values passed to the constructor for invocation
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the constructor does not belong to &lt;code&gt;T&lt;/code&gt;
     *         or if the Object[] does not match the constructor signature
     */
    &lt;T&gt; Set&lt;ConstraintViolation&gt; validateParameters(Class&lt;T&gt; clazz, Constructor constructor,
                                                    Object[] parameterValues, Class&lt;?&gt;... groups);

    /**
     * Validate the parameter value based on the constraints described on
     * the parameterIndex-th parameter of &lt;code&gt;constructor&lt;/code&gt;.
     *
     * @param clazz class hosting the constructor
     * @param constructor the method whose parameters are currectly validated
     * @param parameterValue the parameter value passed to the
     *                       parameterIndex-th parameter of constructor
     * @param parameterIndex parameter index of the parameter validated in constructor
     * @param groups groups targeted for validation
     *
     * @return set of constraint violations
     *
     * @throws IllegalArgumentException if the constructor does not belong to &lt;code&gt;T&lt;/code&gt;
     *         or if prameterIndex is out of bound
     */
    &lt;T&gt; Set&lt;ConstraintViolation&gt; validateParameter(Class&lt;T&gt; clazz, Constructor constructor,
                                                   Object parameterValue, int parameterIndex,
                                                   Class&lt;?&gt;... groups);</pre><p>The constraints declarations evaluated are the constraints hosted on
    the parameters of the method or constructor. If
    <tt class="classname">@Valid</tt> is placed on a parameter, constraints
    declared on the object itself are considered.</p><p><tt class="methodname">validateReturnedValue</tt> evaluates the
    constraints hosted on the method itself. If <tt class="classname">@Valid</tt>
    is placed on the method, the constraints declared on the object itself are
    considered.</p><pre class="programlisting">public @NotNull String saveItem(@Valid @NotNull Item item, @Max(23) BigDecimal price)</pre><p>In the previous example,</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">item</tt> is validated against
        <tt class="classname">@NotNull</tt> and all the constraints it
        hosts</p></li><li><p><tt class="literal">price</tt> is validated against
        <tt class="classname">@Max(23)</tt></p></li><li><p>the result of <tt class="methodname">saveItem</tt> is validated
        against <tt class="classname">@NotNull</tt></p></li></ul></div><p>Note that the Bean Validation specification does not trigger the
    validation call. An external framework is responsible for calling one of
    the <tt class="methodname">validateParameters</tt>,
    <tt class="methodname">validateParameter</tt> and
    <tt class="methodname">validateReturnedValue</tt> methods at the appropriate
    time.</p><p>For completeness, Bean Validation exposes metadata for constraints
    hosted on parameters and methods.</p><pre class="programlisting">public interface ParameterDescriptor extends ElementDescriptor { 
    boolean isCascaded(); 
    int getIndex(); 
} 

public interface MethodDescriptor extends ElementDescriptor { 
    List&lt;ParameterDescriptor&gt; getParameterDescriptors(); //index aligned 
    boolean isCascaded(); 
} 

public interface ConstructorDescriptor extends ElementDescriptor { 
    List&lt;ParameterDescriptor&gt; getParameterDescriptors(); //index aligned 
} 

public interface BeanDescriptor { 
    MethodDescriptor getConstraintsForMethod(Method); 
    MethodDescriptor getConstraintsForConstructor(Constructor); 
    Set&lt;String&gt; getConstrainedProperties(); 
    Set&lt;Method&gt; getConstrainedMethods(); 
    Set&lt;Constructor&gt; getConstrainedConstructors(); 
} </pre></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-jpa"></a>Appendix&nbsp;D.&nbsp;Java Persistence 2.0 integration</h2></div></div><div></div></div><p>Integration with Java Persistence is described in the Java
    Persistence 2 specification (JSR-317). Persistence frameworks are
    encouraged to mimic the integration work done with Java
    Persistence.</p><p>While not specified by this specification or the Java Persistence
    2.0 specification, Persistence Providers are encouraged to make use of
    Bean Validation constraint metadata when generating DDL schemas. The
    proposal is as followed.</p><pre class="programlisting">Ideas explored and not standardized

Java Persistence consumes Bean Validation (BV) metadata to enhance persistence property 
metadata.

A Persistence provider must use the BV metadata of a given list of groups. 
The default group evaluated is Default (default BV group). Groups evaluated 
can be overridden by a property. 
This property contains the comma separated groups (fully qualified class name).

For each entity, apply the following algorithm. 
For each persistent property in a given entity: 
 - extract the list of BV constraints (including the composing constraints) 
 - determine the subset of applicable constraints 
    (i.e. constraints understood by the persistence provider)
 - apply these constraints on the persistent property metadata 
 - if the property type is an embeddable object or a collection 
of embeddable objects, apply the algorithm on the embeddable object properties

The list of constraints that must be understood by persistence providers are
as followed:
 - @NotNull should be considered equivalent to @Column(nullable=false) / 
     @JoinColumn(nullable=false)
 - @Size.max should be considered equivalent to @Column.length 
     for String properties 
 - @Digits (which contains integer and fraction) should be considered 
     equivalent to @Column.precision = integer+fraction, 
     @Column.scale = fraction for decimal columns

The BV annotation metadata should have priority over JPA metadata 
(JPA has no sensible "unset" values on their annotations).

Question: should we add @Unique that would map to @Column(unique=true)? 
@Unique cannot be tested at the Java level reliably but could generate
a database unique constraint generation. @Unique is not part 
of the BV spec today.

Persistence Provider should optionally recognize and try to apply the 
following constraints as well:
 - @Min / @Max on numeric columns (TODO String too?)
 - @Future / @Past on temporal columns
 - @Size for collections and array (not sure it is feasible).

Persistence Providers can also apply non standard constraints to their metadata model. 
For example, provider ACME might recognize and understand @com.acme.validation.Email 
and apply it to the database model.

While most high level constraints will not be recognize, the BV built-in constraints 
will be the common language spoken by Persistence Providers. Any high level constraint 
can be composed of more modular constraints (constraint composition).

* additional proposal
In case of a constraint violation report detected and generated by the database 
(not null, etc), the Java persistence provider catches this report and translates 
it into a BV error report. From the perspective of the application, constraint 
errors are viewed through a unified layer. BV must provide some API to create a 
constraint violation error (constraintDescriptor.createConstraintViolation(...)).

While this proposal has a lot of value-add, I wonder how difficult it can be to 
implement this in persistence providers.

Provide a way to disable BV metadata use by a persistence provider (property based).</pre><p>This is not an endorsement of the Java Persistence expert group or
    the Bean Validation expert group. Such approach may nor may not be
    standardized in the future. Such integration should not be considered
    portable.</p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-jsf"></a>Appendix&nbsp;E.&nbsp;Java Server Faces 2.0 integration</h2></div></div><div></div></div><p>Integration with Java Server Faces is described in the Java Server
    Faces 2 specification (JSR-314). Presentation frameworks are encouraged to
    study the integration work done with JSF 2.</p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-ee"></a>Appendix&nbsp;F.&nbsp;Proposal for Java EE integration</h2></div></div><div></div></div><p>This proposal is being discussed with the EE expert group. It
    proposes a way to smoothly integrates Bean Validation to the platform.
    This proposition is the result of the work done on JSF and JPA
    integrations.</p><p>Java Persistence and Java Server Faces have deep integration
    proposals with Bean Validation. Java EE Connector Architecture uses Bean
    Validation to validate particular artifacts.</p><p></p><p></p><p>TODO: This section is outdated. See the latest version in the Java
    EE 6 specification.</p><p><tt class="classname">Validator</tt> and
    <tt class="classname">ValidatorFactory</tt> are very good candidates for
    injectable Java EE resources (<tt class="classname">ValidatorFactory</tt> is
    responsible for providing <tt class="classname">Validator</tt> instances which
    executes the validation logic). To tie everything together in a unified
    way for the Java EE application developer, some integration at the Java EE
    level would be beneficial.</p><p>A <tt class="classname">ValidatorFactory</tt> is built by the EE
    container and exposed to applications as well as services like JPA, JSF
    and Java EE Connectors (this imply a
    <tt class="classname">ValidatorFactory</tt> must be built and ready before
    these services). While not required, it is recommended to cache and share
    the same <tt class="classname">ValidatorFactory</tt> for a given deployment
    unit. <span class="emphasis"><em>Should we mandate it?</em></span>.</p><p>The container passes the <tt class="classname">ValidatorFactory</tt>
    instance to the JPA provider via the configuration Map of
    <tt class="code">PersistenceProvider.createContainerEntityManagerFactory(PersistenceUnitInfo,
    Map)</tt>. The property name is
    <tt class="literal">javax.persistence.validation.factory</tt>
    (<tt class="literal">Persistence.VALIDATOR_FACTORY</tt>).</p><p>The container places the <tt class="classname">ValidatorFactory</tt>
    instance under the following JNDI name. JSF 2 implementations are required
    to look in this entry for any <tt class="classname">ValidatorFactory</tt> and
    use it.</p><p>In addition, <tt class="classname">Validator</tt> and
    <tt class="classname">ValidatorFactory</tt> should be considered as Java EE
    resources: injection aware services should allow injection of
    <tt class="classname">Validator</tt> instances as well as
    <tt class="classname">ValidatorFactory</tt> instances.
    <tt class="classname">@Resource</tt> is used for this. If
    <tt class="classname">Validator</tt> instances are injected, the default
    validation context is used. In other words,
    <tt class="classname">Validator</tt> are provided by
    <tt class="code">validatorFactory.getValidator()</tt>. The factory is available for
    the lifetime of the deployment.</p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="changelog"></a>Appendix&nbsp;G.&nbsp;Changelog</h2></div></div><div></div></div><pre class="programlisting">1.0.0 final (2009-10-12)
------------------------

** Bug
    * [BVAL-181] - Fix some namespace issues in validation-configuration-1.0.xsd


** Improvement
    * [BVAL-182] - Add getDefaultTraversableResolver and getDefaultConstraintValidatorFactory to Configuration
    * [BVAL-183] - Add getTraversableResolver and getConstraintValidatorFactory to ValidatorFactory
    * [BVAL-184] - Replace Red Hat Middleware LLC to Red Hat, Inc. and/or its affiliates
    * [BVAL-186] - Clarify method names on the constraint violation builder DSL of ConstraintValidatorContext
    * [BVAL-187] - Imply that ConstraintViolation is serializable if entities are serializable

** New Feature
    * [BVAL-185] - Allow overriding of ConstraintValidatorFactory when creating a Validator
    * [BVAL-190] - Add methods to filter ConstraintDescriptor per groups, target and scope


** Task
    * [BVAL-132] - Define behaviour for BeanDescriptor.getConstraintsForProperty(null)



1.0.CR5 (2009-08-27)
--------------------

** Bug
    * [BVAL-173] - Fix typo getUnorderdConstraintDescriptorsMatchingGroups =&gt; getUnorderedConstraintDescriptorsMatchingGroups
    * [BVAL-177] - Payload of composed constraints are ignored, the main constraint payload is propagated
    * [BVAL-178] - Add payload to the XML schema
    * [BVAL-180] - ConstraintDescriptor.getPayload() should return Set&lt;Class&lt;? extends Payload&gt;&gt; not Set&lt;Class&lt;Payload&gt;&gt;


** Improvement
    * [BVAL-174] - clearer default message for assertTrue and assertFalse
    * [BVAL-179] - Rename ConstraintPayload to Payload



1.0.CR4 Unpublished release
---------------------------



1.0.CR3 Proposed Final Draft 2 (2009-07-08)
-------------------------------------------

** Bug
    * [BVAL-144] - validation-configuration.xsd property element does not extend basic string type preventing Oxygen to be happy
    * [BVAL-159] - Fix example 3.8 on object graph validation 


** Improvement
    * [BVAL-143] - Describe path with an object model
    * [BVAL-147] - Support for unbounded wildcards in ConstraintValidator
    * [BVAL-148] - Built-in constraints annotations now annotated with @Constraint(validatedBy={})
    * [BVAL-151] - TraversableResolver#isTraversable can receive null traversableObject when valudateValue is called
    * [BVAL-152] - TraversableResolver should differentiate reachability and cascadability
    * [BVAL-153] - Generify ConstraintValidatorException
    * [BVAL-154] - Iterable is a superclass of all collection, clarify it's interaction with @Valid
    * [BVAL-155] - ignore-annotation is not inherited hierarchically: make that explicit
    * [BVAL-156] - Pattern.Flag takes the JDK flag int at construction time
    * [BVAL-157] - Add [] to non-indexed iterable path 
    * [BVAL-158] - Clarify that @Valid is orthogonal to the idea of group
    * [BVAL-160] - rename message template key as [f.q.c.n of the constraint].message
    * [BVAL-162] - Move metadata classes to the metadata package (BeanDescriptor, ElementDescriptor, PropertyDescriptor, ConstraintDescriptor)
    * [BVAL-164] - Validation.byProvider now accept the provider implementation class
    * [BVAL-166] - IllegalArgumentException raised on BeanDescriptor.getConstraintsForProperty and Validator.getConstraintsForClass
    * [BVAL-167] - Recommend f.q.c.n.message for resource bundle keys and migrate examples
    * [BVAL-169] - Rename ElementDescriptor.getType to getElementClass
    * [BVAL-170] - Let built-in annotations to support ElementType.PARAMETER and ElementType.CONSTRUCTOR

** New Feature
    * [BVAL-149] - Provide access to the ValidationProviderResolver via BootstrapState
    * [BVAL-150] - Add ConstraintViolation.getRootBeanClass
    * [BVAL-161] - Add unwrap methods to ValidatorFactory and Validator
    * [BVAL-163] - Add support for constraint payload
    * [BVAL-168] - Return the list of matching ConstraintDescriptor for a given set of groups
    * [BVAL-172] - Provide ConstraintDescriptor#getPayload



1.0.CR2 Unpublished release
---------------------------



1.0.CR1 Proposed Final Draft (2009-03-16)
-----------------------------------------


** Bug
    * [BVAL-118] - ConstraintDescriptor.getGroups() returns Default if no group is declared on the constraint
    * [BVAL-125] - @Size.min default value should be 0


** Improvement
    * [BVAL-32] - Describe what is happening when a composition is not consistent
    * [BVAL-50] - Be consistent in the spec, use @author or not
    * [BVAL-54] - Specify that constraints on non getter methods are ignored (if BVAL-36 is not accepted)
    * [BVAL-72] - Validating an object multiple times if in a different branch of the graph
    * [BVAL-86] - Default TraversableResolver is JPA aware
    * [BVAL-88] - Improvement on MessageInterpolator
    * [BVAL-91] - Rename Constraint related classes to improve readability
    * [BVAL-95] - @Size should support Map
    * [BVAL-96] - Support byte in @Min/@Max
    * [BVAL-106] - Constraintdescriptor.getConstraintValidatorClasses() should return a List, not an array
    * [BVAL-114] - Relax property names in ConstraintValidatorContext
    * [BVAL-120] - Rename ConstraintViolation getRawMessage=&gt;getMessageTemplate, getInterpolatedMessage=&gt;getMessage
    * [BVAL-122] - Rename @GroupSequence.sequence to @GroupSequence.value
    * [BVAL-126] - Define group sequence logic more formally and eliminate corner cases
    * [BVAL-129] - Clarify ConstraintValidatorContext propertyPath generation
    * [BVAL-130] - Make ConstraintDescriptor generic: ConstraintDescriptor&lt;T extends Annotation&gt;
    * [BVAL-131] - Provide object graph navigation determinism
    * [BVAL-134] - @Valid accepts objects implementing Iterable 
    * [BVAL-135] - Remove DefaultValidationProviderResolver from the public API
    * [BVAL-136] - Add Context object for MessageInterpolator
    * [BVAL-137] - prefix for message template key is constraint. instead of validator.
    * [BVAL-138] - Rename OverridesParameter to OverridesAttribute
    * [BVAL-139] - Remove @OverridesParameters and use the inner class mode (OverridesAttribute.LIst)
    * [BVAL-140] - BeanDescriptor.getConstrainedProperties() returns Set&lt;PropertyDescriptor&gt;
    * [BVAL-141] - Rename ConstraintDescriptor.getParameters() to getAttributes()

** New Feature
    * [BVAL-52] - Define the exception hierarchy and rules
    * [BVAL-55] - Exception policy
    * [BVAL-65] - Additional built-in constraints
    * [BVAL-98] - Type-safe ConstraintValidator
    * [BVAL-100] - Support XML mapping overriding
    * [BVAL-102] - Support META-INF/validation.xml
    * [BVAL-119] - Introduce @Pattern for regexp
    * [BVAL-121] - Define built-in constraints plural forms
    * [BVAL-123] - Add ConstraintViolationException
    * [BVAL-124] - Introduce backslash as escaping character
    * [BVAL-142] - @Min/@max no longer accept float/double and introduce @DecimalMin/@DecimalMax


** Task
    * [BVAL-24] - What should be done when multiple META-INF/validation.xml are found?
    * [BVAL-117] - Specify behaviour of ConstraintValidator.initalize in the case of inconsistent values in constraint parameters
    * [BVAL-127] - Remove ConstraintViolation.getGroups()
    * [BVAL-128] - Clarify invalid cases for validateProperty / validateValue on proeprtyName being empty or null
    * [BVAL-133] - Remove JPA and JSF integration proposals




1.0.Beta2 Public Draft (2008-12-15)
-----------------------------------


** Bug
    * [BVAL-6] - Wrong example in validation methods section
    * [BVAL-17] - Validator&lt;A&gt;.validate(b) where b:B and B extends A should validate B. Metadata APIs are specific to A
    * [BVAL-42] - Names of message keys in spec inconsistent
    * [BVAL-45] - Typo at ConstraintDescriptor.getContstraintClass()


** Improvement
    * [BVAL-29] - Types should be determined at runtime
    * [BVAL-33] - Should ConstraintDescriptor.getConstraintImplementation() replaced by .getConstraintImplementationClass()?
    * [BVAL-40] - Rename InvalidConstraint to ConstraintViolation
    * [BVAL-48] - Add a way to access the default message resolver
    * [BVAL-49] - Mark metadata classes as immutable
    * [BVAL-59] - Rethink the group sequence inheritance rules
    * [BVAL-60] - ConstraintViolation points to the corresponding ConstraintDescriptor
    * [BVAL-68] - Specify that static methods and fields are not validated
    * [BVAL-73] - Rename ConstraintViolation.getBeanClass() to CV. getRootClass() or simply remove it
    * [BVAL-78] - Forbid a Validation implementation to modify the state of the object being validated

** New Feature
    * [BVAL-30] - Define validation Context to be passed to constraint implementation calls
    * [BVAL-36] - Validation of method parameters and returned values
    * [BVAL-67] - Allow MessageResolver to be Localizable
    * [BVAL-71] - Should we have group aggregation?
    * [BVAL-76] - Expose the raw message to ConstraintViolation
    * [BVAL-79] - Groups are now Type based rather than String based
    * [BVAL-81] - Provide a TraversableResolver contract


** Task
    * [BVAL-1] - Remove references to 'beancheck' in the spec
    * [BVAL-3] - Replace array return types with Sets
    * [BVAL-4] - Return value for @NotEmpty for null values
    * [BVAL-5] - Change order of exmaple classes in Book/Author example
    * [BVAL-7] - Use of example in ConstraintFactory section (2.4)
    * [BVAL-8] - StandardConstraint description (2.5)
    * [BVAL-23] - Make Validator&lt;T&gt; thread-safe</pre></div></div></body></html>