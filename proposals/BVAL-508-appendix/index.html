<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<title>Value extraction for cascaded validation and type argument constraints (BVAL-508)</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
body{-webkit-font-smoothing:antialiased}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
body{tab-size:4}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="appendix-value-extraction"><a class="anchor" href="#appendix-value-extraction"></a>Appendix A: Value extraction for cascaded validation and type argument constraints (BVAL-508)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This appendix describes the current work-in-progress around the retrieval of values to be validated during cascaded validation (e.g. <code>List&lt;@Valid Order&gt; orders</code>)
and evaluation of type argument constraints (e.g. <code>Optional&lt;@Email String&gt; email</code>)
It is based on the original <a href="http://beanvalidation.org/proposals/BVAL-508/">proposals for BVAL-508</a>.</p>
</div>
<div class="sect2">
<h3 id="motivation"><a class="anchor" href="#motivation"></a>Motivation</h3>
<div class="paragraph">
<p>Value extraction is needed when constraints are applied to the element(s) stored within a container type.
There are two categories:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cascaded validation of iterables, maps and arrays as triggered via <code>@Valid</code>: <code>@Valid List&lt;Order&gt; orders</code>; in this case all the values stored in the list must be extracted so each can be validated</p>
</li>
<li>
<p>Validation of type argument constraints as enabled by Java 8: <code>Optional&lt;@Email String&gt; email</code> or <code>Property&lt;@Min(1) Integer&gt; value</code>;
in this case, e.g. the wrapped <code>String</code> and <code>Integer</code> values must be extracted so the <code>@Email</code> and <code>@Min</code> constraints can be applied</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both cases can also overlap: <code>List&lt;@RetailOrder @Valid Order&gt; retailOrders</code>.</p>
</div>
<div class="paragraph">
<p>Type argument constraints and pluggable extractors will also make cascaded validation more flexible.
As of BV 1.1, there was a fixed set of data types supported by cascaded validation mandated by the spec (<code>Iterable</code>, arrays, <code>Map</code> (only the values would be validated).
This excludes use cases such as custom collection types (e.g. Guava&#8217;s multi-map),
validation of map keys or collection types of other JVM languages (such as Ceylon&#8217;s collection framework).</p>
</div>
<div class="paragraph">
<p>Allowing to put <code>@Valid</code> on type parameters allows to express the subject of cascaded validation more specifically:
<code>Map&lt;@Valid AddressType, @Valid Address&gt; addresses</code> would describe that both, map keys and values, should be validated.</p>
</div>
</div>
<div class="sect2">
<h3 id="requirements"><a class="anchor" href="#requirements"></a>Requirements</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Constraints can be applied to type arguments (of bean properties, but also executable parameters and method return values): <code>Property&lt;@Min(1) Integer&gt; value</code></p>
</li>
<li>
<p>Individual type parameters can be marked for cascaded validation: <code>Map&lt;@Valid AddressType, Address&gt; addresses</code></p>
</li>
<li>
<p>How values are retrieved must be customizable by means of a pluggable value extractor mechanism, with a set of defined default extractors</p>
</li>
<li>
<p>Sometimes constraints should apply to a value wrapped by a container type, but there is no type parameter to put the constraints to.
JavaFX&#8217;s <code>Property</code> hierarchy is the most prominent example: <code>@Email StringProperty emailProperty</code>.
In such case the value should be implicitly extracted from the container if unambiguously doable.</p>
</li>
<li>
<p>Allow to configure type argument constraints and cascades via XML mappings</p>
</li>
<li>
<p>Expose meta-data on type argument constraints and cascades in the constraint metadata API</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="non-requirements"><a class="anchor" href="#non-requirements"></a>Non-requirements</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Constraints on type uses in local variables, invocations etc: <code>@NotNull String name = "Emmanuel";</code>, <code>new @NonEmpty @Readonly List&lt;String&gt;(myNonEmptyStringSet)</code></p>
</li>
<li>
<p>constraints on type uses in type definitions:</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">CustList</span> <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">List</span>&lt;<span style="color:#007">@NotNull</span> Customer&gt; {
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="solution"><a class="anchor" href="#solution"></a>Solution</h3>
<div class="paragraph">
<p>Value retrieval for cascaded validation and validation of type argument constraints is done via the <code>ValueExtractor</code> API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="JAVA">Unresolved directive in BVAL-<span style="color:#00D">508</span>-appendix.asciidoc - include::{validation-api-source-dir}javax/validation/valueextraction/ValueExtractor.java[lines=<span style="color:#00D">7</span>.<span style="color:#60E">.8</span>;<span style="color:#00D">15</span>..-<span style="color:#00D">1</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>An extractor is tied to one specific type parameter of the type from which it extracts values. The <code>@ExtractedValue</code> annotation is used to mark that type parameter.</p>
</div>
<div class="paragraph">
<p>As an example, this is how the implementation of the list extractor may look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">ListValueExtractor</span> <span style="color:#088;font-weight:bold">implements</span> ValueExtractor&lt;<span style="color:#0a8;font-weight:bold">List</span>&lt;<span style="color:#007">@ExtractedValue</span> ?&gt;&gt; {

        <span style="color:#007">@Override</span>
        <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> extractValues(<span style="color:#0a8;font-weight:bold">List</span>&lt;?&gt; originalValue, ValueReceiver receiver) {
                <span style="color:#080;font-weight:bold">for</span> ( <span style="color:#339;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; originalValue.size(); i++ ) {
                        receiver.indexedValue( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">&lt;iterable element&gt;</span><span style="color:#710">&quot;</span></span>, i, originalValue.get( i ) );
                }
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The right callback methods (<code>indexedValue()</code>, <code>keyedValue()</code> etc.) must be called in order to allow for proper construction of the property path as per the rules laid out in the BV 1.1 spec.</p>
</div>
<div class="paragraph">
<p>If a non-null value is passed for <code>nodeName</code>, a path node of type <code>CONTAINER_ELEMENT</code> will be appended to the property path.
That&#8217;s desirable for collection types for instance. If null is passed, no node will be appended,
resulting in the same path as if the constraint had been given on the element itself instead of a type parameter.
That&#8217;s desirable for pure "wrapper types" such as <code>Optional</code>.</p>
</div>
<div class="sect3">
<h4 id="extractedvalue"><a class="anchor" href="#extractedvalue"></a>@ExtractedValue</h4>
<div class="paragraph">
<p>The <code>@ExtractedValue</code> annotation is used to denote the element extracted by a given value extractor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="JAVA">Unresolved directive in BVAL-<span style="color:#00D">508</span>-appendix.asciidoc - include::{validation-api-source-dir}javax/validation/valueextraction/ExtractedValue.java[lines=<span style="color:#00D">7</span>.<span style="color:#60E">.8</span>;<span style="color:#00D">15</span>..-<span style="color:#00D">1</span>]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@ExtractedValue</code> annotation must be specified exactly once for a value extractor type.
Thus the following extractor definition is illegal as it specifies <code>@ExtractedValue</code> several times:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">DoubleExtractor</span> <span style="color:#088;font-weight:bold">implements</span> ValueExtractor&lt;Multimap&lt;<span style="color:#007">@ExtractedValue</span> ?, <span style="color:#007">@ExtractedValue</span> ?&gt;&gt; { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>When defined for a generic type, only wildcard type arguments may be annotated with <code>@ExtractedValue</code>.
Thus the following extractor definition is illegal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">StringListValueExtractor</span> <span style="color:#088;font-weight:bold">implements</span> ValueExtractor&lt;<span style="color:#0a8;font-weight:bold">List</span>&lt;<span style="color:#007">@ExtractedValue</span> <span style="color:#0a8;font-weight:bold">String</span>&gt;&gt; { ... }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This implies that there may not be more than one extractor for a given generic type.
I.e. there can be an extractor for <code>List&lt;?&gt;</code>, but not one for <code>List&lt;String&gt;</code> and one for <code>List&lt;Integer&gt;</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In case an illegal value extractor definition is detected, a <code>ValueExtractorDefinitionException</code> is raised.</p>
</div>
<div class="paragraph">
<p>If a value extractor returns the entire extracted type itself
(as it is the case for the built-in extractor for handling any non-collection object associations),
the <code>@ExtractedValue</code> annotation is to be given on the extracted type itself:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">ObjectValueExtractor</span> <span style="color:#088;font-weight:bold">implements</span> ValueExtractor&lt;<span style="color:#007">@ExtractedValue</span> <span style="color:#0a8;font-weight:bold">Object</span>&gt; {

        <span style="color:#007">@Override</span>
        <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> extractValues(<span style="color:#0a8;font-weight:bold">Object</span> originalValue, ValueReceiver receiver) {
                receiver.value( <span style="color:#069">null</span>, originalValue );
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a value extractor returns the elements of an array type,
the <code>@ExtractedValue</code> annotation is to be given for the array type as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">IntArrayValueExtractor</span> <span style="color:#088;font-weight:bold">implements</span> ValueExtractor&lt;<span style="color:#339;font-weight:bold">int</span> <span style="color:#007">@ExtractedValue</span><span style="color:#339;font-weight:bold">[]</span>&gt; {

        <span style="color:#007">@Override</span>
        <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> extractValues(<span style="color:#339;font-weight:bold">int</span><span style="color:#339;font-weight:bold">[]</span> originalValue, ValueReceiver receiver) {
                <span style="color:#080;font-weight:bold">for</span> ( <span style="color:#339;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; originalValue.length; i++ ) {
                        receiver.indexedValue( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">&lt;iterable element&gt;</span><span style="color:#710">&quot;</span></span>, i, originalValue[i] );
                }
        }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Motivation for callback-style API</div>
<div class="paragraph">
<p>Instead of returning the extracted values from the method call, implementations of <code>ValueExtractor</code> pass the extracted values to the given receiver callback.
This helps to avoid object allocations and allows to handle the case of a single extracted value (<code>Optional&lt;T&gt;</code>) and multiple extracted values (<code>List&lt;T&gt;</code>) in a uniform fashion.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="extensions-to-code-node-code"><a class="anchor" href="#extensions-to-code-node-code"></a>Extensions to <code>Node</code></h4>
<div class="paragraph">
<p>There is a new <code>javax.validation.ElementKind</code>, <code>CONTAINER_ELEMENT</code>.
There is also a new <code>Node</code> sub-type, <code>ContainerElementNode</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#339;font-weight:bold">interface</span> <span style="color:#B06;font-weight:bold">ContainerElementNode</span> <span style="color:#088;font-weight:bold">extends</span> Node {

    <span style="color:#777">/**
     * @return the type of the container the node is placed in, if contained in a container type such as
     * {@code Optional}, {@code List} or an array, {@code null} otherwise
     */</span>
    <span style="color:#0a8;font-weight:bold">Class</span>&lt;?&gt; getContainerClass();

    <span style="color:#777">/**
     * @return the index of the type parameter affected by the violated constraint in the container class
     */</span>
    <span style="color:#0a8;font-weight:bold">Integer</span> getTypeArgumentIndex();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>getContainerClass()</code> and <code>getTypeArgumentIndex()</code> also need to be added to <code>BeanNode</code> and <code>PropertyNode</code> and will return the affected type parameter when violating a class-level or property constraint in the course of cascaded validation of a generic type, such as <code>List</code> or <code>Map</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="default-extractors"><a class="anchor" href="#default-extractors"></a>Default extractors</h4>
<div class="paragraph">
<p>Compatible implementations provide extractors for the following types out of the box. They must invoke the right callback methods in order to ensure path nodes in the described form are appended:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Arrays of objects and all primitive data types</p>
<div class="ulist">
<ul>
<li>
<p><code>@Valid</code> can be given for the array itself or for its component type.
Both will cause the validation of all the array elements</p>
</li>
<li>
<p>If a constraint given for an array&#8217;s component type is validated, a node with the following properties will be added to the path:</p>
<div class="ulist">
<ul>
<li>
<p>name: "&lt;iterable element&gt;"</p>
</li>
<li>
<p>kind: <code>CONTAINER_ELEMENT</code></p>
</li>
<li>
<p>isInIterable: <code>false</code></p>
</li>
<li>
<p>index: the element&#8217;s index</p>
</li>
<li>
<p>key: <code>null</code></p>
</li>
<li>
<p>containerClass: in the case of an array of <code>Object</code>s, <code>Object[]</code>, in the case of an array of primitives, the type of the array (e.g. <code>int[]</code>)</p>
</li>
<li>
<p>typeArgumentIndex: <code>null</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>java.util.Iterable</code> - excluding the case of <code>java.util.List</code> described below</p>
<div class="ulist">
<ul>
<li>
<p>When <code>@Valid</code> is given on the iterable element itself, the element and all its entries will be validated; this is to grant backwards compatibility with BV 1.1</p>
</li>
<li>
<p>When <code>@Valid</code> is given on the type parameter of an iterable element, all the entries will be validated.</p>
</li>
<li>
<p>When validating a type argument constraint for <code>Iterable</code>, a node with the following properties will be added to the path:</p>
<div class="ulist">
<ul>
<li>
<p>name: "&lt;iterable element&gt;"</p>
</li>
<li>
<p>kind: <code>CONTAINER_ELEMENT</code></p>
</li>
<li>
<p>isInIterable: <code>true</code></p>
</li>
<li>
<p>index: the element&#8217;s index if the iterable is of type <code>List</code> or a subtype thereof; <code>null</code> otherwise</p>
</li>
<li>
<p>key: <code>null</code></p>
</li>
<li>
<p>containerClass: <code>Iterable</code></p>
</li>
<li>
<p>typeArgumentIndex: <code>0</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>java.util.List</code></p>
<div class="ulist">
<ul>
<li>
<p>When <code>@Valid</code> is given on the iterable element itself, the element and all its entries will be validated; this is to grant backwards compatibility with BV 1.1</p>
</li>
<li>
<p>When <code>@Valid</code> is given on the type parameter of an iterable element, all the entries will be validated.</p>
</li>
<li>
<p>When validating a type argument constraint for <code>List</code>, a node with the following properties will be added to the path:</p>
<div class="ulist">
<ul>
<li>
<p>name: "&lt;iterable element&gt;"</p>
</li>
<li>
<p>kind: <code>CONTAINER_ELEMENT</code></p>
</li>
<li>
<p>isInIterable: <code>true</code></p>
</li>
<li>
<p>index: the element&#8217;s index</p>
</li>
<li>
<p>key: <code>null</code></p>
</li>
<li>
<p>containerClass: <code>List</code></p>
</li>
<li>
<p>typeArgumentIndex: <code>0</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>java.util.Map</code></p>
<div class="ulist">
<ul>
<li>
<p>When <code>@Valid</code> is given on the map element itself, the element and all its values will be validated; this is to grant backwards compatibility with BV 1.1</p>
</li>
<li>
<p>When <code>@Valid</code> is given on the key type parameter, the map keys will be validated</p>
</li>
<li>
<p>When <code>@Valid</code> is given on the value type parameter, the map values will be validated</p>
</li>
<li>
<p>When validating a constraint on the key type argument of <code>Map</code>, a node with the following properties will be added to the path:</p>
<div class="ulist">
<ul>
<li>
<p>name: "&lt;map key&gt;"</p>
</li>
<li>
<p>kind: <code>CONTAINER_ELEMENT</code></p>
</li>
<li>
<p>isInIterable: <code>true</code></p>
</li>
<li>
<p>index: <code>null</code></p>
</li>
<li>
<p>key: key</p>
</li>
<li>
<p>containerClass: <code>Map</code></p>
</li>
<li>
<p>typeArgumentIndex: <code>0</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>When validating a constraint on the value type argument of <code>Map</code>, a node with the following properties will be added to the path:</p>
<div class="ulist">
<ul>
<li>
<p>name: "&lt;map value&gt;"</p>
</li>
<li>
<p>kind: <code>CONTAINER_ELEMENT</code></p>
</li>
<li>
<p>isInIterable: <code>true</code></p>
</li>
<li>
<p>index: <code>null</code></p>
</li>
<li>
<p>key: key</p>
</li>
<li>
<p>containerClass: <code>Map</code></p>
</li>
<li>
<p>typeArgumentIndex: <code>1</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>java.util.Optional</code></p>
<div class="ulist">
<ul>
<li>
<p>No node will be appended to the path when validating type argument constraints on <code>Optional</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>javafx.beans.observable.ObservableValue</code></p>
<div class="ulist">
<ul>
<li>
<p>No node will be appended to the path when validating type argument constraints on <code>ObservableValue</code></p>
</li>
<li>
<p>Constraints given on an element of type <code>ObservableValue</code> apply to the wrapped value by default (see <a href="#appendix-valueextraction-wrappedelements">Applying element-level constraints to wrapped elements</a>).</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>java.lang.Object</code></p>
<div class="ulist">
<ul>
<li>
<p>When <code>@Valid</code> is given for an element, the element will be validated</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="examples"><a class="anchor" href="#examples"></a>Examples</h5>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="plugging-in-custom-extractors"><a class="anchor" href="#plugging-in-custom-extractors"></a>Plugging in custom extractors</h4>
<div class="paragraph">
<p>Additional value extractors can be plugged in when bootstrapping a <code>Validator</code> or <code>ValidatorFactory</code>, amending and/or overriding the set of built-in value extractors.
The following ways to do so exist, in descending order of precedence:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Invoking the method <code>ValidatorContext#addValueExtractor(ValueExtractor&lt;?&gt;)</code> (to apply it for a single <code>Validator</code>)</p>
</li>
<li>
<p>Invoking the method <code>Configuration#addValueExtractor(ValueExtractor&lt;?&gt;)</code> (to apply it at the validation factory level)</p>
</li>
<li>
<p>Specifying the fully-qualified class name of one or several extractors in <code>META-INF/validation.xml</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span style="color:#070;font-weight:bold">&lt;value-extractors&gt;</span>
    <span style="color:#070;font-weight:bold">&lt;value-extractor&gt;</span>com.example.MyExtractor<span style="color:#070;font-weight:bold">&lt;/value-extractor&gt;</span>
<span style="color:#070;font-weight:bold">&lt;/value-extractors&gt;</span></code></pre>
</div>
</div>
</li>
<li>
<p>Placing a file named <em>META-INF/services/javax.validation.valueextraction.ValueExtractor</em> on the classpath,
with the fully-qualified name(s) of one or more extractor implementations as its contents (i.e. employing the Java service loader mechanism)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A value extractor for a given type and extracted type parameter specified at a higher level overrides any other extractors for the same type and extracted type given at lower levels.
If e.g. a value extractor defined as <code>class MyListValueExtractor implements ValueExtractor&lt;List&lt;@ExtractedValue ?&gt;&gt; { &#8230;&#8203; }</code> is given via <code>ValidatorContext#addValueExtractor(ValueExtractor&lt;?&gt;)</code>,
it will take precedence over any other value extractor implementing <code>List&lt;@ExtractedValue ?&gt;</code> given via <code>Configuration#addValueExtractor(ValueExtractor&lt;?&gt;)</code>,
<em>META-INF/validation.xml</em> or the service loader mechanism as well as the built-in extractor for <code>List</code> elements.</p>
</div>
</div>
<div class="sect3">
<h4 id="appendix-valueextraction-wrappedelements"><a class="anchor" href="#appendix-valueextraction-wrappedelements"></a>Applying element-level constraints to wrapped elements</h4>
<div class="paragraph">
<p>Sometimes there is no type parameter to put a constraint to, but still constraints should be applied to the wrapped value instead of the annotated element
(a field, property getter, method return value or executable parameter).
JavaFX&#8217;s property hierarchy falls into that category, as it defines specific <code>Property</code> sub-types which are not generic.
As an example, consider a generic type <code>Wrapper&lt;T&gt;</code> and a non-generic sub-type <code>StringWrapper</code> which binds the type parameter <code>&lt;T&gt;</code> to <code>String</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#007">@Email</span> StringWrapper email;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Two defined sub-types of <code>javax.validation.Payload</code> can be used to control the target of validation in such cases via the constraint&#8217;s <code>payload()</code> attribute:</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. <code>Payload</code> types for unwrapping control</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="JAVA">Unresolved directive in BVAL-<span style="color:#00D">508</span>-appendix.asciidoc - include::{validation-api-source-dir}javax/validation/valueextraction/Unwrapping.java[lines=<span style="color:#00D">7</span>.<span style="color:#60E">.8</span>;<span style="color:#00D">11</span>..-<span style="color:#00D">1</span>]</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#007">@Email</span>(payload = Unwrapping.Unwrap.class) StringWrapper email;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Value extractor definitions can be marked with the <code>@UnwrapByDefault</code> annotation so that constraints are automatically applied to the wrapped value if a constraint is found for an element handled by that extractor:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. <code>@UnwrapByDefault</code> annotation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="JAVA">Unresolved directive in BVAL-<span style="color:#00D">508</span>-appendix.asciidoc - include::{validation-api-source-dir}javax/validation/valueextraction/UnwrapByDefault.java[lines=<span style="color:#00D">7</span>.<span style="color:#60E">.8</span>;<span style="color:#00D">16</span>..-<span style="color:#00D">1</span>]</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#007">@UnwrapByDefault</span>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">WrapperExtractor</span> <span style="color:#088;font-weight:bold">implements</span> ValueExtractor&lt;Wrapper&lt;<span style="color:#007">@ExtractedValue</span> ?&gt;&gt; {

        <span style="color:#007">@Override</span>
        <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> extractValues(Wrapper originalValue, ValueReceiver receiver) {
                <span style="color:#777">// ...</span>
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If this extractor was identified as the single most-specific extractor for <code>StringWrapper</code> (see <a href="#appendix-valueextraction-extractorretrieval">Retrieval of extractors</a>), the <code>@Email</code> constraint above would automatically be applied to the wrapped string value.</p>
</div>
<div class="paragraph">
<p>In rare cases it may happen that a constraint should be applied to the wrapped value although an extractor exists.
In this case the <code>Unwrapping.Skip</code> payload type can be specified for that constraint to prevent the unwrapping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#007">@NotNull</span>(payload = Unwrapping.Skip.class) StringWrapper email;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For the sake of readability, when applying constraints to the elements of a generic container type,
it is strongly recommended to put the constraints to the type argument instead of the element itself in conjunction with <code>Unwrapping.Unwrap</code>.
I.e. you should prefer</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#0a8;font-weight:bold">List</span>&lt;<span style="color:#007">@Email</span> <span style="color:#0a8;font-weight:bold">String</span>&gt; emails;</code></pre>
</div>
</div>
<div class="paragraph">
<p>over</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#007">@Email</span>(payload = Unwrapping.Unwrap.class)
<span style="color:#0a8;font-weight:bold">List</span>&lt;<span style="color:#0a8;font-weight:bold">String</span>&gt; emails;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="appendix-valueextraction-extractorretrieval"><a class="anchor" href="#appendix-valueextraction-extractorretrieval"></a>Retrieval of extractors</h4>
<div class="paragraph">
<p>When detecting a type argument constraint or cascade, the applicable extractor is determined as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Select all those value extractors which handle a type parameter that maps to the type argument annotated with the constraint or <code>@Valid</code> annotation;
Example:</p>
<div class="ulist">
<ul>
<li>
<p>Given <code>List&lt;@Email String&gt; emails</code> and considering the default extractors listed above, only the extractors for <code>List</code> and <code>Iterable</code> are selected.
The former handles the type parameter <code>T</code> of type <code>List</code>, which directly maps to the type argument annotated with <code>@Email</code>.
The latter handles the type parameter <code>E</code> of type <code>Iterable</code> which (indirectly) maps to the annotated type argument (as <code>List</code> extends <code>Iterable</code> and binds its type parameter <code>T</code> to <code>E</code> from <code>Iterable</code>).
Other extractors such as the ones for <code>K</code> and <code>V</code> of <code>Map</code> are dismissed, as they handle type parameters not mapping to the annotated type argument</p>
</li>
<li>
<p>Given</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#339;font-weight:bold">interface</span> <span style="color:#B06;font-weight:bold">ConfusingMap</span>&lt;K, V&gt; <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Map</span>&lt;V, K&gt; {}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ConfusingMap&lt;<span style="color:#007">@Email</span> <span style="color:#0a8;font-weight:bold">String</span>, <span style="color:#0a8;font-weight:bold">String</span>&gt; map;</code></pre>
</div>
</div>
<div class="paragraph">
<p>And considering the default extractors listed above, only the extractor for the type parameter <code>V</code> of <code>Map</code> will be selected. This is because the <code>@Email</code> constraint is given for the type argument representing type parameter <code>K</code> of <code>ConfusingMap</code> which maps to type parameter <code>V</code> of <code>Map</code>.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>From the remaining candidate value extractors choose the one which is most specific to the container type declaring the annoted type argument.
An extractor A is more specific than another extractor B if A extracts a subtype of the type extracted by B.
Example:</p>
<div class="ulist">
<ul>
<li>
<p>When obtaining the extractor for type parameter constraint validation, the declared type of the validated element is considered.
This is to be consistent with constraint validator resolution, which is based on the static type of elements, not the runtime type.</p>
</li>
<li>
<p>When obtaining the extractor for cascaded validation, the runtime type of the cascaded element is considered.
This is to be consistent with the rules defined for property path construction which are based on the runtime type.</p>
</li>
<li>
<p>From the two extractors above, the one for <code>List</code> is chosen as <code>List</code> is a subtype of <code>Iterable</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If there are several extractors which are equally specific (e.g. several extractors for <code>List</code>), an <code>UnexpectedTypeException</code> is raised.
TODO: apply rules similar to "ConstraintValidator resolution algorithm" and further clarify wording</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When detecting a regular element-level constraint (i.e. non type argument constraint) the applicable value extractor, if any, is determined as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If the constraint carries the <code>Unwrapping.Skip</code> payload, don&#8217;t apply any value extractor</p>
</li>
<li>
<p>Determine the set of uniquely mapping type parameters declared by the types in the element type&#8217;s type hierarchy; Examples:</p>
<div class="ulist">
<ul>
<li>
<p>element of type <code>java.lang.String</code>: () (empty set)</p>
</li>
<li>
<p>element of type <code>java.lang.Iterable</code>: (T)</p>
</li>
<li>
<p>element of type <code>java.lang.Map</code>: (K, V)</p>
</li>
<li>
<p>element of type <code>java.util.Collection</code>: (E) (as the type parameter <code>E</code> of <code>Collection</code> maps to <code>T</code> of <code>Iterable</code>, only the type parameter of the subtype is considered)</p>
</li>
<li>
<p><code>interface A&lt;T&gt; {}</code>, <code>interface B&lt;U&gt; {}</code>, <code>class C implements A&lt;String&gt;, B&lt;Integer&gt; {}</code>; element of type <code>C</code>: (T, U) (two non mapping type parameters)</p>
</li>
</ul>
</div>
</li>
<li>
<p>If the constraint carries the <code>Unwrapping.Unwrap</code> payload:</p>
<div class="ulist">
<ul>
<li>
<p>If no type parameter or more than one type parameter was found in step 2, raise a <code>ConstraintDeclarationException</code></p>
</li>
<li>
<p>Choose the most specific extractor matching the single type parameter found in step 2</p>
</li>
<li>
<p>If there are several extractors which are equally specific, a <code>ConstraintDeclarationException</code> is raised.</p>
</li>
<li>
<p>If there is exactly one remaining extractor, apply this extractor</p>
</li>
<li>
<p>Otherwise, a <code>ConstraintDeclarationException</code> is raised.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If the constraint neither carries the <code>Unwrapping.Unwrap</code> nor the <code>Unwrapping.Skip</code> payload:</p>
<div class="ulist">
<ul>
<li>
<p>If no type parameter or more than one type parameter was found in step 2, don&#8217;t apply any value extractor</p>
</li>
<li>
<p>Choose the most specific extractor matching the single type parameter found in step 2</p>
</li>
<li>
<p>If there are multiple such extractors, a <code>ConstraintDeclarationException</code> is raised.</p>
</li>
<li>
<p>If there is exactly one remaining extractor and it is marked with <code>UnwrapByDefault</code>, apply this extractor</p>
</li>
<li>
<p>Otherwise, no extractor is applied</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Implementation note</div>
<div class="paragraph">
<p>As extractor retrieval for type parameter constraints is done using the static type of constrained elements,
the retrieval can be done once at initialization time and then be cached.
This is not possible for retrieval of extractors for cascaded validation.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="examples-2"><a class="anchor" href="#examples-2"></a>Examples</h4>
<div class="ulist">
<ul>
<li>
<p>Applying a constraint to the value wrapped by a container type:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Property&lt;<span style="color:#007">@Min</span>(<span style="color:#00D">1</span>) <span style="color:#0a8;font-weight:bold">Integer</span>&gt; value;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>@Valid</code> is not required; the <code>@Min</code> constraint will be validated when the <code>value</code> property is subject to validation.</p>
</div>
</li>
<li>
<p>Applying constraints to each value in a collection type:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#0a8;font-weight:bold">List</span>&lt;<span style="color:#007">@NotNull</span> <span style="color:#007">@Email</span> <span style="color:#0a8;font-weight:bold">String</span>&gt; emails;</code></pre>
</div>
</div>
</li>
<li>
<p>Cascaded validation of the values in a collection type:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#0a8;font-weight:bold">List</span>&lt;<span style="color:#007">@Valid</span> Order&gt; orders;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will validate the constraints on each <code>Order</code> element in the list.</p>
</div>
</li>
<li>
<p>The legacy style for cascaded validation is supported as well:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#007">@Valid</span> <span style="color:#0a8;font-weight:bold">List</span>&lt;Order&gt; orders;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This would also validate any constraints on a custom list type (e.g. <code>MyList#getId()</code>).
TODO: we never clarified that in 1.1. Should it be made explicit?</p>
</div>
</li>
<li>
<p>Map validation with type argument constraints and cascading:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#007">@Valid</span>
<span style="color:#0a8;font-weight:bold">Map</span>&lt;<span style="color:#007">@RegExp</span>(...) <span style="color:#0a8;font-weight:bold">String</span>, <span style="color:#007">@RetailOrder</span> Order&gt; orders;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This would validate the map&#8217;s keys against <code>@RegExp</code>, the map&#8217;s values against <code>@RetailOrder</code> and apply cascaded validation of the map values (as well as the map object itself).</p>
</div>
</li>
<li>
<p>When selecting extractors, type parameters must be thoroughly traced in the hierarchy.
Consider this case where the order of the type parameters of <code>Map</code> is swapped in a sub-type:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">CrazyMap</span>&lt;K, V&gt; <span style="color:#088;font-weight:bold">implements</span> <span style="color:#0a8;font-weight:bold">Map</span>&lt;V, K&gt; { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Example</span> {
    <span style="color:#088;font-weight:bold">private</span> CrazyMap&lt;<span style="color:#007">@RegExp</span>(...) <span style="color:#0a8;font-weight:bold">String</span>, <span style="color:#007">@Min</span>(<span style="color:#00D">0</span>) <span style="color:#0a8;font-weight:bold">Long</span>&gt; crazyMap = ...;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assuming there is no dedicated extractor for <code>CrazyMap</code> but only the default ones for <code>K</code> and <code>V</code> of <code>Map</code>,
extraction for <code>@RegExp</code> must happen via the default map value extractor and extraction for <code>@Min</code> via the default map key extractor.</p>
</div>
<div class="paragraph">
<p>A type parameter in a sub-type may also map to several type parameters in a super-type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#339;font-weight:bold">interface</span> <span style="color:#B06;font-weight:bold">NumericMap</span>&lt;T <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Number</span>&gt; <span style="color:#088;font-weight:bold">extends</span> <span style="color:#0a8;font-weight:bold">Map</span>&lt;T, T&gt; {}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">private</span> NumericMap&lt;<span style="color:#007">@Min</span>(<span style="color:#00D">1</span>) <span style="color:#0a8;font-weight:bold">Integer</span>&gt; integerMap;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@Min</code> constraint is to be applied to the map&#8217;s keys and values as the annotated type parameter maps to <code>K</code> and <code>V</code> of <code>Map</code>.</p>
</div>
</li>
<li>
<p>type argument constraints can be applied to the elements of <code>Object</code> arrays and arrays of any primitive type:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#0a8;font-weight:bold">String</span> <span style="color:#007">@Email</span><span style="color:#339;font-weight:bold">[]</span> emails;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#339;font-weight:bold">int</span> <span style="color:#007">@Min</span>(<span style="color:#00D">1</span>) <span style="color:#339;font-weight:bold">[]</span> positiveNumbers;</code></pre>
</div>
</div>
</li>
<li>
<p>The extractor for cascaded validation is determined based on an element&#8217;s runtime type:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#0a8;font-weight:bold">Collection</span>&lt;<span style="color:#007">@Valid</span> Order&gt; orders = <span style="color:#080;font-weight:bold">new</span> <span style="color:#0a8;font-weight:bold">ArrayList</span>&lt;&gt;();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here the most-specific extractor for the runtime type <code>ArrayList</code> must be applied, causing the property nodes of violations to have an index set (<code>Node#getIndex()</code>).</p>
</div>
</li>
<li>
<p>The container value passed to a value extractor is retrieved from the element that has the type argument carrying the constraint or <code>@Valid</code> annotation:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">private</span> <span style="color:#0a8;font-weight:bold">Map</span>&lt;<span style="color:#0a8;font-weight:bold">String</span>, <span style="color:#007">@Valid</span> <span style="color:#007">@RetailOrder</span> Order&gt; ordersByName;

<span style="color:#088;font-weight:bold">public</span> <span style="color:#0a8;font-weight:bold">Map</span>&lt;<span style="color:#007">@NotNull</span> <span style="color:#0a8;font-weight:bold">String</span>, Order&gt; getOrdersByName() {
    <span style="color:#080;font-weight:bold">return</span> ordersByName;
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>When validating the <code>@NotNull</code> constraint, the map as returned by the getter will be passed to the map key extractor in order to obtain the map keys.
When validating the <code>@RetailOrder</code> constraint and performing cascaded validation,
the map as obtained directly from the field will be passed to the map value extractor in order to obtain the map values.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Custom extractor for a <code>Tuple</code> type:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">interface</span> <span style="color:#B06;font-weight:bold">Tuple</span>&lt;T1, T2&gt; {
    T1 getFirst();
    T2 getSecond();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">TupleFirstExtractor</span> <span style="color:#088;font-weight:bold">implements</span> ValueExtractor&lt;Tuple&lt;<span style="color:#007">@ExtractedValue</span> ?, ?&gt;&gt; {

        <span style="color:#007">@Override</span>
        <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> extractValues(Tuple&lt;?, ?&gt; originalValue, ValueReceiver receiver) {
                receiver.value( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">&lt;first&gt;</span><span style="color:#710">&quot;</span></span>, originalValue.getFirst() );
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">TupleSecondExtractor</span> <span style="color:#088;font-weight:bold">implements</span> ValueExtractor&lt;Tuple&lt;?, <span style="color:#007">@ExtractedValue</span> ?&gt;&gt; {

        <span style="color:#007">@Override</span>
        <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> extractValues(Tuple&lt;?, ?&gt; originalValue, ValueReceiver receiver) {
                receiver.value( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">&lt;second&gt;</span><span style="color:#710">&quot;</span></span>, originalValue.getSecond() );
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">private</span> Tuple&lt;<span style="color:#007">@NotNull</span> <span style="color:#007">@Email</span> <span style="color:#0a8;font-weight:bold">String</span>, <span style="color:#007">@NotNull</span> <span style="color:#007">@Min</span>(<span style="color:#00D">1</span>) <span style="color:#0a8;font-weight:bold">Integer</span>&gt; tuple;</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="examples-for-extractor-retrieval"><a class="anchor" href="#examples-for-extractor-retrieval"></a>Examples for extractor retrieval</h5>
<div class="ulist">
<ul>
<li>
<p>The most specific extractor matching the constrained type argument is chosen:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">private</span> <span style="color:#0a8;font-weight:bold">List</span>&lt;<span style="color:#007">@Email</span> <span style="color:#0a8;font-weight:bold">String</span>&gt; emails;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Based on the algorithm described above and considering the mandated default extractors, only the extractor for <code>List</code> and <code>Iterable</code> are candidate extractors (all other extractors are defined for a type parameter not mapping to <code>T</code> of <code>List</code>). The extractor for <code>List</code> will be applied as it&#8217;s more specific than the extractor for <code>Iterable</code> (<code>List</code> is a subtype of <code>Iterable</code>).</p>
</div>
</li>
<li>
<p>Constraints targeting wrapped values can be given on the wrapping element.
Let there be these definitions:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">StringWrapper</span> {
    <span style="color:#0a8;font-weight:bold">String</span> wrapped;
};</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#007">@UnwrapByDefault</span>
<span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">StringWrapperExtractor</span> <span style="color:#088;font-weight:bold">implements</span> ValueExtractor&lt;<span style="color:#007">@ExtractedValue</span> StringWrapper&gt; { ... }
};</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">private</span> <span style="color:#007">@Email</span> StringWrapper email;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@Email</code> constraint will be applied to the wrapped string and can be validated as the extractor defines that element-level constraints should be applied to the wrapped value.</p>
</div>
<div class="paragraph">
<p>If the extractor were not decorated with <code>@UnwrapByDefault</code> an exception would be raised as there is no validator for <code>@Email</code> on <code>StringWrapper</code>.</p>
</div>
<div class="paragraph">
<p>Unwrapping could be mandated explicitly in this case:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#007">@Email</span>(payload = Unwrapping.Unwrap.class)
<span style="color:#088;font-weight:bold">private</span> StringWrapper email;</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="invalid-examples"><a class="anchor" href="#invalid-examples"></a>Invalid examples</h5>
<div class="ulist">
<ul>
<li>
<p>No most specific extractor can be found unambiguously:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">interface</span> <span style="color:#B06;font-weight:bold">CachedValue</span>&lt;V&gt; {
    V getCachedValue();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">interface</span> <span style="color:#B06;font-weight:bold">RealValue</span>&lt;V&gt; {
    V getRealValue();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">CachableValue</span>&lt;V&gt; <span style="color:#088;font-weight:bold">implements</span> CachedValue&lt;V&gt;, RealValue&lt;V&gt; { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">CachedValueExtractor</span> <span style="color:#088;font-weight:bold">implements</span> ValueExtractor&lt;CachedValue&lt;<span style="color:#007">@ExtractedValue</span> ?&gt;&gt; { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">RealValueExtractor</span> <span style="color:#088;font-weight:bold">implements</span> ValueExtractor&lt;RealValue&lt;<span style="color:#007">@ExtractedValue</span> ?&gt;&gt; { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">private</span> CachableValue&lt;<span style="color:#007">@Min</span>(<span style="color:#00D">1</span>) <span style="color:#0a8;font-weight:bold">Integer</span>&gt; foo;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Validation of <code>foo</code> will fail, as none of the two matching extractors is more specific than the other one.
An extractor for <code>CachableValue</code> must be added, resolving the ambiguity.</p>
</div>
</li>
<li>
<p>Element-level constraints cannot be applied if there is no type parameter at all or multiple non-mapping type parameters in the annotated element&#8217;s type hierarchy.
Thus an exception will be raised in the following cases:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#777">// no type parameter</span>
<span style="color:#007">@Email</span>(payload = Unwrapping.Unwrap.class)
<span style="color:#088;font-weight:bold">private</span> <span style="color:#0a8;font-weight:bold">String</span> email;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#777">// multiple type parameters</span>
<span style="color:#007">@Email</span>(payload = Unwrapping.Unwrap.class)
<span style="color:#088;font-weight:bold">private</span> <span style="color:#0a8;font-weight:bold">Map</span>&lt;<span style="color:#0a8;font-weight:bold">String</span>, <span style="color:#0a8;font-weight:bold">String</span>&gt; emails;</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xml-based-configuration"><a class="anchor" href="#xml-based-configuration"></a>XML based configuration</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="metadata-retrieval"><a class="anchor" href="#metadata-retrieval"></a>Metadata retrieval</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="misc"><a class="anchor" href="#misc"></a>Misc.</h4>
<div class="ulist">
<ul>
<li>
<p>Regarding group sequences and default group sequences, the same rules apply for type argument constraints as they apply for regular element-level constraints.</p>
</li>
<li>
<p>For the conversion of validation groups the same rules apply no matter whether <code>@Valid</code> is given for a regular element or for a type argument.
I.e. the following group conversion declaration is valid:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">private</span> <span style="color:#0a8;font-weight:bold">List</span>&lt;<span style="color:#007">@Valid</span> <span style="color:#007">@ConvertGroup</span>(from=Default.class, to=Other.class) Order&gt; orders;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="open-questions"><a class="anchor" href="#open-questions"></a>Open questions</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Should nested containers be supported: <code>List&lt;Map&lt;String, @NotNull String&gt;&gt; addressesByType</code>?
Or <code>Optional&lt;List&lt;@Email&gt;&gt; optionalEmails</code>;
The latter seems very reasonable.</p>
</li>
<li>
<p><span class="line-through"><code>ConstraintsApplyTo</code> only allows one behavior per annotated element. Should it be per constraint?</span>
<span class="line-through">E.g. for <code>@NotNull @Email StringProperty email</code> it may be desirable to apply <code>@NotNull</code> to the wrapper but <code>@Email</code> to the wrapped value. That&#8217;s not possible currently.</span></p>
<div class="paragraph">
<p><em>For the first draft we settled for using dedicated <code>Payload</code> types to control the unwrapping behavior.</em>
<em>While not ideal, this provides the required level of control.</em>
<em>Discussed alternatives include a new constraint member <code>boolean validateWrappedValue()</code>, but this requires to update every existing constraint and adds a lot of "weight" for a rather small corner case.</em>
<em>Any approach using a separate annotation fails as there is no way to clearly identify the targeted constraint annotation, as annotations cannot obtained from an element in a guaranteed order</em>.</p>
</div>
</li>
<li>
<p><span class="line-through">Should <code>ConstraintsApplyTo</code> also be used for tagging extractors triggering "auto-extraction". Maybe a separate annotation would be less confusing, e.g. <code>@AutoExtract</code> or so?</span></p>
<div class="paragraph">
<p><em>This is done by <code>@UnwrapByDefault</code> now which solely exists for this purpose.</em></p>
</div>
</li>
<li>
<p>Should a path node be added for type argument constraints of <code>Optional</code> and similar types?</p>
<div class="paragraph">
<p><em>This proposal suggests to not do it, but Emmanuel is not convinced of this</em>.</p>
</div>
</li>
<li>
<p><span class="line-through">Should value extractors be discoverable via the service loader mechanism (i.e. by means of <code>META-INF/services/javax.validation.valueextraction.ValueExtractor</code> files)</span></p>
<div class="paragraph">
<p><span class="line-through">Pro: It&#8217;d allow 3rd party libs such as Google Guava to provide custom extractors for their container types and have them automatically be applied without any effort for the user.</span></p>
</div>
<div class="paragraph">
<p><span class="line-through">Cons: Need a way to disable or override some extractors with others. Which might make it a nogo.</span></p>
</div>
<div class="paragraph">
<p><em>Added service loader mechanism as source of value extractors. Specified order of precedence.</em></p>
</div>
</li>
<li>
<p>What to return from <code>PropertyDescriptor#getElementClass()</code> if there is a field of type <code>Foo</code> but a getter of type <code>Optional&lt;Foo&gt;</code>.
So far, BV assumed the types of field and getter to be the same and exposed a single property descriptor
(which btw. also may fall apart as of BV 1.1 when the field is of a sub-type of the getter&#8217;s type).
What to return here?</p>
</li>
<li>
<p><span class="line-through">Should the presence of type argument constraints alone trigger cascaded validation?</span></p>
<div class="paragraph">
<p><span class="line-through">E.g. consider the case of <code>Tuple</code> above:</span></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Tuple&lt;<span style="color:#007">@Min</span>(<span style="color:#00D">1</span>) <span style="color:#0a8;font-weight:bold">Integer</span>, <span style="color:#007">@Email</span> <span style="color:#0a8;font-weight:bold">String</span>&gt; tuple;</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="line-through"><em>Here it may be nice to validate e.g. <code>@NotNull</code> constraints given within the <code>Tuple</code> class itself when validating the type argument constraints. With the current proposal their validation requires a separate <code>@Valid</code> on the element. Personally I think that&#8217;s better (more consistent)</em>.</span></p>
</div>
<div class="paragraph">
<p><em>We agreed to require <code>@Valid</code> for the sake of consistency.</em></p>
</div>
</li>
<li>
<p>For an element with a type argument, should it be allowed to specify constraints on the element (and use the <code>Unwrapping.Unwrap</code> payload) or should it be disallowed?</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#007">@Email</span>(payload = Unwrapping.Unwrap.class) Optional&lt;<span style="color:#0a8;font-weight:bold">String</span>&gt; email;</code></pre>
</div>
</div>
</li>
<li>
<p><span class="line-through">Should we allow extractors to be defined for specific parameterized types, e.g.:</span></p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">ListOfIntegerExtractor</span> <span style="color:#088;font-weight:bold">implements</span> ValueExtractor&lt;<span style="color:#0a8;font-weight:bold">List</span>&lt;<span style="color:#007">@ExtractedValue</span> <span style="color:#0a8;font-weight:bold">Integer</span>&gt;&gt; { ... }

<span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">ListOfStringExtractor</span> <span style="color:#088;font-weight:bold">implements</span> ValueExtractor&lt;<span style="color:#0a8;font-weight:bold">List</span>&lt;<span style="color:#007">@ExtractedValue</span> <span style="color:#0a8;font-weight:bold">String</span>&gt;&gt; { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="line-through">Currently, only one extractor (for type <code>List&lt;?&gt;</code> is allowed).</span></p>
</div>
<div class="paragraph">
<p><span class="line-through"><em>I can&#8217;t see a compelling use case for this (when would extractor behavior differ between different parameterizations of the same generic type) and am leaning towards only supporting the wildcard parameterization (<code>implements ValueExtractor&lt;List&lt;@ExtractedValue ?&gt;&gt;</code>)</em>.</span></p>
</div>
<div class="paragraph">
<p><em>We agreed on only allowing one extractor per type, to be given using the wildcard parameterization, as we cannot see a use case for having multiple extractors right now.</em>
<em>But if needed, this limitation can be lifted in a future revision.</em></p>
</div>
</li>
<li>
<p>Can we find another name than "type argument constraints"? While that suits for the most cases, it doesn&#8217;t when applying constraints to the component type of an array: <code>String @NotBlank [] names</code>.</p>
<div class="paragraph">
<p><em>I think "type use" is the correct one in Java terminology. But would anyone get what a "type use constraint" is?</em>.</p>
</div>
</li>
<li>
<p>Vet the API by exploring advanced use cases, e.g. Guava&#8217;s <a href="https://github.com/google/guava/wiki/NewCollectionTypesExplained#table">Table</a>, <a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/graph/Graph.html">Graph</a>, <a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/graph/ValueGraph.html">ValueGraph</a> and <a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/graph/Network.html">Network</a> types.</p>
<div class="paragraph">
<p>Example for <code>Table</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">TableValueExtractor</span> <span style="color:#088;font-weight:bold">implements</span> ValueExtractor&lt;Table&lt;?, ?, <span style="color:#007">@ExtractedValue</span> ?&gt;&gt; {

        <span style="color:#007">@Override</span>
        <span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">void</span> extractValues(Table&lt;?, ?, ?&gt; originalValue, ValueExtractor.ValueReceiver receiver) {

                <span style="color:#080;font-weight:bold">for</span> ( Cell&lt;?, ?, ?&gt; cell : originalValue.cellSet() ) {
                        receiver.keyedValue(
                                        <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">&lt;table cell&gt;</span><span style="color:#710">&quot;</span></span>,
                                        <span style="color:#080;font-weight:bold">new</span> CellKey( cell.getRowKey(), cell.getColumnKey() ),
                                        cell.getValue()
                        );
                }
        }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#088;font-weight:bold">static</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">CellKey</span> {

        <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">Object</span> rowKey;
        <span style="color:#088;font-weight:bold">private</span> <span style="color:#088;font-weight:bold">final</span> <span style="color:#0a8;font-weight:bold">Object</span> columnKey;

        <span style="color:#088;font-weight:bold">public</span> CellKey(<span style="color:#0a8;font-weight:bold">Object</span> rowKey, <span style="color:#0a8;font-weight:bold">Object</span> columnKey) {
                <span style="color:#950">this</span>.rowKey = rowKey;
                <span style="color:#950">this</span>.columnKey = columnKey;
        }

        <span style="color:#777">// equals(), hashCode() ...</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When having an invalid table cell in the following and validating it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#088;font-weight:bold">public</span> <span style="color:#339;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Customer</span> {

    Table&lt;Year, <span style="color:#0a8;font-weight:bold">String</span>, <span style="color:#007">@Min</span>(<span style="color:#00D">1</span>) <span style="color:#0a8;font-weight:bold">Integer</span>&gt; revenuePerYearAndCategory = HashBasedTable.create();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then this will be the result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ConstraintViolation&lt;Customer&gt; violation = ...;

<span style="color:#0a8;font-weight:bold">Iterator</span>&lt;Node&gt; path = violation.getPropertyPath().iterator();

Node node = path.next();
assertThat( node.getName() ).isEqualTo( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">revenuePerYearAndCategory</span><span style="color:#710">&quot;</span></span> );
assertThat( node.getKind() ).isEqualTo( ElementKind.PROPERTY );
assertThat( node.getKey() ).isNull();
assertThat( node.getIndex() ).isNull();

node = path.next();
assertThat( node.getName() ).isEqualTo( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">&lt;table cell&gt;</span><span style="color:#710">&quot;</span></span> );
assertThat( node.getKind() ).isEqualTo( ElementKind.CONTAINER_ELEMENT );
assertThat( node.getKey() ).isEqualTo( <span style="color:#080;font-weight:bold">new</span> CellKey(Year.of( <span style="color:#00D">2015</span> ), <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">cds</span><span style="color:#710">&quot;</span></span>) );
assertThat( node.getIndex() ).isNull();

assertThat( path.hasNext() ).isFalse();</code></pre>
</div>
</div>
</li>
<li>
<p>In the original proposal it was foreseen that <code>@ExtractedValue</code> could refer to type-parameters from super-types. Is that still needed?</p>
</li>
<li>
<p>During cascaded validation of an element with several type arguments, it&#8217;s currently not possible to tell from the resulting constraint violation and its node path which type argument was cascaded.
Example:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#0a8;font-weight:bold">Map</span>&lt;<span style="color:#007">@Valid</span> OrderType, <span style="color:#007">@Valid</span> Order&gt; ordersByType;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If there was constraint violation on an <code>OrderType</code> property and one on an <code>Order</code> property, one couldn&#8217;t tell from the resulting paths and their nodes which is which.</p>
</div>
<div class="paragraph">
<p><em>One way out could be to add <code>TypeVariable&lt;?&gt; Node#getTypeParameter()</code> </em>.</p>
</div>
<div class="paragraph">
<p><em>This would return the type parameter handled by the extractor used for obtaining the cascaded value</em>.
<em> <code>Node#getTypeParameter()</code> would also return the type parameter for type argument constraints</em>.
<em>Note it must be <code>getTypeParameter()</code> (not <code>getTypeArgument()</code>) because one annotated type argument at the constrained/cascaded element could represent multiple type parameters (see example "A type parameter in a sub-type may also map to several type parameters in a super-type" above).</em>
<em>Assuming a constraint violation on property <code>description</code> of class <code>OrderType</code> we&#8217;d get</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ConstraintViolation&lt;Customer&gt; violation = ...;

<span style="color:#0a8;font-weight:bold">Iterator</span>&lt;Node&gt; path = violation.getPropertyPath().iterator();

Node node = path.next();
assertThat( node.getName() ).isEqualTo( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">ordersByType</span><span style="color:#710">&quot;</span></span> );
assertThat( node.getKind() ).isEqualTo( ElementKind.PROPERTY );
assertThat( node.getKey() ).isNull();
assertThat( node.getIndex() ).isNull();
assertThat( node.getTypeParameter() ).isNull();

node = path.next();
assertThat( node.getName() ).isEqualTo( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">description</span><span style="color:#710">&quot;</span></span> );
assertThat( node.getKind() ).isEqualTo( ElementKind.PROPERTY );
assertThat( node.getKey() ).isEqualTo( <span style="color:#080;font-weight:bold">new</span> OrderType( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">RETAIL</span><span style="color:#710">&quot;</span></span> ) );
assertThat( node.getIndex() ).isNull();
assertThat( node.getTypeParameter().getName() ).isEqualTo( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">K</span><span style="color:#710">&quot;</span></span> );

assertThat( path.hasNext() ).isFalse();</code></pre>
</div>
</div>
<div class="paragraph">
<p><em> <code>getTypeParameter()</code> would also return the type parameter in case of type argument constraints:</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span style="color:#0a8;font-weight:bold">Map</span>&lt;OrderType, <span style="color:#007">@Min</span>(<span style="color:#00D">1</span>) <span style="color:#0a8;font-weight:bold">Integer</span>&gt; orderQuantitiesByType;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ConstraintViolation&lt;Customer&gt; violation = ...;

<span style="color:#0a8;font-weight:bold">Iterator</span>&lt;Node&gt; path = violation.getPropertyPath().iterator();

Node node = path.next();
assertThat( node.getName() ).isEqualTo( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">orderQuantitiesByType</span><span style="color:#710">&quot;</span></span> );
assertThat( node.getKind() ).isEqualTo( ElementKind.PROPERTY );
assertThat( node.getKey() ).isNull();
assertThat( node.getIndex() ).isNull();
assertThat( node.getTypeParameter() ).isNull();

node = path.next();
assertThat( node.getName() ).isEqualTo( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">&lt;map value&gt;</span><span style="color:#710">&quot;</span></span> );
assertThat( node.getKind() ).isEqualTo( ElementKind.CONTAINER_ELEMENT );
assertThat( node.getKey() ).isEqualTo( <span style="color:#080;font-weight:bold">new</span> OrderType( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">RETAIL</span><span style="color:#710">&quot;</span></span> ) );
assertThat( node.getIndex() ).isNull();
assertThat( node.getTypeParameter().getName() ).isEqualTo( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">V</span><span style="color:#710">&quot;</span></span> );

assertThat( path.hasNext() ).isFalse();</code></pre>
</div>
</div>
</li>
<li>
<p>Revisit the names of nodes of kind <code>CONTAINER_ELEMENT</code>;
instead of <code>&lt;iterable element&gt;</code>, <code>&lt;map value&gt;</code> etc. should it be the names of the type parameters in question, i.e. <code>&lt;E&gt;</code>, <code>&lt;V&gt;</code> etc.?</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-01-02 20:53:47 UTC
</div>
</div>
</body>
</html>