<html>
  <head>
    <meta charset="UTF-8">
    <meta content="IE=Edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>
      Bean Validation - Improve metadata API to be more friendly towards method interceptor integrators
    </title>
    <link href="../../stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="../../stylesheets/print.css" media="print" rel="stylesheet" type="text/css">
    <!--[if lt IE 8]>
      <link href="../../stylesheets/ie.css" media="screen, projection" rel="stylesheet" type="text/css">
    <![endif]-->
    <link href="../../news/news.atom" rel="alternate" type="application/atom+xml">
    <script src="//code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="/javascripts/patternfly.js"></script>
    <script src="/javascripts/bootstrap.js"></script>
  </head>
  <body>
    <header role="banner">
      <nav class="navbar navbar-default navbar-pf" role="navigation">
        <div class="navbar-header">
          <button class="navbar-toggle" data-target=".navbar-collapse-1" data-toggle="collapse" type="button">
            <span class="sr-only">Toggle Navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../.." id="logo" title="Bean Validation">
            Bean Validation
          </a>
        </div>
        <div class="collapse navbar-collapse navbar-collapse-1">
          <ul class="nav navbar-nav navbar-primary navbar-right" id="meny-primary">
            <li class="menu-item menu-item-type-post_type menu-item-object-page">
              <a href="../..">Home</a>
            </li>
            <li class="menu-item menu-item-type-post_type menu-item-object-page">
              <a href="../../news">News</a>
            </li>
            <li class="menu-item menu-item-type-post_type menu-item-object-page">
              <a href="../../1.1">Specification</a>
            </li>
            <li class="menu-item menu-item-type-post_type menu-item-object-page">
              <a href="../../1.1/tck">TCK</a>
            </li>
            <li class="menu-item menu-item-type-post_type menu-item-object-page">
              <a href="../../1.1/ri">RI</a>
            </li>
            <li class="menu-item menu-item-type-post_type menu-item-object-page">
              <a href="../../1.1/certified">Certified</a>
            </li>
            <li class="menu-item menu-item-type-post_type menu-item-object-page">
              <a href="../../contribute">Contribute</a>
            </li>
            <li class="menu-item menu-item-type-post_type menu-item-object-page">
              <a href="../../licensing">Licensing</a>
            </li>
          </ul>
        </div>
      </nav>
    </header>
    <div class="container" id="overview">
      <div class="clearfix row" id="content">
        <div class="col-sm-12 col-md-12 col-lg-12 clearfix" id="main">
          <h1>Improve metadata API to be more friendly towards method interceptor integrators</h1>
          <p><a href="https://hibernate.onjira.com/browse/BVAL-274">Link to JIRA ticket</a></p>
          
          <h2>Problem</h2>
          
          <p>I was looking at how to compute whether or not method interception needs
          to occur via on the metadata API.</p>
          
          <p>The validation of method-level constraints comprises the following steps:</p>
          
          <ul>
          <li>Intercept the method call to be validated</li>
          <li>Validate the parameter values provided by the method caller using Validator#validateParameters() or Validator#validateConstructorParameters().</li>
          <li>If this validation yields a non-empty set of constraint violations, throw a ConstraintViolationException wrapping the violations. Otherwise proceed with the actual method invocation.</li>
          <li>Validate the result returned by the invoked method using Validator#validateReturnValue() or Validator#validateConstructorReturnValue().</li>
          <li>If this validation yields a non-empty set of constraint violations, throw a ConstraintViolationException wrapping the violations. Otherwise return the invocation result to the method caller.</li>
          </ul>
          
          
          <p>I realised that we have a cumbersome API to detect whether or not
          calling Bean Validation.</p>
          
          <pre><code>public boolean interceptMethod(Class&lt;?&gt; type, Method method) {&#x000A;    BeanDescriptor bean = validator.getConstraintsForClass( type );&#x000A;    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod( method.getName(), method.getParameterTypes() );&#x000A;    return methodDescriptor != null;&#x000A;}&#x000A;&#x000A;public boolean validateMethodParametersWithFullNavigation(Class&lt;?&gt; type, Method method) {&#x000A;    BeanDescriptor bean = validator.getConstraintsForClass( type );&#x000A;    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod( method.getName(), method.getParameterTypes() );&#x000A;    if ( methodDescriptor != null ) {&#x000A;        boolean validate = false;&#x000A;        for (ParameterDescriptor paramDescriptor : methodDescriptor.getParameterDescriptors()) {&#x000A;            validate = paramDescriptor.hasConstraints() || paramDescriptor.isCascaded();&#x000A;            if (validate) {&#x000A;                break;&#x000A;            }&#x000A;        }&#x000A;        return validate;&#x000A;    }&#x000A;    else {&#x000A;        return false;&#x000A;    }&#x000A;}&#x000A;&#x000A;public boolean validateReturnValueWithFullNavigation(Class&lt;?&gt; type, Method method) {&#x000A;    BeanDescriptor bean = validator.getConstraintsForClass( type );&#x000A;    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod( method.getName(), method.getParameterTypes() );&#x000A;    if ( methodDescriptor != null ) {&#x000A;        boolean validate = false;&#x000A;        ReturnValueDescriptor returnValue = methodDescriptor.getReturnValueDescriptor();&#x000A;        if ( returnValue!=null ) {&#x000A;            return returnValue.isCascaded() || returnValue.hasConstraints();&#x000A;        }&#x000A;        else {&#x000A;            return false;&#x000A;        }&#x000A;    }&#x000A;    else {&#x000A;        return false;&#x000A;    }&#x000A;}&#x000A;</code></pre>
          
          <p><code>interceptMethod</code> is used to decide whether or not we intercept the method
          at all. it can be used to disable the interceptor entirely.</p>
          
          <p><code>validateMethodParametersWithFullNavigation</code> is used to decide whether
          or not we need to call <code>validator.validateParameters()</code>. If no violation
          is found, we goa nd execute the method.</p>
          
          <p>After the method returns, we call
          <code>validateReturnValueWithFullNavigation</code> to decide whether or not to
          validate return value.</p>
          
          <p>There is of course the equivalent for constructor validation.</p>
          
          <h2>Proposal</h2>
          
          <p>What I am proposing is to add two aggregate methods to
          <code>MethodDescriptor</code> and <code>ConstructorDescriptor</code>.</p>
          
          <pre><code>/**&#x000A; * Returns true if method parameters are constrained either:&#x000A; * - because of a constraint on at least one of the parameters&#x000A; * - because of a cascade on at least one of the parameters (via {@code @Valid})&#x000A; * - because of at least a cross-parameter constraint&#x000A; */&#x000A;boolean isConstrainedOnParameters();&#x000A;&#x000A;/**&#x000A; * Returns true if the method return value is constrained either:&#x000A; * - because of a constraint on the return value&#x000A; * - because validation is cascaded on the return value (via {@code @Valid})&#x000A; */&#x000A;boolean isConstrainedOnReturnValue();&#x000A;</code></pre>
          
          <p>The implementation would then become</p>
          
          <pre><code>public boolean validateMethodParametersWithMethodDescriptorShortcuts(Class&lt;?&gt; type, Method method) {&#x000A;    BeanDescriptor bean = validator.getConstraintsForClass( type );&#x000A;    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod( method.getName(), method.getParameterTypes() );&#x000A;    if ( methodDescriptor != null ) {&#x000A;        return methodDescriptor.isConstrainedOnParameters();&#x000A;    }&#x000A;    else {&#x000A;        return false;&#x000A;    }&#x000A;}&#x000A;&#x000A;public boolean validateMethodReturnValueWithMethodDescriptorShortcuts(Class&lt;?&gt; type, Method method) {&#x000A;    BeanDescriptor bean = validator.getConstraintsForClass( type );&#x000A;    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod( method.getName(), method.getParameterTypes() );&#x000A;    if ( methodDescriptor != null ) {&#x000A;        return methodDescriptor.isConstrainedOnReturnValue();&#x000A;    }&#x000A;    else {&#x000A;        return false;&#x000A;    }&#x000A;}&#x000A;</code></pre>
          
          <p>Of course the lookup of <code>BeanDescriptor</code> and <code>MethodDescriptor</code> only has
          to be done once. The methods result is also likely being cached by the
          interceptor being placed and these calls are probably only happening at
          initialization time.</p>
          
          <p>An alternative solution is to use the fluent API to find constraints</p>
          
          <pre><code>public boolean validateMethodParametersWithFindConstraintAPI(Class&lt;?&gt; type, Method method) {&#x000A;    BeanDescriptor bean = validator.getConstraintsForClass( type );&#x000A;    MethodDescriptor methodDescriptor = bean.getConstraintsForMethod( method.getName(), method.getParameterTypes() );&#x000A;    if ( methodDescriptor != null ) {&#x000A;        return methodDescriptor.findConstraints().declaredOn( ElementType.PARAMETER ).hasConstraints();&#x000A;    }&#x000A;    else {&#x000A;        return false;&#x000A;    }&#x000A;}&#x000A;</code></pre>
          
          <p>But it's not 100% in line with the <code>findConstraints()</code> API: it should only return constraints
          that are on the element. Plus what is returned by the API is
          <code>ConstraintDescriptor</code> which cannot differentiate where it comes from (parameter or method).</p>
          
          <h2>Implementation notes</h2>
          
          <p>Specify that <code>ElementDescriptor.hasConstraints()</code> does not return true for a <code>MethodDescriptor</code>
          when:</p>
          
          <ul>
          <li>method parameters are constrained</li>
          <li>cross-parameter constraints are declared on the method</li>
          </ul>
          
                      <div id="disqus_thread"></div>
                      <script type="text/javascript">
                      var disqus_shortname = 'beanvalidation';
                      var disqus_url = "http://beanvalidation.org/proposals/BVAL-274/";
                      var disqus_developer = null;
                      var disqus_identifier = null;
                      (function() {
                        var dsq = document.createElement("script"); dsq.type = "text/javascript"; dsq.async = true;
                        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                        (document.getElementsByTagName("head")[0] || document.getElementsByTagName("body")[0]).appendChild(dsq);
                      })();
                      </script>
                      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=beanvalidation">comments powered by Disqus.</a></noscript>
        </div>
      </div>
    </div>
  </body>
  <footer class="container" id="widget-footer" role="contentinfo">
    <hr>
    <div class="row">
      <div class="widget col-md-12 widget_text">
        Copyright (c) Red Hat, Inc., Emmanuel Bernard
        <a href="http://redhat.com" id="logo-redhat">Red Hat</a>
      </div>
    </div>
  </footer>
</html>
